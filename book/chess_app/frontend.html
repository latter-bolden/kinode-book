<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adding a Frontend - Kinode Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/fonts/custom-fonts.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../identity_system.html">Identity System</a></li><li class="chapter-item expanded affix "><a href="../design_philosophy.html">Design Philosophy</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="../install.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../login.html"><strong aria-hidden="true">2.</strong> Join the Network</a></li><li class="chapter-item expanded affix "><li class="part-title">System Components</li><li class="chapter-item expanded "><a href="../processes.html"><strong aria-hidden="true">3.</strong> Processes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process-capabilities.html"><strong aria-hidden="true">3.1.</strong> Capability-Based Security</a></li><li class="chapter-item expanded "><a href="../process-startup.html"><strong aria-hidden="true">3.2.</strong> Startup, Spindown, and Crashes</a></li></ol></li><li class="chapter-item expanded "><a href="../networking_protocol.html"><strong aria-hidden="true">4.</strong> Networking Protocol</a></li><li class="chapter-item expanded "><a href="../pki.html"><strong aria-hidden="true">5.</strong> Public Key Infrastructure</a></li><li class="chapter-item expanded "><a href="../http_server_and_client.html"><strong aria-hidden="true">6.</strong> HTTP Server & Client</a></li><li class="chapter-item expanded "><a href="../files.html"><strong aria-hidden="true">7.</strong> Files</a></li><li class="chapter-item expanded "><a href="../databases.html"><strong aria-hidden="true">8.</strong> Databases</a></li><li class="chapter-item expanded affix "><li class="part-title">Process Standard Library</li><li class="chapter-item expanded "><a href="../process_stdlib/overview.html"><strong aria-hidden="true">9.</strong> Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Kit: Development Toolkit</li><li class="chapter-item expanded "><a href="../kit/kit.html"><strong aria-hidden="true">10.</strong> kit</a></li><li class="chapter-item expanded "><a href="../kit/boot-fake-node.html"><strong aria-hidden="true">11.</strong> boot-fake-node</a></li><li class="chapter-item expanded "><a href="../kit/new.html"><strong aria-hidden="true">12.</strong> new</a></li><li class="chapter-item expanded "><a href="../kit/build.html"><strong aria-hidden="true">13.</strong> build</a></li><li class="chapter-item expanded "><a href="../kit/start-package.html"><strong aria-hidden="true">14.</strong> start-package</a></li><li class="chapter-item expanded "><a href="../kit/remove-package.html"><strong aria-hidden="true">15.</strong> remove-package</a></li><li class="chapter-item expanded "><a href="../kit/dev-ui.html"><strong aria-hidden="true">16.</strong> dev-ui</a></li><li class="chapter-item expanded "><a href="../kit/inject-message.html"><strong aria-hidden="true">17.</strong> inject-message</a></li><li class="chapter-item expanded "><a href="../kit/run-tests.html"><strong aria-hidden="true">18.</strong> run-tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial: Build and Deploy an App</li><li class="chapter-item expanded "><a href="../my_first_app/chapter_1.html"><strong aria-hidden="true">19.</strong> Environment Setup</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_2.html"><strong aria-hidden="true">20.</strong> Sending Some Messages, Using Some Tools</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_3.html"><strong aria-hidden="true">21.</strong> Defining Your Protocol</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_4.html"><strong aria-hidden="true">22.</strong> Frontend Time</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_5.html"><strong aria-hidden="true">23.</strong> Sharing with the World</a></li><li class="chapter-item expanded affix "><li class="part-title">In-Depth Guide: Chess App</li><li class="chapter-item expanded "><a href="../chess_app/chess_engine.html"><strong aria-hidden="true">24.</strong> Chess Engine</a></li><li class="chapter-item expanded "><a href="../chess_app/frontend.html" class="active"><strong aria-hidden="true">25.</strong> Adding a Frontend</a></li><li class="chapter-item expanded "><a href="../chess_app/putting_everything_together.html"><strong aria-hidden="true">26.</strong> Putting Everything Together</a></li><li class="chapter-item expanded "><a href="../chess_app/chat.html"><strong aria-hidden="true">27.</strong> Extension 1: Chat</a></li><li class="chapter-item expanded affix "><li class="part-title">Cookbook (Handy Recipes)</li><li class="chapter-item expanded "><a href="../cookbook/cookbook_overview.html"><strong aria-hidden="true">28.</strong> Cookbook Overview</a></li><li class="chapter-item expanded "><a href="../cookbook/manage_child_processes.html"><strong aria-hidden="true">29.</strong> Managing Child Processes</a></li><li class="chapter-item expanded "><a href="../cookbook/publish_to_web.html"><strong aria-hidden="true">30.</strong> Publishing a Website or Web App</a></li><li class="chapter-item expanded "><a href="../cookbook/file_transfer.html"><strong aria-hidden="true">31.</strong> Simple File Transfer Guide</a></li><li class="chapter-item expanded affix "><li class="part-title">API Reference</li><li class="chapter-item expanded "><a href="../apis/overview.html"><strong aria-hidden="true">32.</strong> APIs Overview</a></li><li class="chapter-item expanded "><a href="../apis/http_authentication.html"><strong aria-hidden="true">33.</strong> HTTP API</a></li><li class="chapter-item expanded "><a href="../apis/http_client.html"><strong aria-hidden="true">34.</strong> HTTP Client API</a></li><li class="chapter-item expanded "><a href="../apis/http_server.html"><strong aria-hidden="true">35.</strong> HTTP Server API</a></li><li class="chapter-item expanded "><a href="../apis/kernel.html"><strong aria-hidden="true">36.</strong> Kernel API</a></li><li class="chapter-item expanded "><a href="../apis/kv.html"><strong aria-hidden="true">37.</strong> KV API</a></li><li class="chapter-item expanded "><a href="../apis/net.html"><strong aria-hidden="true">38.</strong> Net API</a></li><li class="chapter-item expanded "><a href="../apis/kinode_wit.html"><strong aria-hidden="true">39.</strong> kinode.wit</a></li><li class="chapter-item expanded "><a href="../apis/sqlite.html"><strong aria-hidden="true">40.</strong> SQLite API</a></li><li class="chapter-item expanded "><a href="../apis/terminal.html"><strong aria-hidden="true">41.</strong> Terminal API</a></li><li class="chapter-item expanded "><a href="../apis/vfs.html"><strong aria-hidden="true">42.</strong> VFS API</a></li><li class="chapter-item expanded "><a href="../apis/websocket_authentication.html"><strong aria-hidden="true">43.</strong> Websocket API</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kinode Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="adding-a-frontend"><a class="header" href="#adding-a-frontend">Adding a Frontend</a></h1>
<p>Here, we'll add a web frontend to the code from the <a href="./chess_engine.html">previous section</a>.</p>
<p>Creating a web frontend has two parts:</p>
<ol>
<li>Altering the process code to serve and handle HTTP requests</li>
<li>Writing a webpage to interact with the process.
Here, you'll use React to make a single-page app that displays your current games and allows us to: create new games, resign from games, and make moves on the chess board.</li>
</ol>
<p>JavaScript and React development aren't in the scope of this tutorial, so we'll provide that code <a href="https://github.com/uqbar-dao/chess-ui">here</a>.</p>
<p>The important part of the frontend for the purpose of this tutorial is the build, specifically the <code>pkg/ui</code> directory that will be loaded into the VFS during installation.
Serve these as static files, <a href="https://github.com/uqbar-dao/chess-ui/tree/tutorial/tutorial_build">which you can get here</a> if you don't want to build them yourself.</p>
<p>Run <code>npm run build</code> in the <code>chess-ui</code> repo and copy the output <code>dist</code> folder into the <code>pkg</code> folder in your app, so it'll be ingested on-install.
This allows your process to fetch them from the virtual filesystem, as all files in <code>pkg</code> are mounted.
Rename it to <code>ui</code> so that you have the files in <code>pkg/ui</code>.
See the <a href="../apis/vfs.html">VFS API overview</a> to see how to use files mounted in <code>pkg</code>.</p>
<p>Chess will use the <code>http_server</code> runtime module to serve a static frontend and receive HTTP requests from it.
You'll also use a WebSocket connection to send updates to the frontend when the game state changes.</p>
<p>In <code>my_chess/src/lib.rs</code>, inside <code>init()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use kinode_process_lib::http;
...
// Serve the index.html and other UI files found in pkg/ui at the root path.
http::serve_ui(&amp;our, &quot;ui&quot;).unwrap();

// Allow HTTP requests to be made to /games; they will be handled dynamically.
http::bind_http_path(&quot;/games&quot;, true, false).unwrap();

// Allow websockets to be opened at / (our process ID will be prepended).
http::bind_ws_path(&quot;/&quot;, true, false).unwrap();
...
<span class="boring">}</span></code></pre></pre>
<p>The above code should be inserted into the <code>init()</code> function such that the frontend is served when the process starts.</p>
<p>The <code>http</code> library in <a href="../process_stdlib/overview.html">process_lib</a> provides a simple interface for serving static files and handling HTTP requests.
Use <code>serve_ui</code> to serve the static files includeded in the process binary, and <code>bind_http_path</code> to handle requests to <code>/games</code>.
<code>serve_ui</code> takes two arguments: the process' <code>&amp;Address</code> and the name of the folder inside <code>pkg</code> that contains the <code>index.html</code> and other associated UI files.
See <a href="../process_stdlib/overview.html">process_lib docs</a> for more functions and documentation on their parameters.
These requests all serve HTTP that can only be accessed by a logged-in node user (the <code>true</code> parameter for <code>authenticated</code>) and can be accessed remotely (the <code>false</code> parameter for <code>local_only</code>).
This API is under active development!</p>
<p>Requests on the <code>/games</code> path will arrive as requests to your process, and you'll have to handle them and respond.
The request/response format can be imported from <code>http</code> in <code>process_lib</code>.
To do this, add a branch to the main request-handling function that takes requests from <code>http_server:distro:sys</code>.</p>
<p>In <code>my_chess/src/lib.rs</code>, inside <code>handle_request()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
    } else if message.source().node == our.node
        &amp;&amp; message.source().process == &quot;http_server:distro:sys&quot;
    {
        // receive HTTP requests and websocket connection messages from our server
        match serde_json::from_slice::&lt;http::HttpServerRequest&gt;(message.body())? {
            http::HttpServerRequest::Http(ref incoming) =&gt; {
                match handle_http_request(our, state, incoming) {
                    Ok(()) =&gt; Ok(()),
                    Err(e) =&gt; {
                        println!(&quot;chess: error handling http request: {:?}&quot;, e);
                        http::send_response(
                            http::StatusCode::SERVICE_UNAVAILABLE,
                            None,
                            &quot;Service Unavailable&quot;.to_string().as_bytes().to_vec(),
                        )
                    }
                }
            }
            http::HttpServerRequest::WebSocketOpen { channel_id, .. } =&gt; {
                // We know this is authenticated and unencrypted because we only
                // bound one path, the root path. So we know that client
                // frontend opened a websocket and can send updates
                state.clients.insert(channel_id);
                Ok(())
            }
            http::HttpServerRequest::WebSocketClose(channel_id) =&gt; {
                // client frontend closed a websocket
                state.clients.remove(&amp;channel_id);
                Ok(())
            }
            http::HttpServerRequest::WebSocketPush { .. } =&gt; {
                // client frontend sent a websocket message
                // we don't expect this! we only use websockets to push updates
                Ok(())
            }
        }
    } else {
...
<span class="boring">}</span></code></pre></pre>
<p>This code won't compile yet — you need a new function to handle HTTP requests, and a new state parameter to handle active frontend clients.</p>
<p>Before defining <code>handle_http_request</code>, you need to add a new state parameter in the process state.
The state will keep track of all connected clients in a <code>HashSet&lt;u32&gt;</code> and send updates to them when the game state changes.
You'll also need to update the <code>save_chess_state</code> and <code>load_chess_state</code> functions to handle this new state.</p>
<p>In <code>my_chess/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
#[derive(Debug, Serialize, Deserialize)]
struct ChessState {
    pub games: HashMap&lt;String, Game&gt;, // game is by opposing player id
    pub clients: HashSet&lt;u32&gt;,        // doesn't get persisted
}
...
<span class="boring">}</span></code></pre></pre>
<p><code>clients</code> now holds the channel IDs of all connected clients.
It'll be used to send updates over WebSockets to the frontend when the game state changes.
But wait!
This information shouldn't be persisted because those connections will disappear when the process is killed or the node running this process is turned off.
Instead, create another state type for persistence and convert to/from the in-memory one above when you save process state.</p>
<p>In <code>my_chess/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use std::collections::{HashMap, HashSet};
...
#[derive(Debug, Serialize, Deserialize)]
struct StoredChessState {
    pub games: HashMap&lt;String, Game&gt;, // game is by opposing player id
}

fn save_chess_state(state: &amp;ChessState) {
    set_state(&amp;bincode::serialize(&amp;state.games).unwrap());
}

fn load_chess_state() -&gt; ChessState {
    match get_typed_state(|bytes| Ok(bincode::deserialize::&lt;HashMap&lt;String, Game&gt;&gt;(bytes)?)) {
        Some(games) =&gt; ChessState {
            games,
            clients: HashSet::new(),
        },
        None =&gt; ChessState {
            games: HashMap::new(),
            clients: HashSet::new(),
        },
    }
}
...
<span class="boring">}</span></code></pre></pre>
<p>Now, change the <code>handle_http_request</code> function to take incoming HTTP requests and return HTTP responses.
This will serve the same purpose as the <code>handle_local_request</code> function from the previous chapter, meaning that the frontend will produce actions and the backend will execute them.</p>
<p>An aside: As a process dev, you should be aware that HTTP resources served in this way can be accessed by <em>other processes running on the same node</em>, regardless of whether the paths are authenticated or not.
This can be a security risk: if your app is handling sensitive actions from the frontend, a malicious app could make those API requests instead.
You should never expect users to &quot;only install non-malicious apps&quot; — instead, use a <em>secure subdomain</em> to isolate your app's HTTP resources from other processes.
See the <a href="../apis/http_server.html">HTTP Server API</a> for more details.</p>
<p>In <code>my_chess/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use kinode_process_lib::get_blob;
...
fn handle_http_request(
    our: &amp;Address,
    state: &amp;mut ChessState,
    http_request: &amp;http::IncomingHttpRequest,
) -&gt; anyhow::Result&lt;()&gt; {
    if http_request.path()? != &quot;games&quot; {
        return http::send_response(
            http::StatusCode::NOT_FOUND,
            None,
            &quot;Not Found&quot;.to_string().as_bytes().to_vec(),
        );
    }
    match http_request.method.as_str() {
        // on GET: give the frontend all of our active games
        &quot;GET&quot; =&gt; http::send_response(
            http::StatusCode::OK,
            Some(HashMap::from([(
                String::from(&quot;Content-Type&quot;),
                String::from(&quot;application/json&quot;),
            )])),
            serde_json::to_vec(&amp;state.games)?,
        ),
        // on POST: create a new game
        &quot;POST&quot; =&gt; {
            let Some(blob) = get_blob() else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            let blob_json = serde_json::from_slice::&lt;serde_json::Value&gt;(&amp;blob.bytes)?;
            let Some(game_id) = blob_json[&quot;id&quot;].as_str() else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            if let Some(game) = state.games.get(game_id)
                &amp;&amp; !game.ended
            {
                return http::send_response(http::StatusCode::CONFLICT, None, vec![]);
            };

            let player_white = blob_json[&quot;white&quot;]
                .as_str()
                .unwrap_or(our.node.as_str())
                .to_string();
            let player_black = blob_json[&quot;black&quot;]
                .as_str()
                .unwrap_or(game_id)
                .to_string();

            // send the other player a new game request
            let Ok(msg) = Request::new()
                .target((game_id, our.process.clone()))
                .body(serde_json::to_vec(&amp;ChessRequest::NewGame {
                    white: player_white.clone(),
                    black: player_black.clone(),
                })?)
                .send_and_await_response(5)? else {
                    return Err(anyhow::anyhow!(&quot;other player did not respond properly to new game request&quot;))
                };
            // if they accept, create a new game
            // otherwise, should surface error to FE...
            if serde_json::from_slice::&lt;ChessResponse&gt;(msg.body())? != ChessResponse::NewGameAccepted
            {
                return Err(anyhow::anyhow!(&quot;other player rejected new game request&quot;));
            }
            // create a new game
            let game = Game {
                id: game_id.to_string(),
                turns: 0,
                board: Board::start_pos().fen(),
                white: player_white,
                black: player_black,
                ended: false,
            };
            let body = serde_json::to_vec(&amp;game)?;
            state.games.insert(game_id.to_string(), game);
            save_chess_state(&amp;state);
            http::send_response(
                http::StatusCode::OK,
                Some(HashMap::from([(
                    String::from(&quot;Content-Type&quot;),
                    String::from(&quot;application/json&quot;),
                )])),
                body,
            )
        }
        // on PUT: make a move
        &quot;PUT&quot; =&gt; {
            let Some(blob) = get_blob() else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            let blob_json = serde_json::from_slice::&lt;serde_json::Value&gt;(&amp;blob.bytes)?;
            let Some(game_id) = blob_json[&quot;id&quot;].as_str() else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            let Some(game) = state.games.get_mut(game_id) else {
                return http::send_response(http::StatusCode::NOT_FOUND, None, vec![]);
            };
            if (game.turns % 2 == 0 &amp;&amp; game.white != our.node)
                || (game.turns % 2 == 1 &amp;&amp; game.black != our.node)
            {
                return http::send_response(http::StatusCode::FORBIDDEN, None, vec![]);
            } else if game.ended {
                return http::send_response(http::StatusCode::CONFLICT, None, vec![]);
            }
            let Some(move_str) = blob_json[&quot;move&quot;].as_str() else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            let mut board = Board::from_fen(&amp;game.board).unwrap();
            if !board.apply_uci_move(move_str) {
                // reader note: can surface illegal move to player or something here
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            }
            // send the move to the other player
            // check if the game is over
            // if so, update the records
            let Ok(msg) = Request::new()
                .target((game_id, our.process.clone()))
                .body(serde_json::to_vec(&amp;ChessRequest::Move {
                    game_id: game_id.to_string(),
                    move_str: move_str.to_string(),
                })?)
                .send_and_await_response(5)? else {
                    return Err(anyhow::anyhow!(&quot;other player did not respond properly to our move&quot;))
                };
            if serde_json::from_slice::&lt;ChessResponse&gt;(msg.body())? != ChessResponse::MoveAccepted {
                return Err(anyhow::anyhow!(&quot;other player rejected our move&quot;));
            }
            // update the game
            game.turns += 1;
            if board.checkmate() || board.stalemate() {
                game.ended = true;
            }
            game.board = board.fen();
            // update state and return to FE
            let body = serde_json::to_vec(&amp;game)?;
            save_chess_state(&amp;state);
            // return the game
            http::send_response(
                http::StatusCode::OK,
                Some(HashMap::from([(
                    String::from(&quot;Content-Type&quot;),
                    String::from(&quot;application/json&quot;),
                )])),
                body,
            )
        }
        // on DELETE: end the game
        &quot;DELETE&quot; =&gt; {
            let Some(game_id) = http_request.query_params.get(&quot;id&quot;) else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            let Some(game) = state.games.get_mut(game_id) else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            // send the other player an end game request
            Request::new()
                .target((game_id.as_str(), our.process.clone()))
                .body(serde_json::to_vec(&amp;ChessRequest::Resign(our.node.clone()))?)
                .send()?;
            game.ended = true;
            let body = serde_json::to_vec(&amp;game)?;
            save_chess_state(&amp;state);
            http::send_response(
                http::StatusCode::OK,
                Some(HashMap::from([(
                    String::from(&quot;Content-Type&quot;),
                    String::from(&quot;application/json&quot;),
                )])),
                body,
            )
        }
        // Any other method will be rejected.
        _ =&gt; http::send_response(http::StatusCode::METHOD_NOT_ALLOWED, None, vec![]),
    }
}
...
<span class="boring">}</span></code></pre></pre>
<p>This is a lot of code.
Mostly, it just handles the different HTTP methods and returns the appropriate responses.
The only unfamiliar code here is the <code>get_blob()</code> function, which is used here to inspect the HTTP body.
See the HTTP API docs (<a href="../apis/http_client.html">client</a>, <a href="../apis/http_server.html">server</a>) for more details.</p>
<p>Are you ready to play chess?
Almost there!
One more missing piece: the backend needs to send WebSocket updates to the frontend after each move in order to update the board without a refresh.
Since open channels are already tracked in process state, you just need to send a push to each open channel when a move occurs.</p>
<p>In <code>my_chess/src/lib.rs</code>, add a helper function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use kinode_process_lib::LazyLoadBlob;
...
fn send_ws_update(
    our: &amp;Address,
    game: &amp;Game,
    open_channels: &amp;HashSet&lt;u32&gt;,
) -&gt; anyhow::Result&lt;()&gt; {
    for channel in open_channels {
        Request::new()
            .target((&amp;our.node, &quot;http_server&quot;, &quot;sys&quot;, &quot;kinode&quot;))
            .body(serde_json::to_vec(
                &amp;http::HttpServerAction::WebSocketPush {
                    channel_id: *channel,
                    message_type: http::WsMessageType::Binary,
                },
            )?)
            .blob(LazyLoadBlob {
                mime: Some(&quot;application/json&quot;.to_string()),
                bytes: serde_json::json!({
                    &quot;kind&quot;: &quot;game_update&quot;,
                    &quot;data&quot;: game,
                }).to_string().into_bytes(),
            })
            .send()?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Now, anywhere you receive an action from another node (in <code>handle_chess_request()</code>, for example), call <code>send_ws_update(&amp;our, &amp;game, &amp;state.clients)?</code> to send an update to all connected clients.
You'll need to add <code>our</code> as a parameter to the handler function.
A good place to do this is right before saving the updated state.
Local moves from the frontend will update on their own.</p>
<p>Finally, add requests for <code>http_server</code> and <code>vfs</code> messaging capabilities to the <code>manifest.json</code>:</p>
<pre><code class="language-json">...
&quot;request_capabilities&quot;: [
    &quot;http_server:distro:sys&quot;,
    &quot;vfs:distro:sys&quot;
],
...
</code></pre>
<p>Continue to <a href="./putting_everything_together.html">Putting Everything Together</a> to see the full code and screenshots of the app in action.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chess_app/chess_engine.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chess_app/putting_everything_together.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chess_app/chess_engine.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chess_app/putting_everything_together.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/customize-buttons.js"></script>


    </div>
    </body>
</html>
