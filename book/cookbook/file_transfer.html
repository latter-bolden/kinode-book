<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Simple File Transfer Guide - Kinode Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/fonts/custom-fonts.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../identity_system.html">Identity System</a></li><li class="chapter-item expanded affix "><a href="../design_philosophy.html">Design Philosophy</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="../install.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../login.html"><strong aria-hidden="true">2.</strong> Join the Network</a></li><li class="chapter-item expanded affix "><li class="part-title">System Components</li><li class="chapter-item expanded "><a href="../processes.html"><strong aria-hidden="true">3.</strong> Processes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process-capabilities.html"><strong aria-hidden="true">3.1.</strong> Capability-Based Security</a></li><li class="chapter-item expanded "><a href="../process-startup.html"><strong aria-hidden="true">3.2.</strong> Startup, Spindown, and Crashes</a></li></ol></li><li class="chapter-item expanded "><a href="../networking_protocol.html"><strong aria-hidden="true">4.</strong> Networking Protocol</a></li><li class="chapter-item expanded "><a href="../pki.html"><strong aria-hidden="true">5.</strong> Public Key Infrastructure</a></li><li class="chapter-item expanded "><a href="../http_server_and_client.html"><strong aria-hidden="true">6.</strong> HTTP Server & Client</a></li><li class="chapter-item expanded "><a href="../files.html"><strong aria-hidden="true">7.</strong> Files</a></li><li class="chapter-item expanded "><a href="../databases.html"><strong aria-hidden="true">8.</strong> Databases</a></li><li class="chapter-item expanded affix "><li class="part-title">Process Standard Library</li><li class="chapter-item expanded "><a href="../process_stdlib/overview.html"><strong aria-hidden="true">9.</strong> Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Kit: Development Toolkit</li><li class="chapter-item expanded "><a href="../kit/kit.html"><strong aria-hidden="true">10.</strong> kit</a></li><li class="chapter-item expanded "><a href="../kit/boot-fake-node.html"><strong aria-hidden="true">11.</strong> boot-fake-node</a></li><li class="chapter-item expanded "><a href="../kit/new.html"><strong aria-hidden="true">12.</strong> new</a></li><li class="chapter-item expanded "><a href="../kit/build.html"><strong aria-hidden="true">13.</strong> build</a></li><li class="chapter-item expanded "><a href="../kit/start-package.html"><strong aria-hidden="true">14.</strong> start-package</a></li><li class="chapter-item expanded "><a href="../kit/remove-package.html"><strong aria-hidden="true">15.</strong> remove-package</a></li><li class="chapter-item expanded "><a href="../kit/dev-ui.html"><strong aria-hidden="true">16.</strong> dev-ui</a></li><li class="chapter-item expanded "><a href="../kit/inject-message.html"><strong aria-hidden="true">17.</strong> inject-message</a></li><li class="chapter-item expanded "><a href="../kit/run-tests.html"><strong aria-hidden="true">18.</strong> run-tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial: Build and Deploy an App</li><li class="chapter-item expanded "><a href="../my_first_app/chapter_1.html"><strong aria-hidden="true">19.</strong> Environment Setup</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_2.html"><strong aria-hidden="true">20.</strong> Sending Some Messages, Using Some Tools</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_3.html"><strong aria-hidden="true">21.</strong> Defining Your Protocol</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_4.html"><strong aria-hidden="true">22.</strong> Frontend Time</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_5.html"><strong aria-hidden="true">23.</strong> Sharing with the World</a></li><li class="chapter-item expanded affix "><li class="part-title">In-Depth Guide: Chess App</li><li class="chapter-item expanded "><a href="../chess_app/chess_engine.html"><strong aria-hidden="true">24.</strong> Chess Engine</a></li><li class="chapter-item expanded "><a href="../chess_app/frontend.html"><strong aria-hidden="true">25.</strong> Adding a Frontend</a></li><li class="chapter-item expanded "><a href="../chess_app/putting_everything_together.html"><strong aria-hidden="true">26.</strong> Putting Everything Together</a></li><li class="chapter-item expanded "><a href="../chess_app/chat.html"><strong aria-hidden="true">27.</strong> Extension 1: Chat</a></li><li class="chapter-item expanded affix "><li class="part-title">Cookbook (Handy Recipes)</li><li class="chapter-item expanded "><a href="../cookbook/cookbook_overview.html"><strong aria-hidden="true">28.</strong> Cookbook Overview</a></li><li class="chapter-item expanded "><a href="../cookbook/manage_child_processes.html"><strong aria-hidden="true">29.</strong> Managing Child Processes</a></li><li class="chapter-item expanded "><a href="../cookbook/publish_to_web.html"><strong aria-hidden="true">30.</strong> Publishing a Website or Web App</a></li><li class="chapter-item expanded "><a href="../cookbook/file_transfer.html" class="active"><strong aria-hidden="true">31.</strong> Simple File Transfer Guide</a></li><li class="chapter-item expanded affix "><li class="part-title">API Reference</li><li class="chapter-item expanded "><a href="../apis/overview.html"><strong aria-hidden="true">32.</strong> APIs Overview</a></li><li class="chapter-item expanded "><a href="../apis/http_authentication.html"><strong aria-hidden="true">33.</strong> HTTP API</a></li><li class="chapter-item expanded "><a href="../apis/http_client.html"><strong aria-hidden="true">34.</strong> HTTP Client API</a></li><li class="chapter-item expanded "><a href="../apis/http_server.html"><strong aria-hidden="true">35.</strong> HTTP Server API</a></li><li class="chapter-item expanded "><a href="../apis/kernel.html"><strong aria-hidden="true">36.</strong> Kernel API</a></li><li class="chapter-item expanded "><a href="../apis/kv.html"><strong aria-hidden="true">37.</strong> KV API</a></li><li class="chapter-item expanded "><a href="../apis/net.html"><strong aria-hidden="true">38.</strong> Net API</a></li><li class="chapter-item expanded "><a href="../apis/kinode_wit.html"><strong aria-hidden="true">39.</strong> kinode.wit</a></li><li class="chapter-item expanded "><a href="../apis/sqlite.html"><strong aria-hidden="true">40.</strong> SQLite API</a></li><li class="chapter-item expanded "><a href="../apis/terminal.html"><strong aria-hidden="true">41.</strong> Terminal API</a></li><li class="chapter-item expanded "><a href="../apis/vfs.html"><strong aria-hidden="true">42.</strong> VFS API</a></li><li class="chapter-item expanded "><a href="../apis/websocket_authentication.html"><strong aria-hidden="true">43.</strong> Websocket API</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kinode Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="file-transfer"><a class="header" href="#file-transfer">File Transfer</a></h1>
<p>This entry will teach you to build a simple file transfer app, allowing nodes to download files from a public directory.
It will use the <a href="../apis/vfs.html">vfs</a> to read and write files, and will spin up worker processes for the transfer.</p>
<p>This guide assumes a basic understanding of Kinode process building, some familiarity with <a href="../kit/kit.html"><code>kit</code></a>, requests and responses, and some knowledge of rust syntax.</p>
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<ul>
<li><a href="#start">Start</a></li>
<li><a href="#transfer">Transfer</a></li>
<li><a href="#final-code">Final Code</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="../apis/vfs.html">VFS API</a></li>
<li><a href="https://github.com/bitful-pannul/file_transfer">Github Repo</a></li>
</ul>
<h2 id="start"><a class="header" href="#start">Start</a></h2>
<p>First, initialize a new project with</p>
<pre><code>kit new file_transfer
</code></pre>
<p>Here's a clean template so you have a complete fresh start:</p>
<p>This guide will use the following <code>kinode_process_lib</code> version in <code>Cargo.toml</code> for this app:</p>
<pre><code>kinode_process_lib = { git = &quot;ssh://git@github.com/uqbar-dao/process_lib.git&quot;, rev = &quot;64d2856&quot; }
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use std::str::FromStr;

use kinode_process_lib::{await_message, println, Address, Message, ProcessId, Request, Response};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

fn handle_message(our: &amp;Address) -&gt; anyhow::Result&lt;()&gt; {
    let message = await_message()?;
    println!(&quot;file_transfer: got message!: {:?}&quot;, message);
    Ok(())
}

struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer: begin&quot;);

        let our = Address::from_str(&amp;our).unwrap();

        loop {
            match handle_message(&amp;our) {
                Ok(()) =&gt; {}
                Err(e) =&gt; {
                    println!(&quot;file_transfer: error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Before delving into the code, you can handle the capabilities you need to request at spawn, these will be messaging capabilities to <code>&quot;net:distro:sys&quot;</code> (as you'll want to talk to other nodes), and one to <code>&quot;vfs:distro:sys&quot;</code> as you'll want to talk to the filesystem.</p>
<p><code>pkg/manifest.json</code></p>
<pre><code class="language-json">[
    {
        &quot;process_name&quot;: &quot;file_transfer&quot;,
        &quot;process_wasm_path&quot;: &quot;/file_transfer.wasm&quot;,
        &quot;on_exit&quot;: &quot;Restart&quot;,
        &quot;request_networking&quot;: true,
        &quot;request_capabilities&quot;: [
            &quot;net:distro:sys&quot;,
            &quot;vfs:distro:sys&quot;
        ],
        &quot;grant_capabilities&quot;: [],
        &quot;public&quot;: true
    }
]
</code></pre>
<p>Now, start by creating a <a href="../apis/vfs.html#drives">drive</a> in your vfs and opening it, where files will be downloaded by other nodes.
You can add a whitelist a bit later!</p>
<p>Also, import some vfs functions from the <code>process_lib</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use kinode_process_lib::vfs::{create_drive, metadata, open_dir, Directory, FileType},

let drive_path = create_drive(our.package_id(), &quot;files&quot;).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>To start, this will be an app without UI, so to upload files into your public directory, simply copy them into the &quot;files&quot; folder located in <code>your_node/vfs/file_transfer:file_transfer:template.uq/files</code></p>
<p>You now need to let other nodes know what files they can download from you, so add some message types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub enum TransferRequest {
    ListFiles,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferResponse {
    ListFiles(Vec&lt;FileInfo&gt;),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct FileInfo {
    pub name: String,
    pub size: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>You can handle these messages cleanly by modifying the handle message function slightly.
It will match on whether a message is a request or a response, the errors get thrown to the main loop automatically with the <code>?</code> after the <code>await_message()</code> function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use kinode_process_lib::{
    await_message, println,
    vfs::{create_drive, metadata, open_dir, Directory, FileType},
    Address, Message, ProcessId, Request, Response,
};
use serde::{Deserialize, Serialize};
use std::str::FromStr;

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferRequest {
    ListFiles,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct FileInfo {
    pub name: String,
    pub size: u64,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferResponse {
    ListFiles(Vec&lt;FileInfo&gt;),
}

fn handle_message(our: &amp;Address, file_dir: &amp;Directory) -&gt; anyhow::Result&lt;()&gt; {
    let message = await_message()?;

    match message {
        Message::Response {
            ref source,
            ref body,
            ..
        } =&gt; {
            handle_transfer_response(our, source, body, file_dir)?;
        }
        Message::Request {
            ref source,
            ref body,
            ..
        } =&gt; {
            handle_transfer_request(&amp;our, source, body, file_dir)?;
        }
    };

    Ok(())
}

struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer: begin&quot;);

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = create_drive(our.package_id(), &quot;files&quot;).unwrap();
        let file_dir = open_dir(&amp;drive_path, false).unwrap();

        loop {
            match handle_message(&amp;our, &amp;file_dir) {
                Ok(()) =&gt; {}
                Err(e) =&gt; {
                    println!(&quot;file_transfer: error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can then add the <code>handle_transfer_request</code> and <code>handle_transfer_response</code> functions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_transfer_request(
    our: &amp;Address,
    source: &amp;Address,
    body: &amp;Vec&lt;u8&gt;,
    files_dir: &amp;Directory,
) -&gt; anyhow::Result&lt;()&gt; {
    let transfer_request = serde_json::from_slice::&lt;TransferRequest&gt;(body)?;

    match transfer_request {
        TransferRequest::ListFiles =&gt; {
            let entries = files_dir.read()?;
            let files: Vec&lt;FileInfo&gt; = entries
                .iter()
                .filter_map(|file| match file.file_type {
                    FileType::File =&gt; match metadata(&amp;file.path) {
                        Ok(metadata) =&gt; Some(FileInfo {
                            name: file.path.clone(),
                            size: metadata.len,
                        }),
                        Err(_) =&gt; None,
                    },
                    _ =&gt; None,
                })
                .collect();

            Response::new()
                .body(serde_json::to_vec(&amp;TransferResponse::ListFiles(files))?)
                .send()?;
        }
    }
}

fn handle_transfer_response(
    our: &amp;Address,
    source: &amp;Address,
    body: &amp;Vec&lt;u8&gt;,
    file_dir: &amp;Directory,
) -&gt; anyhow::Result&lt;()&gt; {
    let transfer_response = serde_json::from_slice::&lt;TransferResponse&gt;(body)?;

    match transfer_response {
        TransferResponse::ListFiles(files) =&gt; {
            println!(&quot;got files from node: {:?} ,files: {:?}&quot;, source, files);
        }
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Now try this out by booting two nodes (fake or real), placing files in the /files folder of one of them, and sending a request.</p>
<pre><code>/m node2.os@file_transfer:file_transfer:template.uq &quot;ListFiles&quot;
</code></pre>
<p>You should see a printed response.</p>
<pre><code class="language-md">Thu 1/11 13:14 response from node2.os@file_transfer:file_transfer:template.os: {&quot;ListFiles&quot;:[{&quot;name&quot;:&quot;file_transfer:template.os/files/barry-lyndon.mp4&quot;,&quot;size&quot;:8760244}, {&quot;name&quot;:&quot;file_transfer:template.os/files/blue-danube.mp3&quot;,&quot;size&quot;:9668359}]}
</code></pre>
<h3 id="transfer"><a class="header" href="#transfer">Transfer</a></h3>
<p>Now the fun part, downloading/sending files!</p>
<p>You could handle all of this within the <code>file_transfer</code> process, but you can also spin up another process, a worker, that handles the downloading/sending and then sends progress updates back to the main <code>file_transfer</code>.
This way you can download several files downloading at the same time without waiting for one to finish.</p>
<p>Start by defining some types.
You'll need a request that tells our main process to spin up a worker, requesting the node you're downloading from to do the same.
Also, a progress report would be nice!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub enum TransferRequest {
    ListFiles,
    Download { name: String, target: Address },
    Progress { name: String, progress: u64 },
}
<span class="boring">}</span></code></pre></pre>
<p>Now, a request to downoad a file will result in a respose to the requesting process to download the file using a worker.</p>
<p>Add a simple <code>Start</code> and <code>Done</code> variant, so you'll know when the worker has successfully been spawned and initialized.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub enum TransferResponse {
    ListFiles(Vec&lt;FileInfo&gt;),
    Download { name: String, worker: Address },
    Start,
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p>Now, add the intra worker communication types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub enum WorkerRequest {
    Initialize {
        name: String,
        target_worker: Option&lt;Address&gt;,
    },
    Chunk {
        name: String,
        offset: u64,
        length: u64,
    },
    Size(u64),
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Workers will take an <code>Inititialize</code> request from their own node, that either tells them they're a receiver or a sender based on if they have a target worker <code>Option&lt;Address&gt;</code>.</li>
<li>Progress reports are sent back to the main process, which you can then pipe them through as websocket updates to the frontend.</li>
<li>To enable spawning, import the <code>spawn</code> function from the <code>process_lib</code>.</li>
<li>The only additional part you need to handle in the transfer app is the Download request you've added.</li>
</ul>
<p><code>TransferRequest::Download</code> will handle 2 cases:</p>
<ol>
<li>A node sent us a download request, you spawn a worker, and tell it to send chunks to the <code>target_worker</code> you got in the request.</li>
<li>You want to download a file from another node, you send yourself a download request, you spin up a worker and send it's address to the remote node.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    match transfer_request {
        TransferRequest::ListFiles =&gt; {
            // like before
        }
        TransferRequest::Progress { name, progress } =&gt; {
            // for now, progress reports are just printed
            println!(&quot;file: {} progress: {}%&quot;, name, progress);
        }
        TransferRequest::Download { name, target } =&gt; {
            // spin up a worker, initialize based on whether it's a downloader or a sender.
            let our_worker = spawn(
                None,
                &amp;format!(&quot;{}/pkg/worker.wasm&quot;, our.package_id()),
                OnExit::None,
                our_capabilities(),
                vec![],
                false,
            )?;

            let our_worker_address = Address {
                node: our.node.clone(),
                process: our_worker,
            };

            match source.node == our.node {
                true =&gt; {
                    // we want to download a file
                    let _resp = Request::new()
                        .body(serde_json::to_vec(&amp;WorkerRequest::Initialize {
                            name: name.clone(),
                            target_worker: None,
                        })?)
                        .target(&amp;our_worker_address)
                        .send_and_await_response(5)??;

                    // send our initialized worker address to the other node
                    Request::new()
                        .body(serde_json::to_vec(&amp;TransferRequest::Download {
                            name: name.clone(),
                            target: our_worker_address,
                        })?)
                        .target(&amp;target)
                        .send()?;
                }
                false =&gt; {
                    // they want to download a file
                    Request::new()
                        .body(serde_json::to_vec(&amp;WorkerRequest::Initialize {
                            name: name.clone(),
                            target_worker: Some(target),
                        })?)
                        .target(&amp;our_worker_address)
                        .send()?;
                }
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>There you go.
As you can see, the main transfer doesn't actually do much — it only handles a handshake.
This makes adding more features later on very simple.</p>
<p>Now, the actual worker.
Add this bit by bit:</p>
<p>First, because when you spawn your worker you give it <code>our_capabilities()</code> (i.e. it has the same capabilities as the parent process), the worker will have the ability to message both <code>&quot;net:distro:sys&quot;</code> and <code>&quot;vfs:distro:sys&quot;</code>.
As it's also within the same package, you can simply open the <code>files_dir</code> without issue.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer worker: begin&quot;);

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = format!(&quot;{}/files&quot;, our.package_id());
        let files_dir = open_dir(&amp;drive_path, false).unwrap();

        loop {
            match handle_message(&amp;our, &amp;files_dir) {
                Ok(()) =&gt; {}
                Err(e) =&gt; {
                    println!(&quot;file_transfer: error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You'll also need a bit of state for the receiving worker.
This is not persisted (you'll add that soon!), but when different chunks arrive, you need to know what file to write to and how long that file should eventually become to generate progress updates.
This is not known at the point of spawning (<code>init</code> takes just an <code>our: String</code>), but you've created a <code>WorkerRequest::Initialize</code> precisely for this reason.</p>
<p>The state you'll initialize at the start of the worker will look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut file: Option&lt;File&gt; = None;
let mut size: Option&lt;u64&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>And then in the main loop we pass it to <code>handle_message</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer worker: begin&quot;);

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = format!(&quot;{}/files&quot;, our.package_id());
        let files_dir = open_dir(&amp;drive_path, false).unwrap();

        let mut file: Option&lt;File&gt; = None;
        let mut size: Option&lt;u64&gt; = None;
        loop {
            match handle_message(&amp;our, &amp;mut file, &amp;files_dir, &amp;mut size) {
                Ok(()) =&gt; {}
                Err(e) =&gt; {
                    println!(&quot;file_transfer: error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>handle_message</code> function will handle three <code>WorkerRequest</code> variants: the requests <code>Initialize</code>, <code>Chunk</code> and <code>Size</code>.</p>
<p><code>WorkerRequest::Initialize</code> runs once, received from the spawner:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn handle_message(
    our: &amp;Address,
    file: &amp;mut Option&lt;File&gt;,
    files_dir: &amp;Directory,
    size: &amp;mut Option&lt;u64&gt;,
) -&gt; anyhow::Result&lt;()&gt; {
    let message = await_message()?;

    match message {
        Message::Request {
            ref source,
            ref body,
            ..
        } =&gt; {
            let request = serde_json::from_slice::&lt;WorkerRequest&gt;(body)?;

            match request {
                WorkerRequest::Initialize {
                    name,
                    target_worker,
                } =&gt; {
                    // initialize command from main process,
                    // sets up worker, matches on if it's a sender or receiver.
                    // target_worker = None, we are receiver, else sender.

                    // open/create empty file in both cases.
                    let mut active_file =
                        open_file(&amp;format!(&quot;{}/{}&quot;, files_dir.path, &amp;name), true)?;

                    match target_worker {
                        Some(target_worker) =&gt; {
                            // we have a target, chunk the data, and send it.
                            let size = active_file.metadata()?.len;
                            let num_chunks = (size as f64 / CHUNK_SIZE as f64).ceil() as u64;

                            // give the receiving worker a size request so it can track it's progress!
                            Request::new()
                                .body(serde_json::to_vec(&amp;WorkerRequest::Size(size))?)
                                .target(target_worker.clone())
                                .send()?;

                            active_file.seek(SeekFrom::Start(0))?;

                            for i in 0..num_chunks {
                                let offset = i * CHUNK_SIZE;
                                let length = CHUNK_SIZE.min(size - offset);

                                let mut buffer = vec![0; length as usize];
                                active_file.read_at(&amp;mut buffer)?;

                                Request::new()
                                    .body(serde_json::to_vec(&amp;WorkerRequest::Chunk {
                                        name: name.clone(),
                                        offset,
                                        length,
                                    })?)
                                    .target(target_worker.clone())
                                    .blob_bytes(buffer)
                                    .send()?;
                            }
                            Response::new().body(serde_json::to_vec(&amp;&quot;Done&quot;)?).send()?;
                            return Ok(());
                        }
                        None =&gt; {
                            // waiting for response, store created empty file.
                            *file = Some(active_file);
                            Response::new()
                                .body(serde_json::to_vec(&amp;&quot;Started&quot;)?)
                                .send()?;
                        }
                    }
                }
               _ =&gt; {
                println!(&quot;Chunk and Size next!&quot;)
               }
            }
        }
        _ =&gt; {
            println!(&quot;file_transfer worker: got something else than request...&quot;);
        }
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>So upon <code>Initialize</code>, you open the existing file or create an empty one. Then, depending on whether the worker is a sender or receiver, you take one of two options:</p>
<ul>
<li>if receiver, save the <code>File</code> to your state, and then send a Started response to parent.</li>
<li>if sender, get the file's length, send it as <code>Size</code> to the <code>target_worker</code>, and then chunk the data, loop, read into a buffer and send to <code>target_worker</code>.</li>
</ul>
<p><code>WorkerRequest::Chunk</code> will look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// someone sending a chunk to us!
WorkerRequest::Chunk {
    name,
    offset,
    length,
} =&gt; {
    let file = match file {
        Some(file) =&gt; file,
        None =&gt; {
            return Err(anyhow::anyhow!(
                &quot;file_transfer: receive error: no file initialized&quot;
            ));
        }
    };

    let bytes = match get_blob() {
        Some(blob) =&gt; blob.bytes,
        None =&gt; {
            return Err(anyhow::anyhow!(&quot;file_transfer: receive error: no blob&quot;));
        }
    };

    file.write_all(&amp;bytes)?;

    // if sender has sent us a size, give a progress update to main transfer!
    if let Some(size) = size {
        let progress = ((offset + length) as f64 / *size as f64 * 100.0) as u64;

        // send update to main process
        let main_app = Address {
            node: our.node.clone(),
            process: ProcessId::from_str(
                &quot;file_transfer:file_transfer:template.os&quot;,
            )?,
        };

        Request::new()
            .body(serde_json::to_vec(&amp;TransferRequest::Progress {
                name,
                progress,
            })?)
            .target(&amp;main_app)
            .send()?;

        if progress &gt;= 100 {
            Response::new().body(serde_json::to_vec(&amp;&quot;Done&quot;)?).send()?;
            return Ok(());
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And <code>WorkerRequest::Size</code> is easy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WorkerRequest::Size(incoming_size) =&gt; {
    *size = Some(incoming_size);
}
<span class="boring">}</span></code></pre></pre>
<p>One more thing: once you're done sending, you can exit the process; the worker is not needed anymore.
Change your <code>handle_message</code> function to return a <code>Result&lt;bool&gt;</code> instead telling the main loop whether it should exit or not.</p>
<p>As a bonus, we can add a print when it exits of how long it took to send/receive!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_message(
    our: &amp;Address,
    file: &amp;mut Option&lt;File&gt;,
    files_dir: &amp;Directory,
    size: &amp;mut Option&lt;u64&gt;,
) -&gt; anyhow::Result&lt;bool&gt; {
<span class="boring">}</span></code></pre></pre>
<p>Changing the main loop and the places we return <code>Ok(())</code> appropriately.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer worker: begin&quot;);
        let start = std::time::Instant::now();

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = format!(&quot;{}/files&quot;, our.package_id());
        let files_dir = open_dir(&amp;drive_path, false).unwrap();

        let mut file: Option&lt;File&gt; = None;
        let mut size: Option&lt;u64&gt; = None;

        loop {
            match handle_message(&amp;our, &amp;mut file, &amp;files_dir, &amp;mut size) {
                Ok(exit) =&gt; {
                    if exit {
                        println!(
                            &quot;file_transfer worker done: exiting, took {:?}&quot;,
                            start.elapsed()
                        );
                        break;
                    }
                }
                Err(e) =&gt; {
                    println!(&quot;file_transfer: worker error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="final-code"><a class="header" href="#final-code">Final Code</a></h3>
<p>And Voilà! The worker and then the main process in entirety:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use std::str::FromStr;

use kinode_process_lib::{
    await_message, get_blob, println,
    vfs::{open_dir, open_file, Directory, File, SeekFrom},
    Address, Message, ProcessId, Request, Response,
};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

const CHUNK_SIZE: u64 = 1048576; // 1MB

#[derive(Serialize, Deserialize, Debug)]
pub enum WorkerRequest {
    Initialize {
        name: String,
        target_worker: Option&lt;Address&gt;,
    },
    Chunk {
        name: String,
        offset: u64,
        length: u64,
    },
    Size(u64),
}

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferRequest {
    Progress { name: String, progress: u64 },
}

fn handle_message(
    our: &amp;Address,
    file: &amp;mut Option&lt;File&gt;,
    files_dir: &amp;Directory,
    size: &amp;mut Option&lt;u64&gt;,
) -&gt; anyhow::Result&lt;bool&gt; {
    let message = await_message()?;

    match message {
        Message::Request {
            ref source,
            ref body,
            ..
        } =&gt; {
            let request = serde_json::from_slice::&lt;WorkerRequest&gt;(body)?;

            match request {
                WorkerRequest::Initialize {
                    name,
                    target_worker,
                } =&gt; {
                    // initialize command from main process,
                    // sets up worker, matches on if it's a sender or receiver.
                    // target_worker = None, we are receiver, else sender.

                    // open/create empty file in both cases.
                    let mut active_file =
                        open_file(&amp;format!(&quot;{}/{}&quot;, files_dir.path, &amp;name), true)?;

                    match target_worker {
                        Some(target_worker) =&gt; {
                            // we have a target, chunk the data, and send it.
                            let size = active_file.metadata()?.len;
                            let num_chunks = (size as f64 / CHUNK_SIZE as f64).ceil() as u64;

                            // give the receiving worker a size request so it can track it's progress!
                            Request::new()
                                .body(serde_json::to_vec(&amp;WorkerRequest::Size(size))?)
                                .target(target_worker.clone())
                                .send()?;

                            active_file.seek(SeekFrom::Start(0))?;

                            for i in 0..num_chunks {
                                let offset = i * CHUNK_SIZE;
                                let length = CHUNK_SIZE.min(size - offset);

                                let mut buffer = vec![0; length as usize];
                                active_file.read_at(&amp;mut buffer)?;

                                Request::new()
                                    .body(serde_json::to_vec(&amp;WorkerRequest::Chunk {
                                        name: name.clone(),
                                        offset,
                                        length,
                                    })?)
                                    .target(target_worker.clone())
                                    .blob_bytes(buffer)
                                    .send()?;
                            }
                            Response::new().body(serde_json::to_vec(&amp;&quot;Done&quot;)?).send()?;
                            return Ok(true);
                        }
                        None =&gt; {
                            // waiting for response, store created empty file.
                            *file = Some(active_file);
                            Response::new()
                                .body(serde_json::to_vec(&amp;&quot;Started&quot;)?)
                                .send()?;
                        }
                    }
                }
                // someone sending a chunk to us!
                WorkerRequest::Chunk {
                    name,
                    offset,
                    length,
                } =&gt; {
                    let file = match file {
                        Some(file) =&gt; file,
                        None =&gt; {
                            return Err(anyhow::anyhow!(
                                &quot;file_transfer: receive error: no file initialized&quot;
                            ));
                        }
                    };

                    let bytes = match get_blob() {
                        Some(blob) =&gt; blob.bytes,
                        None =&gt; {
                            return Err(anyhow::anyhow!(&quot;file_transfer: receive error: no blob&quot;));
                        }
                    };

                    file.write_all(&amp;bytes)?;
                    // if sender has sent us a size, give a progress update to main transfer!
                    if let Some(size) = size {
                        let progress = ((offset + length) as f64 / *size as f64 * 100.0) as u64;

                        // send update to main process
                        let main_app = Address {
                            node: our.node.clone(),
                            process: ProcessId::from_str(
                                &quot;file_transfer:file_transfer:template.os&quot;,
                            )?,
                        };

                        Request::new()
                            .body(serde_json::to_vec(&amp;TransferRequest::Progress {
                                name,
                                progress,
                            })?)
                            .target(&amp;main_app)
                            .send()?;

                        if progress &gt;= 100 {
                            Response::new().body(serde_json::to_vec(&amp;&quot;Done&quot;)?).send()?;
                            return Ok(true);
                        }
                    }
                }
                WorkerRequest::Size(incoming_size) =&gt; {
                    *size = Some(incoming_size);
                }
            }
        }
        _ =&gt; {
            println!(&quot;file_transfer worker: got something else than request...&quot;);
        }
    }
    Ok(false)
}

struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer worker: begin&quot;);
        let start = std::time::Instant::now();

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = format!(&quot;{}/files&quot;, our.package_id());
        let files_dir = open_dir(&amp;drive_path, false).unwrap();

        let mut file: Option&lt;File&gt; = None;
        let mut size: Option&lt;u64&gt; = None;

        loop {
            match handle_message(&amp;our, &amp;mut file, &amp;files_dir, &amp;mut size) {
                Ok(exit) =&gt; {
                    if exit {
                        println!(
                            &quot;file_transfer worker done: exiting, took {:?}&quot;,
                            start.elapsed()
                        );
                        break;
                    }
                }
                Err(e) =&gt; {
                    println!(&quot;file_transfer: worker error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And the main process:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use kinode_process_lib::{
    await_message, our_capabilities, println, spawn,
    vfs::{create_drive, metadata, open_dir, Directory, FileType},
    Address, Message, OnExit, Request, Response,
};
use serde::{Deserialize, Serialize};
use std::str::FromStr;

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferRequest {
    ListFiles,
    Download { name: String, target: Address },
    Progress { name: String, progress: u64 },
}

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferResponse {
    ListFiles(Vec&lt;FileInfo&gt;),
    Download { name: String, worker: Address },
    Done,
    Started,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct FileInfo {
    pub name: String,
    pub size: u64,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum WorkerRequest {
    Initialize {
        name: String,
        target_worker: Option&lt;Address&gt;,
    },
}

fn handle_transfer_request(
    our: &amp;Address,
    source: &amp;Address,
    body: &amp;Vec&lt;u8&gt;,
    files_dir: &amp;Directory,
) -&gt; anyhow::Result&lt;()&gt; {
    let transfer_request = serde_json::from_slice::&lt;TransferRequest&gt;(body)?;

    match transfer_request {
        TransferRequest::ListFiles =&gt; {
            let entries = files_dir.read()?;
            let files: Vec&lt;FileInfo&gt; = entries
                .iter()
                .filter_map(|file| match file.file_type {
                    FileType::File =&gt; match metadata(&amp;file.path) {
                        Ok(metadata) =&gt; Some(FileInfo {
                            name: file.path.clone(),
                            size: metadata.len,
                        }),
                        Err(_) =&gt; None,
                    },
                    _ =&gt; None,
                })
                .collect();

            Response::new()
                .body(serde_json::to_vec(&amp;TransferResponse::ListFiles(files))?)
                .send()?;
        }
        TransferRequest::Download { name, target } =&gt; {
            // spin up a worker, initialize based on whether it's a downloader or a sender.
            let our_worker = spawn(
                None,
                &amp;format!(&quot;{}/pkg/worker.wasm&quot;, our.package_id()),
                OnExit::None,
                our_capabilities(),
                vec![],
                false,
            )?;

            let our_worker_address = Address {
                node: our.node.clone(),
                process: our_worker,
            };

            match source.node == our.node {
                true =&gt; {
                    // we want to download a file
                    let _resp = Request::new()
                        .body(serde_json::to_vec(&amp;WorkerRequest::Initialize {
                            name: name.clone(),
                            target_worker: None,
                        })?)
                        .target(&amp;our_worker_address)
                        .send_and_await_response(5)??;

                    // send our initialized worker address to the other node
                    Request::new()
                        .body(serde_json::to_vec(&amp;TransferRequest::Download {
                            name: name.clone(),
                            target: our_worker_address,
                        })?)
                        .target(&amp;target)
                        .send()?;
                }
                false =&gt; {
                    // they want to download a file
                    Request::new()
                        .body(serde_json::to_vec(&amp;WorkerRequest::Initialize {
                            name: name.clone(),
                            target_worker: Some(target),
                        })?)
                        .target(&amp;our_worker_address)
                        .send()?;
                }
            }
        }
        TransferRequest::Progress { name, progress } =&gt; {
            println!(&quot;file: {} progress: {}%&quot;, name, progress);
        }
    }

    Ok(())
}

fn handle_transfer_response(source: &amp;Address, body: &amp;Vec&lt;u8&gt;) -&gt; anyhow::Result&lt;()&gt; {
    let transfer_response = serde_json::from_slice::&lt;TransferResponse&gt;(body)?;

    match transfer_response {
        TransferResponse::ListFiles(files) =&gt; {
            println!(&quot;got files from node: {:?} ,files: {:?}&quot;, source, files);
        }
        _ =&gt; {}
    }

    Ok(())
}

fn handle_message(our: &amp;Address, files_dir: &amp;Directory) -&gt; anyhow::Result&lt;()&gt; {
    let message = await_message()?;

    match message {
        Message::Response {
            ref source,
            ref body,
            ..
        } =&gt; {
            handle_transfer_response(source, body)?;
        }
        Message::Request {
            ref source,
            ref body,
            ..
        } =&gt; {
            handle_transfer_request(&amp;our, source, body, files_dir)?;
        }
    };

    Ok(())
}

struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer: begin&quot;);

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = create_drive(our.package_id(), &quot;files&quot;).unwrap();
        let files_dir = open_dir(&amp;drive_path, false).unwrap();

        loop {
            match handle_message(&amp;our, &amp;files_dir) {
                Ok(()) =&gt; {}
                Err(e) =&gt; {
                    println!(&quot;file_transfer: error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>There you have it!</p>
<p>Try and run it, you can download a file with the command</p>
<pre><code>/m our@file_transfer:file_transfer:template.os {&quot;Download&quot;: {&quot;name&quot;: &quot;dawg.jpeg&quot;, &quot;target&quot;: &quot;buenosaires.os@file_transfer:file_transfer:template.os&quot;}}
</code></pre>
<p>replacing node name and file name!</p>
<p>Stay tuned for additions to this guide, including restarting transfers after rebooting your node or losing connections, and a simple UI!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../cookbook/publish_to_web.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../apis/overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../cookbook/publish_to_web.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../apis/overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/customize-buttons.js"></script>


    </div>
    </body>
</html>
