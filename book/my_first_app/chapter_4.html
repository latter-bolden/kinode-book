<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Frontend Time - Kinode Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/fonts/custom-fonts.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../identity_system.html">Identity System</a></li><li class="chapter-item expanded affix "><a href="../design_philosophy.html">Design Philosophy</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="../install.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../login.html"><strong aria-hidden="true">2.</strong> Join the Network</a></li><li class="chapter-item expanded affix "><li class="part-title">System Components</li><li class="chapter-item expanded "><a href="../processes.html"><strong aria-hidden="true">3.</strong> Processes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process-capabilities.html"><strong aria-hidden="true">3.1.</strong> Capability-Based Security</a></li><li class="chapter-item expanded "><a href="../process-startup.html"><strong aria-hidden="true">3.2.</strong> Startup, Spindown, and Crashes</a></li></ol></li><li class="chapter-item expanded "><a href="../networking_protocol.html"><strong aria-hidden="true">4.</strong> Networking Protocol</a></li><li class="chapter-item expanded "><a href="../pki.html"><strong aria-hidden="true">5.</strong> Public Key Infrastructure</a></li><li class="chapter-item expanded "><a href="../http_server_and_client.html"><strong aria-hidden="true">6.</strong> HTTP Server & Client</a></li><li class="chapter-item expanded "><a href="../files.html"><strong aria-hidden="true">7.</strong> Files</a></li><li class="chapter-item expanded "><a href="../databases.html"><strong aria-hidden="true">8.</strong> Databases</a></li><li class="chapter-item expanded affix "><li class="part-title">Process Standard Library</li><li class="chapter-item expanded "><a href="../process_stdlib/overview.html"><strong aria-hidden="true">9.</strong> Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Kit: Development Toolkit</li><li class="chapter-item expanded "><a href="../kit/kit.html"><strong aria-hidden="true">10.</strong> kit</a></li><li class="chapter-item expanded "><a href="../kit/boot-fake-node.html"><strong aria-hidden="true">11.</strong> boot-fake-node</a></li><li class="chapter-item expanded "><a href="../kit/new.html"><strong aria-hidden="true">12.</strong> new</a></li><li class="chapter-item expanded "><a href="../kit/build.html"><strong aria-hidden="true">13.</strong> build</a></li><li class="chapter-item expanded "><a href="../kit/start-package.html"><strong aria-hidden="true">14.</strong> start-package</a></li><li class="chapter-item expanded "><a href="../kit/remove-package.html"><strong aria-hidden="true">15.</strong> remove-package</a></li><li class="chapter-item expanded "><a href="../kit/dev-ui.html"><strong aria-hidden="true">16.</strong> dev-ui</a></li><li class="chapter-item expanded "><a href="../kit/inject-message.html"><strong aria-hidden="true">17.</strong> inject-message</a></li><li class="chapter-item expanded "><a href="../kit/run-tests.html"><strong aria-hidden="true">18.</strong> run-tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial: Build and Deploy an App</li><li class="chapter-item expanded "><a href="../my_first_app/chapter_1.html"><strong aria-hidden="true">19.</strong> Environment Setup</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_2.html"><strong aria-hidden="true">20.</strong> Sending Some Messages, Using Some Tools</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_3.html"><strong aria-hidden="true">21.</strong> Defining Your Protocol</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_4.html" class="active"><strong aria-hidden="true">22.</strong> Frontend Time</a></li><li class="chapter-item expanded "><a href="../my_first_app/chapter_5.html"><strong aria-hidden="true">23.</strong> Sharing with the World</a></li><li class="chapter-item expanded affix "><li class="part-title">In-Depth Guide: Chess App</li><li class="chapter-item expanded "><a href="../chess_app/chess_engine.html"><strong aria-hidden="true">24.</strong> Chess Engine</a></li><li class="chapter-item expanded "><a href="../chess_app/frontend.html"><strong aria-hidden="true">25.</strong> Adding a Frontend</a></li><li class="chapter-item expanded "><a href="../chess_app/putting_everything_together.html"><strong aria-hidden="true">26.</strong> Putting Everything Together</a></li><li class="chapter-item expanded "><a href="../chess_app/chat.html"><strong aria-hidden="true">27.</strong> Extension 1: Chat</a></li><li class="chapter-item expanded affix "><li class="part-title">Cookbook (Handy Recipes)</li><li class="chapter-item expanded "><a href="../cookbook/cookbook_overview.html"><strong aria-hidden="true">28.</strong> Cookbook Overview</a></li><li class="chapter-item expanded "><a href="../cookbook/manage_child_processes.html"><strong aria-hidden="true">29.</strong> Managing Child Processes</a></li><li class="chapter-item expanded "><a href="../cookbook/publish_to_web.html"><strong aria-hidden="true">30.</strong> Publishing a Website or Web App</a></li><li class="chapter-item expanded "><a href="../cookbook/file_transfer.html"><strong aria-hidden="true">31.</strong> Simple File Transfer Guide</a></li><li class="chapter-item expanded affix "><li class="part-title">API Reference</li><li class="chapter-item expanded "><a href="../apis/overview.html"><strong aria-hidden="true">32.</strong> APIs Overview</a></li><li class="chapter-item expanded "><a href="../apis/http_authentication.html"><strong aria-hidden="true">33.</strong> HTTP API</a></li><li class="chapter-item expanded "><a href="../apis/http_client.html"><strong aria-hidden="true">34.</strong> HTTP Client API</a></li><li class="chapter-item expanded "><a href="../apis/http_server.html"><strong aria-hidden="true">35.</strong> HTTP Server API</a></li><li class="chapter-item expanded "><a href="../apis/kernel.html"><strong aria-hidden="true">36.</strong> Kernel API</a></li><li class="chapter-item expanded "><a href="../apis/kv.html"><strong aria-hidden="true">37.</strong> KV API</a></li><li class="chapter-item expanded "><a href="../apis/net.html"><strong aria-hidden="true">38.</strong> Net API</a></li><li class="chapter-item expanded "><a href="../apis/kinode_wit.html"><strong aria-hidden="true">39.</strong> kinode.wit</a></li><li class="chapter-item expanded "><a href="../apis/sqlite.html"><strong aria-hidden="true">40.</strong> SQLite API</a></li><li class="chapter-item expanded "><a href="../apis/terminal.html"><strong aria-hidden="true">41.</strong> Terminal API</a></li><li class="chapter-item expanded "><a href="../apis/vfs.html"><strong aria-hidden="true">42.</strong> VFS API</a></li><li class="chapter-item expanded "><a href="../apis/websocket_authentication.html"><strong aria-hidden="true">43.</strong> Websocket API</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kinode Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="frontend-time"><a class="header" href="#frontend-time">Frontend Time</a></h1>
<p>After the last chapter, you should have a simple process that responds to two commands from the terminal.
In this chapter, you'll add some basic HTTP logic to serve a frontend and accept an HTTP PUT request that contains a command.</p>
<p>If you're the type of person that prefers to learn by looking at a complete example, check out the <a href="../chess_app/frontend.html">chess frontend chapter</a> for a fleshed-out example and a link to some frontend code.</p>
<h2 id="adding-http-request-handling"><a class="header" href="#adding-http-request-handling">Adding HTTP request handling</a></h2>
<p>Using the built-in HTTP server will require handling a new type of request in our main loop, and serving a response to it.
The <a href="../process_stdlib/overview.html">process_lib</a> contains types and functions for doing so.</p>
<p>At the top of your process, import <code>http</code>, <code>get_blob</code>, and <code>Message</code> from <a href="../process_stdlib/overview.html"><code>kinode_process_lib</code></a> along with the rest of the imports.
You'll use <code>get_blob()</code> to grab the body bytes of an incoming HTTP request.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use kinode_process_lib::{
    await_message, call_init, get_blob, http, println, Address, Message, Request, Response,
};
<span class="boring">}</span></code></pre></pre>
<p>Keep the custom <code>body</code> type the same, and keep using that for terminal input.</p>
<p>At the beginning of the init function, in order to receieve HTTP requests, you must use the <code>kinode_process_lib::http</code> library to bind a new path. Binding a path will cause the process to receive all HTTP requests that match that path.
You can also bind static content to a path using another function in the library.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
fn my_init_fn(our: Address) {
    println!(&quot;{our}: started&quot;);
    // the first argument is the path to bind. Note that requests will be namespaced
    // under the process name, so this will be accessible at /my_process/

    // the second argument marks whether to serve the path only to authenticated clients,
    // and the third argument marks whether to only serve the path locally.
    // in order to skip authentication, set the second argument to false here.
    http::bind_http_path(&quot;/&quot;, false, false).unwrap();
    // ...
}
// ...
<span class="boring">}</span></code></pre></pre>
<p>Now that you're handling multiple kinds of requests, let's refactor the loop to be more concise and move the request-specific logic to dedicated functions.
Put this right under the bind command:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    match await_message() {
        Ok(message) =&gt; {
            if message.source().process == &quot;http_server:distro:sys&quot; {
                handle_http_message(&amp;our, &amp;message);
            } else {
                if handle_hello_message(&amp;message) {
                    break;
                }
            }
        }
        Err(_send_error) =&gt; {
            println!(&quot;got send error!&quot;);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that different apps will want to discriminate between incoming messages differently.
This code doesn't check the <code>source.node</code> at all, for example.</p>
<p>The <code>handle_hello_message</code> will look just like what was in chapter 3.
However, since this logic is no longer inside the main loop, return a boolean to indicate whether or not to exit out of the loop.
Request handling can be separated out into as many functions is needed to keep the code clean.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Returns true if the process should exit.
fn handle_hello_message(message: &amp;Message) -&gt; bool {
    let Ok(body) = MyBody::parse(message.body()) else {
        println!(&quot;received a message with weird `body`!&quot;);
        return false;
    };
    if message.is_request() {
        // Respond to a Hello with a Hello, and a Goodbye by exiting
        // the loop, which will cause the process to exit.
        match body {
            MyBody::Hello(text) =&gt; {
                println!(&quot;got a Hello: {text}&quot;);
            }
            MyBody::Goodbye =&gt; {
                println!(&quot;goodbye!&quot;);
                return true;
            }
        }
    } else {
        // we only expect Hello responses. If we get a Goodbye, ignore it.
        match body {
            MyBody::Hello(text) =&gt; {
                println!(&quot;got a Hello response: {text}&quot;);
            }
            MyBody::Goodbye =&gt; {}
        }
    }
    return false;
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, let's define <code>handle_http_message</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_http_message(our: &amp;Address, message: &amp;Message) {

}
<span class="boring">}</span></code></pre></pre>
<p>Instead of parsing our <code>body</code> type from the message, parse the type that the <code>http_server</code> process gives us. This type is defined in the <code>kinode_process_lib::http</code> module for us:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
let Ok(server_request) = http::HttpServerRequest::from_bytes(message.body()) else {
    println!(&quot;received a message with weird `body`!&quot;);
    return;
};
// ...
<span class="boring">}</span></code></pre></pre>
<p>Next, you must parse out the HTTP request from the general type.
This is.osessary because the <code>HttpServerRequest</code> enum contains both HTTP protocol requests and requests related to WebSockets.
Note that it's quite possible to streamline this series of request refinements if you're only interested in one type of request — this example is overly thorough for demonstration purposes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
let Some(http_request) = server_request.request() else {
    println!(&quot;received a WebSocket message, skipping&quot;);
    return;
};
// ...
<span class="boring">}</span></code></pre></pre>
<p>Now, check the HTTP method in order to only handle PUT requests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
if http_request.method().unwrap() != http::Method::PUT {
    println!(&quot;received a non-PUT HTTP request, skipping&quot;);
    return;
}
// ...
<span class="boring">}</span></code></pre></pre>
<p>Finally, grab the <code>blob</code> from the request, send a 200 OK response to the client, and handle the <code>blob</code>, by sending a Request to ourselves with the <code>blob</code> as the <code>body</code>.
This could be done in a different way, but this simple pattern is useful for letting HTTP requests masquerade as in-Kinode requests.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
let Some(body) = get_blob() else {
    println!(&quot;received a PUT HTTP request with no body, skipping&quot;);
    return;
};
http::send_response(http::StatusCode::OK, None, vec![]).unwrap();
Request::to(our).body(body.bytes).send().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Putting it all together, you get a process which you can build and start, then use cURL to send Hello and Goodbye requests via HTTP PUTs!</p>
<p>Also, remember to request the capability to message <code>http_server</code> in <code>manifest.json</code>:</p>
<pre><code class="language-json">...
&quot;request_capabilities&quot;: [
    &quot;http_server:distro:sys&quot;
],
...
</code></pre>
<p>Here's the full code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use kinode_process_lib::{
    await_message, call_init, get_blob, http, println, Address, Message, Request,
};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

#[derive(Serialize, Deserialize)]
enum MyBody {
    Hello(String),
    Goodbye,
}

impl MyBody {
    fn hello(text: &amp;str) -&gt; Vec&lt;u8&gt; {
        serde_json::to_vec(&amp;MyBody::Hello(text.to_string())).unwrap()
    }

    fn goodbye() -&gt; Vec&lt;u8&gt; {
        serde_json::to_vec(&amp;MyBody::Goodbye).unwrap()
    }

    fn parse(bytes: &amp;[u8]) -&gt; Result&lt;MyBody, serde_json::Error&gt; {
        serde_json::from_slice::&lt;MyBody&gt;(bytes)
    }
}

call_init!(my_init_fn);

fn my_init_fn(our: Address) {
    println!(&quot;{our}: started&quot;);

    http::bind_http_path(&quot;/&quot;, false, false).unwrap();

    Request::new()
        .target(&amp;our)
        .body(MyBody::hello(&quot;hello world&quot;))
        .send()
        .unwrap();

    loop {
        match await_message() {
            Ok(message) =&gt; {
                if message.source().process == &quot;http_server:distro:sys&quot; {
                    handle_http_message(&amp;our, &amp;message);
                } else {
                    if handle_hello_message(&amp;message) {
                        break;
                    }
                }
            }
            Err(_send_error) =&gt; {
                println!(&quot;got send error!&quot;);
            }
        }
    }
}

/// Handle a message from the HTTP server.
fn handle_http_message(our: &amp;Address, message: &amp;Message) {
    let Ok(server_request) = http::HttpServerRequest::from_bytes(message.body()) else {
        println!(&quot;received a message with weird `body`!&quot;);
        return;
    };
    let Some(http_request) = server_request.request() else {
        println!(&quot;received a WebSocket message, skipping&quot;);
        return;
    };
    if http_request.method().unwrap() != http::Method::PUT {
        println!(&quot;received a non-PUT HTTP request, skipping&quot;);
        return;
    }
    let Some(body) = get_blob() else {
        println!(&quot;received a PUT HTTP request with no body, skipping&quot;);
        return;
    };
    http::send_response(http::StatusCode::OK, None, vec![]).unwrap();
    Request::to(our).body(body.bytes).send().unwrap();
}

/// Returns true if the process should exit.
fn handle_hello_message(message: &amp;Message) -&gt; bool {
    let Ok(body) = MyBody::parse(message.body()) else {
        println!(&quot;received a message with weird `body`!&quot;);
        return false;
    };
    if message.is_request() {
        // Respond to a Hello with a Hello, and a Goodbye by exiting
        // the loop, which will cause the process to exit.
        match body {
            MyBody::Hello(text) =&gt; {
                println!(&quot;got a Hello: {text}&quot;);
            }
            MyBody::Goodbye =&gt; {
                println!(&quot;goodbye!&quot;);
                return true;
            }
        }
    } else {
        // we only expect Hello responses. If we get a Goodbye, ignore it.
        match body {
            MyBody::Hello(text) =&gt; {
                println!(&quot;got a Hello response: {text}&quot;);
            }
            MyBody::Goodbye =&gt; {}
        }
    }
    return false;
}
<span class="boring">}</span></code></pre></pre>
<p>A cURL command to send a Hello request looks like this.
Make sure to replace the URL with your node's local port and the correct process name.
Note: if you had not set <code>authenticated</code> to false in the bind command, you would need to add an <code>Authorization</code> header to this request with the JWT cookie of your node.
This is saved in your browser automatically on login.</p>
<pre><code class="language-bash">curl -X PUT -H &quot;Content-Type: application/json&quot; -d '{&quot;Hello&quot;: &quot;greetings&quot;}' &quot;http://localhost:8080/tutorial:tutorial:template.os&quot;
</code></pre>
<h2 id="serving-a-static-frontend"><a class="header" href="#serving-a-static-frontend">Serving a static frontend</a></h2>
<p>If you just want to serve an API, you've seen enough now to handle PUTs and GETs to your heart's content.
But the classic personal node app also serves a webpage that provides a user interface for your program.</p>
<p>You <em>could</em> add handling to our <code>/</code> path to dynamically serve some HTML on every GET.
But for maximum ease and efficiency, use the static bind command on <code>/</code> and move our PUT handling to <code>/api</code>.
To do this, edit the bind commands in <code>my_init_fn</code> to look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>http::bind_http_path(&quot;/api&quot;, true, false).unwrap();
http::serve_index_html(&amp;our, &quot;ui&quot;).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Now you can add a static <code>index.html</code> file to the package.
UI files are stored in the <code>ui/</code> directory and built into the application by <code>kit build</code> automatically.
Create a new file in <code>ui/index.html</code> with the following contents.
<strong>Make sure to replace the fetch URL with your process ID!</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;main&gt;
        &lt;h1&gt;This is a website!&lt;/h1&gt;
        &lt;p&gt;Enter a message to send to the process:&lt;/p&gt;
        &lt;form id=&quot;hello-form&quot; class=&quot;col&quot;&gt;
        &lt;input id=&quot;hello&quot; required=&quot;&quot; name=&quot;hello&quot; placeholder=&quot;hello world&quot; value=&quot;&quot;&gt;
        &lt;button&gt; PUT &lt;/button&gt;
      &lt;/form&gt;
    &lt;/main&gt;
	&lt;script&gt;
        async function say_hello(text) {
          const result = await fetch(&quot;/tutorial:tutorial:template.os/api&quot;, {
            method: &quot;PUT&quot;,
            headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },
            body: JSON.stringify({ &quot;Hello&quot;: text }),
          });
          console.log(result);
        }


        document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
          const form = document.getElementById(&quot;hello-form&quot;);
          form.addEventListener(&quot;submit&quot;, (e) =&gt; {
            e.preventDefault();
            e.stopPropagation();
            const text = document.getElementById(&quot;hello&quot;).value;
            say_hello(text);
          });
        });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>This is a super barebones <code>index.html</code> that provides a form to make requests to the <code>/api</code> endpoint.</p>
<p>Finally, add one more entry to <code>manifest.json</code>: messaging capabilities to the VFS which is required to store and access the UI <code>index.html</code>:</p>
<pre><code class="language-json">...
&quot;request_capabilities&quot;: [
    &quot;vfs:distro:sys&quot;
],
...
</code></pre>
<p>After saving this file to <code>ui/index.html</code>, rebuilding the program, and starting the package again, you should be able to navigate to you <code>http://localhost:8080/&lt;process_id&gt;</code> and see the form page.
Note that you can now set <code>authenticated</code> to <code>true</code> in the <code>/api</code> binding and the webpage will still work, but cURL will not.</p>
<p>This frontend is now fully packaged with the process — there are no more steps!
Of course, this can be made arbitrarily complex with various frontend frameworks that produce a static build.</p>
<p>In the next and final chapter, learn about the package metadata and how to share this app across the Kinode network.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../my_first_app/chapter_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../my_first_app/chapter_5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../my_first_app/chapter_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../my_first_app/chapter_5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/customize-buttons.js"></script>


    </div>
    </body>
</html>
