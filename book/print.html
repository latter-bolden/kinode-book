<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nectar Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/fonts/custom-fonts.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="identity_system.html">Identity System</a></li><li class="chapter-item expanded affix "><a href="design_philosophy.html">Design Philosophy</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="install.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="login.html"><strong aria-hidden="true">2.</strong> Join the Network</a></li><li class="chapter-item expanded affix "><li class="part-title">System Components</li><li class="chapter-item expanded "><a href="processes.html"><strong aria-hidden="true">3.</strong> Processes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="process-capabilities.html"><strong aria-hidden="true">3.1.</strong> Capability-Based Security</a></li><li class="chapter-item expanded "><a href="process-startup.html"><strong aria-hidden="true">3.2.</strong> Startup, Spindown, and Crashes</a></li></ol></li><li class="chapter-item expanded "><a href="networking_protocol.html"><strong aria-hidden="true">4.</strong> Networking Protocol</a></li><li class="chapter-item expanded "><a href="pki.html"><strong aria-hidden="true">5.</strong> Public Key Infrastructure</a></li><li class="chapter-item expanded "><a href="http_server_and_client.html"><strong aria-hidden="true">6.</strong> HTTP Server & Client</a></li><li class="chapter-item expanded "><a href="files.html"><strong aria-hidden="true">7.</strong> Files</a></li><li class="chapter-item expanded "><a href="databases.html"><strong aria-hidden="true">8.</strong> Databases</a></li><li class="chapter-item expanded affix "><li class="part-title">Process Standard Library</li><li class="chapter-item expanded "><a href="process_stdlib/overview.html"><strong aria-hidden="true">9.</strong> Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial: Build and Deploy an App</li><li class="chapter-item expanded "><a href="my_first_app/chapter_1.html"><strong aria-hidden="true">10.</strong> Environment Setup</a></li><li class="chapter-item expanded "><a href="my_first_app/chapter_2.html"><strong aria-hidden="true">11.</strong> Sending Some Messages, Using Some Tools</a></li><li class="chapter-item expanded "><a href="my_first_app/chapter_3.html"><strong aria-hidden="true">12.</strong> Defining Your Protocol</a></li><li class="chapter-item expanded "><a href="my_first_app/chapter_4.html"><strong aria-hidden="true">13.</strong> Frontend Time</a></li><li class="chapter-item expanded "><a href="my_first_app/chapter_5.html"><strong aria-hidden="true">14.</strong> Sharing with the World</a></li><li class="chapter-item expanded affix "><li class="part-title">In-Depth Guide: Chess App</li><li class="chapter-item expanded "><a href="chess_app/chess_engine.html"><strong aria-hidden="true">15.</strong> Chess Engine</a></li><li class="chapter-item expanded "><a href="chess_app/frontend.html"><strong aria-hidden="true">16.</strong> Adding a Frontend</a></li><li class="chapter-item expanded "><a href="chess_app/putting_everything_together.html"><strong aria-hidden="true">17.</strong> Putting Everything Together</a></li><li class="chapter-item expanded "><a href="chess_app/chat.html"><strong aria-hidden="true">18.</strong> Extension 1: Chat</a></li><li class="chapter-item expanded affix "><li class="part-title">Kit: Development Toolkit</li><li class="chapter-item expanded "><a href="kit/kit.html"><strong aria-hidden="true">19.</strong> kit</a></li><li class="chapter-item expanded "><a href="kit/boot-fake-node.html"><strong aria-hidden="true">20.</strong> boot-fake-node</a></li><li class="chapter-item expanded "><a href="kit/new.html"><strong aria-hidden="true">21.</strong> new</a></li><li class="chapter-item expanded "><a href="kit/build.html"><strong aria-hidden="true">22.</strong> build</a></li><li class="chapter-item expanded "><a href="kit/start-package.html"><strong aria-hidden="true">23.</strong> start-package</a></li><li class="chapter-item expanded "><a href="kit/remove-package.html"><strong aria-hidden="true">24.</strong> remove-package</a></li><li class="chapter-item expanded "><a href="kit/dev-ui.html"><strong aria-hidden="true">25.</strong> dev-ui</a></li><li class="chapter-item expanded "><a href="kit/inject-message.html"><strong aria-hidden="true">26.</strong> inject-message</a></li><li class="chapter-item expanded "><a href="kit/run-tests.html"><strong aria-hidden="true">27.</strong> run-tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Cookbook (Handy Recipes)</li><li class="chapter-item expanded "><a href="cookbook/cookbook_overview.html"><strong aria-hidden="true">28.</strong> Cookbook Overview</a></li><li class="chapter-item expanded "><a href="cookbook/manage_child_processes.html"><strong aria-hidden="true">29.</strong> Managing Child Processes</a></li><li class="chapter-item expanded "><a href="cookbook/publish_to_web.html"><strong aria-hidden="true">30.</strong> Publishing a Website or Web App</a></li><li class="chapter-item expanded "><a href="cookbook/file_transfer.html"><strong aria-hidden="true">31.</strong> Simple File Transfer Guide</a></li><li class="chapter-item expanded affix "><li class="part-title">API Reference</li><li class="chapter-item expanded "><a href="apis/overview.html"><strong aria-hidden="true">32.</strong> APIs Overview</a></li><li class="chapter-item expanded "><a href="apis/http_authentication.html"><strong aria-hidden="true">33.</strong> HTTP API</a></li><li class="chapter-item expanded "><a href="apis/http_client.html"><strong aria-hidden="true">34.</strong> HTTP Client API</a></li><li class="chapter-item expanded "><a href="apis/http_server.html"><strong aria-hidden="true">35.</strong> HTTP Server API</a></li><li class="chapter-item expanded "><a href="apis/kernel.html"><strong aria-hidden="true">36.</strong> Kernel API</a></li><li class="chapter-item expanded "><a href="apis/kv.html"><strong aria-hidden="true">37.</strong> KV API</a></li><li class="chapter-item expanded "><a href="apis/net.html"><strong aria-hidden="true">38.</strong> Net API</a></li><li class="chapter-item expanded "><a href="apis/nectar_wit.html"><strong aria-hidden="true">39.</strong> nectar.wit</a></li><li class="chapter-item expanded "><a href="apis/sqlite.html"><strong aria-hidden="true">40.</strong> SQLITE API</a></li><li class="chapter-item expanded "><a href="apis/terminal.html"><strong aria-hidden="true">41.</strong> Terminal API</a></li><li class="chapter-item expanded "><a href="apis/vfs.html"><strong aria-hidden="true">42.</strong> VFS API</a></li><li class="chapter-item expanded "><a href="apis/websocket_authentication.html"><strong aria-hidden="true">43.</strong> Websocket API</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nectar Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The Nectar Book describes the Nectar operating system, both in conceptual and practical terms.</p>
<ul>
<li>To get your hands dirty developing, jump to <a href="./my_first_app/chapter_1.html">My First Nectar Application</a>.</li>
<li>To learn about high-level concepts, keep reading these documents in-order.</li>
<li>To learn about how the system functions, start reading about <a href="./processes.html">System Components</a>.</li>
</ul>
<p>NectarOS is a decentralized operating system, peer-to-peer app framework, and node network designed to simplify the development and deployment of decentralized applications.
It is also a <em>sovereign cloud computer</em>, in that Nectar can be deployed anywhere and act as a server controlled by anyone.
Ultimately, Nectar facilitates the writing and distribution of software that runs on privately-held, personal server nodes or node clusters.</p>
<p>Nectar eliminates boilerplate and reduces the complexity of p2p software development by providing four basic and necessary primitives:</p>
<div class="table-wrapper"><table><thead><tr><th>Primitive</th><th>Description</th></tr></thead><tbody>
<tr><td>Networking</td><td>Passing messages from peer to peer.</td></tr>
<tr><td>Identity</td><td>Linking permanent system-wide identities to individual nodes.</td></tr>
<tr><td>Data Persistence</td><td>Storing data and saving it in perpetuity.</td></tr>
<tr><td>Global State</td><td>Reading shared global state (blockchain) and composing actions with this state (transactions).</td></tr>
</tbody></table>
</div>
<p>The focus of this book is how to build and deploy applications on NectarOS.</p>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>Applications are composed of processes, which hold state and pass messages.
Nectar's kernel handles the startup and teardown of processes, as well as message-passing between processes, both locally and across the network.
Processes are programs compiled to Wasm, which export a single <code>init()</code> function.
They can be started once and complete immediately, or they can run &quot;forever&quot;.</p>
<p>Peers in NectarOS are identified by their onchain username in the &quot;NDNS&quot;: Nectar Domain Name System, which is modeled after ENS.
The modular architecture of the NDNS allows for any Ethereum NFT, including ENS names themselves, to generate a unique Nectar identity once it is linked to a NDNS entry.</p>
<p>Data persistence and blockchain access, as fundamental primitives for p2p apps, are built directly into the kernel.
The filesystem is abstracted away from the developer, and data is automatically persisted across an arbitrary number of encrypted remote backups as configured at the user-system-level.
Accessing global state in the form of the Ethereum blockchain is now trivial, with chain reads and writes handled by built-in system runtime modules.</p>
<p>Several other I/O primitives also come with the kernel: an HTTP server and client framework, as well as a simple key-value store.
Together, these tools can be used to build performant and self-custodied full-stack applications.</p>
<p>Finally, by the end of this book, you will learn how to deploy applications to the Nectar network, where they will be discoverable and installable by any user with an Nectar node.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identity-system"><a class="header" href="#identity-system">Identity System</a></h1>
<p>One of the most important features of a peer-to-peer network is the ability to maintain a unique and persistent identity.
This identity must be self-sovereign, unforgeable, and easy to discover by peers.
NectarOS uses a domain system similar to <a href="https://ens.domains/">ENS</a> to achieve this.
It should be noted that, in our system, the concepts of <code>domain</code>, <code>identity</code>, and <code>username</code> are identical and interchangeable.</p>
<p>Like ENS, Nectar domains (managed by our NDNS) are registered by a wallet and owned in the form of an NFT.
However, unlike ENS, Nectar domains never expire. Additionally, they contain metadata necessary to both:</p>
<ul>
<li>demonstrate the provenance of a given identity.</li>
<li>route messages to the identity on the Nectar network.</li>
</ul>
<p>NDNS provides both sensible defaults and flexibility.
The cheapest option is also the default: minting a new NFT, a <code>.nec</code> TLD.
However, unlike ENS, NDNS is not restricted to a single set of NFTs.
Instead, it is designed to easily extend and wrap existing NFTs, enabling users to use identities they are already attached to as their Nectar identity.</p>
<p>What does this look like in practice?</p>
<p>It's easy enough to check for provenance of a given identity.
If you have an Nectar domain, you can prove ownership by signing a message with the wallet that owns the domain.
However, to essentially use your Nectar identity as a domain name for your personal server, NDNS domains have routing information, similar to a DNS record, that points to an IP address.</p>
<p>A NDNS domain can either be <code>direct</code> or <code>indirect</code>.
When users first boot a node, they may decide between these two domain types as they create their initial identity.
Direct nodes share their literal IP address and port in their metadata, allowing other nodes to message them directly.
Again, this is similar to registering a WWW domain name and pointing it at your web server.
However, running a direct node is both technically demanding (you must maintain the ability of your machine to be accessed remotely) and a security risk (you must open ports on the server to the public internet).
Therefore, indirect nodes are the best choice for the majority of users that choose to run their own node (TODO: what about those who have someone else run it? A hosting service?).</p>
<p>Instead of sharing their IP and port, indirect nodes simply post a list of <em>routers</em> onchain.
These routers are other <em>direct</em> nodes that have agreed to forward messages to indirect nodes.
When a node wants to send a message to an indirect node, it first finds the node onchain, and then sends the message to one of the routers listed in the node's metadata.
The router is responsible for forwarding the message to the indirect node and similarly forwarding messages from that node back to the network at large.</p>
<p>For more information about the architectural specifics of the networking protocol, see <a href="./networking_protocol.html">Networking Protocol</a>.
The main takeaway for the identity system is that <em>domain provenance</em> and <em>domain resolution</em> are unified by NDNS.</p>
<p>Like .eth for ENS, the NDNS domain space is fixed inside the <code>.nec</code> top-level domain.
However, we reserve the ability to expand domain availability in the future, and governance of the Nectar protocol will include the ability to manage domain names.
Eventually, we hope to link various TLDs to existing NFT communities and other identity systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h1>
<p>The following is a high-level overview of NectarOS's design philosophy, along with the rationale for fundamental design choices.</p>
<h3 id="decentralized-software-requires-a-shared-computing-environment"><a class="header" href="#decentralized-software-requires-a-shared-computing-environment">Decentralized Software Requires a Shared Computing Environment</a></h3>
<p>A single shared computing environment enables software to coordinate directly between users, services, and other pieces of software in a common language.
Therefore, the best way to enable decentralized software is to provide an easy-to-use, general purpose node (that can run on anything from laptops to data centers) that runs the same operating system as all other nodes on the network.
This environment must integrate with existing protocols, blockchains, and services to create a new set of protocols that operate peer-to-peer within the node network.</p>
<h3 id="decentralization-is-broad"><a class="header" href="#decentralization-is-broad">Decentralization is Broad</a></h3>
<p>A wide array of companies and services benefit from some amount of decentralized infrastructure, even those operating in a largely centralized context.
Additionally, central authority and centralized data are often essential to the proper function of a particular service, including those with decentralized properties.
The Nectar environment must be flexible enough to serve the vast majority of the decentralization spectrum.</p>
<h3 id="blockchains-are-not-databases"><a class="header" href="#blockchains-are-not-databases">Blockchains are not Databases</a></h3>
<p>To use blockchains as mere databases would negate their unique value.
Blockchains are consensus tools, and exist in a spectrum alongside other consensus strategies such as Raft, lockstep protocols, CRDTs, and simple gossip.
All of these are valid consensus schemes, and peer-to-peer software, such as that built on Nectar, must choose the correct strategy for a particular task, program, or application.</p>
<h3 id="decentralized-software-outcompetes-centralized-software-through-permissionlessness-and-composability"><a class="header" href="#decentralized-software-outcompetes-centralized-software-through-permissionlessness-and-composability">Decentralized Software Outcompetes Centralized Software through Permissionlessness and Composability</a></h3>
<p>Therefore, any serious decentralized network must identify and prioritize the features that guarantee permissionless and composable development.
Those features include:</p>
<ul>
<li>a persistent software environment (software can run forever once deployed)</li>
<li>client diversity (more actors means fewer monopolies)</li>
<li>perpetual backwards-compatibility</li>
<li>a robust node network that ensures individual ownership of software and data</li>
</ul>
<h3 id="decentralized-software-requires-decentralized-governance"><a class="header" href="#decentralized-software-requires-decentralized-governance">Decentralized Software Requires Decentralized Governance</a></h3>
<p>The above properties are achieved by governance.
Successful protocols launched on Nectar will be ones that decentralize their governance in order to maintain these properties.
We believe that systems that don't proactively specify their point of control will eventually centralize, even if unintentionally.
The governance of Nectar itself must be designed to encourage decentralization, playing a role in the publication and distribution of userspace software protocols.
In practice, this looks like an on-chain permissionless App Store.</p>
<h3 id="good-products-use-existing-tools"><a class="header" href="#good-products-use-existing-tools">Good Products Use Existing Tools</a></h3>
<p>Nectar is a novel combination of existing technologies, protocols, and ideas.
Our goal is not to create a new programming language or consensus algorithm, but to build a new execution environment that integrates the best of existing tools.
Our current architecture relies on the following systems:</p>
<ul>
<li>ETH: a trusted execution layer</li>
<li>Rust: a performant, expressive, and popular programming language</li>
<li>Wasm: a portable, powerful binary format for executable programs</li>
<li>Wasmtime: a standalone Wasm runtime</li>
</ul>
<p>In addition, Nectar is inspired by the <a href="https://bytecodealliance.org/">Bytecode Alliance</a> and their vision for secure, efficient, and modular software.
We make extensive use of their tools and standards.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This section will teach you how to get the NectarOS core software, required to run a live node.
After acquiring the software, you can learn how to run it and <a href="./login.html">Join the Network</a>.
However, if you are just interested in starting development as fast as possible, start with <a href="./my_first_app/chapter_1.html">My First Nectar Application</a>.</p>
<h2 id="download-binary"><a class="header" href="#download-binary">Download Binary</a></h2>
<p>The recommended method for most users is to use a precompiled binary.
If you want to make edits to the Nectar core software, see <a href="install.html#build-from-source">Build From Source</a>.</p>
<p>First, get the software itself by downloading a <a href="https://github.com/uqbar-dao/nectar/releases">precompiled release binary</a>.
Choose the correct binary for your particular computer architecture and OS.
Extract the <code>.zip</code> file and the binary is inside.</p>
<p>Note that some operating systems, particularly Apple, may flag the download as suspicious.
While the binary has not been tested exhaustively on all Linux distributions, it should <em>just work</em>.</p>
<h3 id="apple"><a class="header" href="#apple">Apple</a></h3>
<p>First, attempt to run the binary, which Apple will block.
Then, go to <code>System Settings &gt; Privacy and Security</code> and click to <code>Allow Anyway</code> for the <code>nectar</code> binary:</p>
<p><img src="./assets/apple-unknown-developer.png" alt="Apple unknown developer" /></p>
<h2 id="build-from-source"><a class="header" href="#build-from-source">Build From Source</a></h2>
<p>You can compile the binary from source using the following instructions.</p>
<h3 id="acquire-rust-and-various-tools"><a class="header" href="#acquire-rust-and-various-tools">Acquire Rust and various tools</a></h3>
<p>Install Rust and some <code>cargo</code> tools, by running the following in your terminal:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
cargo install wasm-tools
rustup install nightly
rustup target add wasm32-wasi
rustup target add wasm32-wasi --toolchain nightly
cargo install cargo-wasi
</code></pre>
<p>For more information, or debugging, see the <a href="https://www.rust-lang.org/tools/install">Rust lang install page</a>.</p>
<h3 id="acquire-nectaros-core"><a class="header" href="#acquire-nectaros-core">Acquire NectarOS core</a></h3>
<p>Clone and set up the repository:</p>
<pre><code class="language-bash">git clone git@github.com:uqbar-dao/nectar.git

cd nectar
mkdir .cargo
echo &quot;net.git-fetch-with-cli = true&quot; &gt; .cargo/config
</code></pre>
<p>Build the binary:</p>
<pre><code class="language-bash">cargo +nightly build --release
</code></pre>
<p>The resulting binary will be at path <code>target/release/nectar</code>.</p>
<p>You can also build the binary without the <code>--release</code> flag.
This command will build the binary significantly faster, as it does not perform any optimizations during compilation, but it will run much more slowly after compiling.
The non-release binary will be at path <code>target/debug/nectar</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join-the-network"><a class="header" href="#join-the-network">Join the Network</a></h1>
<p>Let's get onto the live network!</p>
<p>These directions are particular to the NectarOS alpha release.
Joining the network will become significantly easier on subsequent releases.</p>
<p>Note: While Nectar will eventually post identities to Optimism, the alpha release uses the Ethereum Sepolia testnet.</p>
<h2 id="creating-an-alchemy-account"><a class="header" href="#creating-an-alchemy-account">Creating an Alchemy Account</a></h2>
<p>Alchemy is used as an <a href="login.html#acquiring-an-rpc-api-key">Ethereum RPC endpoint</a> and as a <a href="login.html#aside-acquiring-sepolia-testnet-eth">faucet for Sepolia testnet ETH</a>.
An Ethereum RPC endpoint and Sepolia ETH are required to send and receive Ethereum transactions that support the Nectar identity system.
If you do not already have one, register an <a href="https://www.alchemy.com/">Alchemy account</a>.
The account is free and requires only an email address for registration.</p>
<h2 id="starting-the-nectar-node"><a class="header" href="#starting-the-nectar-node">Starting the Nectar node</a></h2>
<p>Start an Nectar node using the binary acquired in the <a href="./install.html">previous section</a>.
Locating the binary on your system, run:</p>
<pre><code class="language-bash">$ ./nectar --help
</code></pre>
<p>This will reveal the arguments expected by the binary:</p>
<pre><code class="language-bash">A General Purpose Sovereign Cloud Computing Platform

Usage: nectar [OPTIONS] --rpc &lt;WS_URL&gt; &lt;home&gt;

Arguments:
  &lt;home&gt;  Path to home directory

Options:
      --port &lt;PORT&gt;   First port to try binding [default: 8080]
      --rpc &lt;WS_URL&gt;  Ethereum RPC endpoint (must be wss://)
  -h, --help          Print help
  -V, --version       Print version
</code></pre>
<p>A home directory must be supplied — where the node will store its files.
The binary also takes a required <code>--rpc</code> flag.
The <code>--rpc</code> flag is a <code>wss://</code> WebSocket link to an Ethereum RPC, allowing the Nectar node can send and receive Ethereum transactions — used in the <a href="./identity_system.html">identity system</a> as mentioned <a href="login.html#creating-an-alchemy-account">above</a>.
Finally, by default, the node will bind to port 8080; this can be modified with the <code>--port</code> flag.</p>
<h3 id="acquiring-an-rpc-api-key"><a class="header" href="#acquiring-an-rpc-api-key">Acquiring an RPC API Key</a></h3>
<p>Create a new &quot;app&quot; on <a href="https://dashboard.alchemy.com/apps">Alchemy</a> on the Ethereum Sepolia network.</p>
<p><img src="./assets/alchemy-create-app.png" alt="Alchemy Create App" /></p>
<p>Copy the WebSocket API key from the API Key button:</p>
<p><img src="./assets/alchemy-api-key.png" alt="Alchemy API Key" /></p>
<h3 id="running-the-binary"><a class="header" href="#running-the-binary">Running the Binary</a></h3>
<p>Replace the <code>--rpc</code> field below with the WebSocket API key link copied from <a href="login.html#acquiring-an-rpc-api-key">the previous step</a>, and start the node with:</p>
<pre><code class="language-bash">./nectar home --rpc wss://eth-sepolia.g.alchemy.com/v2/&lt;your-api-key&gt;
</code></pre>
<p>A new browser tab should open, but if not, look in the terminal for a line like</p>
<pre><code>login or register at http://localhost:8080
</code></pre>
<p>and open that <code>localhost</code> address in a web browser.</p>
<h2 id="registering-an-identity"><a class="header" href="#registering-an-identity">Registering an Identity</a></h2>
<p>Next, register an identity.
If the page looks like:</p>
<p><img src="./assets/register-need-wallet.png" alt="Register need wallet" /></p>
<p>then proceed to <a href="login.html#aside-acquiring-a-wallet">Acquiring a Wallet</a>.
Otherwise, if the page looks like:</p>
<p><img src="./assets/register-have-wallet.png" alt="Register have wallet" /></p>
<p>the browser already has a supported wallet installed.
Click <code>Register NecName</code> and proceed to <a href="login.html#connecting-the-wallet">Connecting the Wallet</a>.</p>
<h3 id="aside-acquiring-a-wallet"><a class="header" href="#aside-acquiring-a-wallet">Aside: Acquiring a Wallet</a></h3>
<p>To register an identity, Nectar must send an Ethereum transaction, which requires ETH and a cryptocurrency wallet.
While many wallets will work, the examples below use Metamask.
Install Metamask <a href="https://metamask.io/download/">here</a>.</p>
<h3 id="connecting-the-wallet"><a class="header" href="#connecting-the-wallet">Connecting the Wallet</a></h3>
<p>After registering a username, click through until you reach <code>Connect Wallet</code> and follow the wallet prompts:</p>
<p><img src="./assets/register-connect-wallet.png" alt="Register connect wallet" /></p>
<h3 id="aside-acquiring-sepolia-testnet-eth"><a class="header" href="#aside-acquiring-sepolia-testnet-eth">Aside: Acquiring Sepolia Testnet ETH</a></h3>
<p>Using the Alchemy account <a href="login.html#creating-an-alchemy-account">registered above</a>, use the <a href="https://sepoliafaucet.com/">Sepolia faucet</a> to acquire Sepolia ETH if you do not already have some in your wallet.
Then, return to the Nectar node.</p>
<h3 id="setting-up-networking-direct-vs-routed-nodes"><a class="header" href="#setting-up-networking-direct-vs-routed-nodes">Setting Up Networking (Direct vs. Routed Nodes)</a></h3>
<p>When registering on Nectar, you may choose between running a direct or indirect (routed) node.
Most users should use an indirect node.
To do this, simply leave the box below name registration unchecked.</p>
<p><img src="./assets/register-select-name.png" alt="Register select name" /></p>
<p>Am indirect node connects to the network through a router, which is a direct node that serves as an intermediary, passing packets from sender to receiver.
Routers make connecting to the network convenient, and so are the default.
If you are connecting from a laptop that isn't always on, or that changes WiFi networks, use an indirect node.</p>
<p>A direct node connects directly, without intermediary, to other nodes (though they may, themselves, be using a router).
Direct nodes may have better performance, since they remove middlemen from connections.
Direct nodes also reduces the number of third parties that know about the connection between your node and your peer's node (if both you and your peer use direct nodes, there will be no third party involved).</p>
<p>Use an indirect node unless you are familiar with running servers.
A direct node must be served from a static IP and port, since these are registered on the Ethereum network and are how other nodes will attempt to contact you.</p>
<p>Regardless, all packets, passed directly or via a router, are end-to-end encrypted.
Only you and the recipient can read messages.</p>
<p>As a direct node, your IP is published on the blockchain.
As an indirect node, only your router knows your IP.</p>
<h3 id="sending-the-registration-transaction"><a class="header" href="#sending-the-registration-transaction">Sending the Registration Transaction</a></h3>
<p>After clicking <code>Register Necname</code>, click through the wallet prompts to send the transaction:</p>
<p><img src="./assets/register-wallet-prompt.png" alt="Register wallet prompt" /></p>
<h3 id="what-does-the-password-do"><a class="header" href="#what-does-the-password-do">What Does the Password Do?</a></h3>
<p>The password encrypts the node's networking key.
The networking key is how your node communicates securely with other nodes, and how other nodes can be certain that you are who you say you are.</p>
<p><img src="./assets/register-set-password.png" alt="Register set password" /></p>
<h2 id="welcome-to-the-network"><a class="header" href="#welcome-to-the-network">Welcome to the Network</a></h2>
<p>After setting the node password, you will be greeted with the homepage.</p>
<p><img src="./assets/homepage.png" alt="Homepage" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processes"><a class="header" href="#processes">Processes</a></h1>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>On NectarOS, processes are the building blocks for peer-to-peer applications.
The Nectar runtime handles message-passing between processes, plus the startup and teardown of said processes.
This section describes the message design as it relates to processes.</p>
<p>Processes have a globally unique identifier, or &quot;address&quot;, composed of four elements.
First, the publisher's node.
Second, the package name.
Third, the process identifier.
Processes spawn with their own identifier: either a developer-selected string or a randomly-generated number as string.
And finally, the node the process is running on (your node).</p>
<p>Package IDs (TODO: link to docs) look like:</p>
<pre><code>my_cool_software:my_username.nec
</code></pre>
<p>Process IDs (TODO: link to docs) look like:</p>
<pre><code>process_one:my_cool_software:my_username.nec
8513024814:my_cool_software:my_username.nec
</code></pre>
<p>Addresses (TODO: link to docs) look like:</p>
<pre><code>some_user.nec@process_one:my_cool_software:my_username.nec
</code></pre>
<p>Processes are compiled to Wasm.
They can be started once and complete immediately, or they can run forever.
They can spawn other processes, and coordinate in arbitrarily complex ways by passing messages to one another.</p>
<h3 id="process-state"><a class="header" href="#process-state">Process State</a></h3>
<p>Nectar processes can be stateless or stateful.
In this case, state refers to data that is persisted between process instantiations.
Nodes get turned off, intentionally or otherwise.
The kernel handles rebooting processes that were running previously, but their state is not persisted by default.</p>
<p>Instead, processes elect to persist data, and what data to persist, when desired.
Data might be persisted after every message ingested, after every X minutes, after a certain specific event, or never.
When data is persisted, the kernel saves it to our abstracted filesystem, which not only persists data on disk, but also across arbitrarily many encrypted remote backups as configured at the user-system-level.</p>
<p>This design allows for ephemeral state that lives in-memory, or truly permanent state, encrypted across many remote backups, synchronized and safe. <a href="./files.html">Read more about filesystem persistence here</a>.</p>
<h3 id="requests-and-responses"><a class="header" href="#requests-and-responses">Requests and Responses</a></h3>
<p>Processes communicate by passing messages, of which there are two kinds: <code>requests</code> and <code>responses</code>.</p>
<h4 id="addressing"><a class="header" href="#addressing">Addressing</a></h4>
<p>When a request or response is received, it has an attached <code>address</code>, which consists of: the source of the message, including the ID of the process that produced the request, as well as the ID of the originating node.</p>
<p>The integrity of a source <code>address</code> differs between local and remote messages.
If a message is local, the validity of its source is ensured by the local kernel, which can be trusted to label the process ID and node ID correctly.
If a message is remote, only the node ID can be validated (via networking keys associated with each node ID).
The process ID comes from the remote kernel, which could claim any process ID.
This is fine — merely consider remote process IDs a <em>claim</em> about the initiating process rather than an infallible ID like in the local case.</p>
<h4 id="please-respond"><a class="header" href="#please-respond">Please Respond</a></h4>
<p>Requests can be issued at any time by a running process.
A request can optionally expect a response.
If it does, the request will be retained by the kernel, along with an optional <code>context</code> object created by the request's issuer.
A request will be considered outstanding until the kernel receives a matching response, at which point that response will be delivered to the requester alongside the optional <code>context</code>.
<code>context</code>s allow responses to be disambiguated when handled asynchronously, for example, when some information about the request must be used in handling the response.
Responses can also be handled in an async-await style, discussed <a href="processes.html#awaiting-a-response">below</a>.</p>
<p>Requests that expect a response set a timeout value, after which, if no response is received, the initial request is returned to the process that issued it as an error.
<a href="processes.html#errors">Send errors</a> are handled in processes alongside other incoming messages.</p>
<h5 id="inheriting-a-response"><a class="header" href="#inheriting-a-response">Inheriting a Response</a></h5>
<p>If a process receives a request, that doesn't mean it must directly issue a response.
The process can instead issue request(s) that &quot;inherit&quot; from the incipient request, continuing its lineage.
If a request does not expect a response and also &quot;inherits&quot; from another request, responses to the child request will be returned to the parent request's issuer.
This allows for arbitrarily complex request-response chains, particularly useful for &quot;middleware&quot; processes.</p>
<p>There is one other use of inheritance, discussed below: <a href="processes.html#inheriting-a-lazy_load_blob">passing data in request chains cheaply</a>.</p>
<h5 id="awaiting-a-response"><a class="header" href="#awaiting-a-response">Awaiting a Response</a></h5>
<p>When sending a request, a process can await a response to that specific request, queueing other messages in the meantime.
Awaiting a response leads to easier-to-read code:</p>
<ul>
<li>The response is handled in the next line of code, rather than in a separate iteration of the message-handling loop</li>
<li>Therefore, the <code>context</code> need not be set.
The downside of awaiting a response is that all other messages to a process will be queued until that response is received and handled.</li>
</ul>
<p>As such, certain applications lend themselves to blocking with an await, and others don't.
A rule of thumb is: await responses (because simpler code) except when a process needs to performantly handle other messages in the meantime.</p>
<p>For example, if a file-transfer process can only transfer one file at a time, requests can simply await responses, since the only possible next message will be a response to the request just sent.
In contrast, if a file-transfer process can transfer more than one file at a time, requests that await responses will block others in the meantime; for performance it may make sense to write the process fully asynchronously.
The constraint on awaiting is a primary reason why it is desirable to <a href="processes.html#spawning-child-processes">spawn child processes</a>.
Continuing the file-transfer example, by spawning one child &quot;worker&quot; process per file to be transferred, each worker can use the await mechanic to simplify the code, while not limiting performance.</p>
<h4 id="message-structure"><a class="header" href="#message-structure">Message Structure</a></h4>
<p>Messages, both requests and responses, can contain arbitrary data, which must be interpreted by the process that receives it.
The structure of a message contains hints about how best to do this:</p>
<p>First, messages contain a field labeled <code>body</code>, which holds the actual contents of the message.
In order to cross the Wasm boundary and be language-agnostic, the <code>body</code> field is simply a byte vector.
To achieve composability between processes, a process should be very clear, in code and documentation, about what it expects in the <code>body</code> field and how it gets parsed, usually into a language-level struct or object.</p>
<p>A message also contains a <code>lazy_load_blob</code>, another byte vector, used for opaque, arbitrary, or large data.
<code>lazy_load_blob</code>s, along with being suitable location for miscellaneous message data, are an optimization for shuttling messages across the Wasm boundary.
Unlike other message fields, the <code>lazy_load_blob</code> is only moved into a process if explicitly called with (<code>get_blob()</code>).
Processes can thus choose whether to ingest a <code>lazy_load_blob</code> based on the <code>body</code>/<code>metadata</code>/<code>source</code>/<code>context</code> of a given message.
<code>lazy_load_blob</code>s hold bytes alongside a <code>mime</code> field for explicit process-and-language-agnostic format declaration, if desired.
See <a href="processes.html#inheriting-a-lazy_load_blob">inheriting a <code>lazy_load_blob</code></a> for a discussion of why lazy loading is useful.</p>
<p>Lastly, messages contain an optional <code>metadata</code> field, expressed as a JSON-string, to enable middleware processes and other such things to manipulate the message without altering the <code>body</code> itself.</p>
<h5 id="inheriting-a-lazy_load_blob"><a class="header" href="#inheriting-a-lazy_load_blob">Inheriting a <code>lazy_load_blob</code></a></h5>
<p>The reason <code>lazy_load_blob</code>s are not automatically loaded into a process is that an intermediate process may not need to access the blob.
If process A sends a message with a blob to process B, process B can send a message that inherits to process C.
If process B does not attach a new <code>lazy_load_blob</code> to that inheriting message, the original blob from process A will be attached and accessible to C.</p>
<p>For example, consider again the file-transfer process discussed <a href="processes.html#awaiting-a-response">above</a>.
Say one node, <code>send.nec</code>, is transferring a file to another node, <code>recv.nec</code>.
The process of sending a file chunk will look something like:</p>
<ol>
<li><code>recv.nec</code> sends a request for chunk N</li>
<li><code>send.nec</code> receives the request and itself makes a request to the filesystem for the piece of the file</li>
<li><code>send.nec</code> receives a response from the filesystem with the piece of the file in the <code>lazy_load_blob</code>;
<code>send.nec</code> sends a response that inherits the blob back to <code>recv.nec</code> without itself having to load the blob, saving the compute and IO required to move the blob across the Wasm boundary.</li>
</ol>
<p>This is the second functionality of inheritance; the first is discussed above: <a href="processes.html#inheriting-a-response">eliminating the need for bucket-brigading of responses</a>.</p>
<h4 id="errors"><a class="header" href="#errors">Errors</a></h4>
<p>Messages that result in networking failures, like requests that timeout, are returned to the process that created them as an error.
There are only two kinds of send errors: Offline and Timeout.
Offline means a message's remote target definitively cannot be reached.
Timeout is multi-purpose: for remote nodes, it may indicate compromised networking; for both remote and local nodes, it may indicate that a process is simply failing to respond in the required time.</p>
<p>A send error will return to the originating process the initial message, along with any optional <code>context</code>, so that the process can re-send the message, crash, or otherwise handle the failure as the developer desires.
If the error results from a response, the process may optionally try to re-send a response: it will be directed towards the original outstanding request.</p>
<h3 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h3>
<p>Processes must acquire capabilities from the kernel in order to perform certain operations.
Processes themselves can also produce capabilities in order to give them to other processes.
For more information about the general capabilities-based security paradigm, [insert link to good article here].</p>
<p>The kernel gives out capabilities that allow a process to message another <em>local</em> process.
It also gives a capability allowing processes to send and receive messages over the network.
A process can optionally mark itself as <code>public</code>, meaning that it can be messaged by any <em>local</em> process regardless of capabilities.</p>
<p><a href="./process-capabilities.html">See the capabilities chapter for more details.</a></p>
<h3 id="spawning-child-processes"><a class="header" href="#spawning-child-processes">Spawning child processes</a></h3>
<p>A process can spawn &quot;child&quot; processes -- in which case the spawner is known as the &quot;parent&quot;.
As discussed <a href="processes.html#awaiting-a-response">above</a>, one of the primary reasons to write an application with multiple processes is to enable both simple code and high performance.</p>
<p>Child processes can be used to:</p>
<ol>
<li>Run code that may crash without risking crashing the parent</li>
<li>Run compute-heavy code without blocking the parent</li>
<li>Run IO-heavy code without blocking the parent</li>
<li>Break out code that is more easily written with awaits to avoid blocking the parent</li>
</ol>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>This is a high-level overview of process semantics.
In practice, processes are combined and shared in <strong>packages</strong>, which are generally synonymous with <strong>apps</strong>.</p>
<p>It's briefly discussed here that processes are compiled to Wasm.
The details of this are not covered in the Nectar Book, but can be found in the documentation for the <a href="https://github.com/uqbar-dao/nectar">Nectar runtime</a>, which uses <a href="https://wasmtime.dev/">Wasmtime</a>, a WebAssembly runtime, to load, execute, and provide an interface for the subset of Wasm processes that are valid Nectar processes.
Pragmatically, processes can be compiled using the <a href="https://github.com/uqbar-dao/kit"><code>kit</code> tools</a>.
The long term goal of the Nectar runtime is to use <a href="https://wasi.dev/">WASI</a> to provide a secure, sandboxed environment for processes to not only make use of the kernel features described in this document, but also to make full use of the entire WebAssembly ecosystem, including the ability to use sandboxed system calls provided by the host via WASI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capability-based-security"><a class="header" href="#capability-based-security">Capability-Based Security</a></h1>
<p>Capabilities are a security paradigm in which an ability that is usually handled as a <em>permission</em> (i.e. certain processes are allowed to perform an action if they are saved on an &quot;access control list&quot;) are instead handled as a <em>token</em> (i.e. the process that possesses token can perform a certain action).
These unforgeable tokens (as enforced by the kernel) can be passed to other owners, held by a given process, and checked for.</p>
<p>In NectarOS, each process has an associated set of capabilities, which are each represented internally as an arbitrary JSON object with a source process:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Capability {
    pub issuer: Address,
    pub params: String, // JSON-string
}
<span class="boring">}</span></code></pre></pre>
<p>The kernel abstracts away the process of ensuring that a capability is not forged.
As a process developer, if a capability comes in on a message or is granted to you by the kernel, you can guarantee that it is legitimate.</p>
<p>Runtime processes, including the kernel itself, the filesystem, and the HTTP client, use capabilities to ensure that only the processes that should be able to access them can do so.
For example, the filesystem has read/write capabilities that determine whether you can perform those operations on a drive.</p>
<p><a href="process-capabilities.html#startup-capabilities-with-manifestjson">System level capabilities</a> like the above can only be given when a process is installed.</p>
<h2 id="startup-capabilities-with-manifestjson"><a class="header" href="#startup-capabilities-with-manifestjson">Startup Capabilities with <code>manifest.json</code></a></h2>
<p>When developing a process, the first encounter you will have with capabilities is with the <code>manifest.json</code> file, where capabilities are directly granted to a process on startup.
Upon install, the package manager (also referred to as &quot;app store&quot;) surfaces these requested capabilities to the user, who can then choose to grant them or not.Here is a <code>manfiest.json</code> example for the <code>chess</code> app:</p>
<pre><code class="language-json">[
    {
        &quot;process_name&quot;: &quot;chess&quot;,
        &quot;process_wasm_path&quot;: &quot;/chess.wasm&quot;,
        &quot;on_exit&quot;: &quot;Restart&quot;,
        &quot;request_networking&quot;: true,
        &quot;request_capabilities&quot;: [
            &quot;net:sys:nectar&quot;
        ],
        &quot;grant_capabilities&quot;: [
            &quot;http_server:sys:nectar&quot;
        ],
        &quot;public&quot;: true
    }
]
</code></pre>
<p>By setting <code>request_networking: true</code>, the kernel will give it the <code>&quot;networking&quot;</code> capability. In the <code>request_capabilities</code> field, <code>chess</code> is asking for the capability to message <code>net:sys:nectar</code>.
Finally, in the <code>grant_capabilities</code> field, it is giving <code>http_server:sys:nectar</code> the ability to message <code>chess</code>.</p>
<p>When booting the <code>chess</code> app, all of these capabilities will be granted throughout your node.
If you were to print out <code>chess</code>' capabilities using <code>nectar_process_lib::our_capabilities() -&gt; Vec&lt;Capability&gt;</code>, you would see something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[
    // obtained because of `request_networking: true`
    Capability { issuer: &quot;our@kernel:sys:nectar&quot;, params: &quot;\&quot;network\&quot;&quot; },
    // obtained because we asked for it in `request_capabilities`
    Capability { issuer: &quot;our@net:sys:nectar&quot;, params: &quot;\&quot;messaging\&quot;&quot; }
]
<span class="boring">}</span></code></pre></pre>
<p>Note that <a href="process-capabilities.html#userspace-capabilities">userspace capabilities</a>, those <em>created by other processes</em>, can also be requested in a package manifest, though it's not guaranteed that the user will have installed the process that can grant the capability.
Therefore, when a userspace process uses the capabilities system, it should have a way to grant capabilities through its <code>body</code> protocol, as described below.</p>
<h2 id="userspace-capabilities"><a class="header" href="#userspace-capabilities">Userspace Capabilities</a></h2>
<p>While the manifest fields are useful for getting a process started, it is not sufficient for creating and giving custom capabilities to other processes.
To create your own capabilities, simply declare a new one and attach it to a <code>Request</code> or <code>Response</code> like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_new_cap = nectar_process_lib::Capability::new(our, &quot;\&quot;my-new-capability\&quot;&quot;);

Request::new()
    .to(a_different_process)
    .capabilities(vec![my_new_cap])
    .send();
<span class="boring">}</span></code></pre></pre>
<p>On the other end, if a process wants to save and reuse that capability, they can do something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>nectar_process_lib::save_capabilities(req.capabilities);
<span class="boring">}</span></code></pre></pre>
<p>This call will automatically save the caps for later use.
Next time you attach this cap to a message, whether that is for authentication with the <code>issuer</code>, or to share it with another process, it will reach the other side just fine, and they can check it using the exact same flow.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="startup-spindown-and-crashes"><a class="header" href="#startup-spindown-and-crashes">Startup, Spindown, and Crashes</a></h1>
<p>Along with learning how processes communicate, understanding the lifecycle paradigm of Nectar processes is essential to developing useful p2p applications.
Recall that a 'package' is a userspace construction that contains one or more processes. The Nectar kernel is only aware of processes.
When a process is first initialized, its compiled Wasm code is loaded into memory and, if the code is valid, the process is added to the kernel's process table.
Then, the <code>init</code> function common to all processes is called.</p>
<p>This scenario is identical to when a process is re-initialized. From the perspective of both the kernel and the process code, there is no difference.</p>
<p>Given that Nectar nodes can, comporting with the realities of the physical world, be turned off, a well-written process must withstand being shut down and reinstantiated at any time.
This raises the question: how do processes persist information between instantiations?
There are two ways: either the process can use the built-in <code>set_state</code> and <code>get_state</code> functions, or it can send data to a process that does this for them.</p>
<p>The first option is a maximally-simple way to write some bytes to disk (where they'll be backed up, if the node owner has configured that behavior).
The second option is vastly more general, because runtime modules that have direct messaging availability from userspace offer any number of APIs.
So far, there are three modules built into NectarOS that are designed for persisted data: a <a href="./files.html">filesystem</a>, a <a href="./databases.html">key-value store, and a SQLite database</a>.</p>
<p>Each of these modules offer APIs accessed via message-passing and write data to disk.
Between instantiations of a process, this data remains saved, even backed up.
The process can then retrieve this data when it is re-instantiated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-protocol"><a class="header" href="#networking-protocol">Networking Protocol</a></h1>
<h3 id="1-protocol-overview-and-motivation"><a class="header" href="#1-protocol-overview-and-motivation">1. Protocol Overview and Motivation</a></h3>
<p>The Nectar networking protocol is designed to be performant, reliable, private, and peer-to-peer, while still enabling access for nodes without a static public IP address.</p>
<p>The networking protocol is NOT designed to be all-encompassing, that is, the only way that two Nectar nodes will ever communicate.
Many Nectar runtimes will provide userspace access to HTTP server/client capabilities, TCP sockets, and much more.
Some applications will choose to use such facilities to communicate.
This networking protocol is merely a common language that every Nectar node is guaranteed to speak.
For this reason, it is the protocol on which system processes will communicate, and it will be a reasonable default for most applications.</p>
<p>In order for nodes to attest to their identity without any central authority, all networking information is made available onchain.
Networking information can take two forms: direct or routed.
The former allows for completely direct peer-to-peer connections, and the latter allows nodes without a physical network configuration that permits direct connections to route messages through a peer.</p>
<p>The networking protocol can and will be implemented in multiple underlying protocols.
Since the protocol is encrypted, a secure underlying connection with TLS or HTTPS is never necessary.
WebSockets are prioritized since we expect to quickly build Nectar nodes that run purely in-browser.
The other transmission protocols with slots in the onchain identity data structure are: TCP, UDP, and WebTransport.</p>
<h3 id="2-onchain-networking-information"><a class="header" href="#2-onchain-networking-information">2. Onchain Networking Information</a></h3>
<p>All nodes must publish an Ed25519 EdDSA networking public key onchain using the protocol registry contract.
A new key transaction may be posted at any time, but because agreement on networking keys is required to establish a connection and send messages between nodes, changes to onchain networking information will temporarily disrupt networking.
Therefore, all nodes must have robust access to the onchain PKI, meaning: multiple backup options and multiple pathways to read onchain data.
Because it may take time for a new networking key to proliferate to all nodes, (anywhere from seconds to days depending on chain indexing access) a node that changes its networking key should expect downtime immediately after doing so.</p>
<p>Nodes that wish to make direct connections must post an IP and port onchain.The registry contract has one IP slot per node, which the owner address of a node can update at will.
The contract has four port slots, one each for WebSockets (<code>ws</code>), TCP, UDP, and WebTransport (<code>wt</code>).
Each port slot can be updated individually by the owner address of a node.
Indirect nodes must leave these slots blank, and instead fill out a <code>routing</code> field, which contains a list of nodes that are allowed and expected to route messages to them.</p>
<p>Nodes with onchain networking information (an IP address and at least one port) will be referred to as <strong>direct</strong> nodes, and ones without will be referred to as <strong>indirect</strong> nodes.</p>
<p>If a node is indirect, it must initiate a connection with at least one of its allowed routers in order to begin networking.
Until such a connection is successfully established, the indirect node is offline.
In practice, an indirect node that wants reliable access to the network should (1) have many routers listed onchain and (2) connect to as many of them as possible on startup.
In order to acquire such routers in practice, a node will likely need to provide some payment or service to them.</p>
<h3 id="3-websockets-protocol"><a class="header" href="#3-websockets-protocol">3. WebSockets protocol</a></h3>
<p>Currently, only the WebSockets protocol is implemented.
In the future, the <code>net:distro:sys</code> runtime module will be responsible for implementing the networking protocol on top of the other transport protocols declared onchain.
The runtime will also be responsible for choosing the optimal way to serve a given message based on the recipient's onchain networking information.
Each protocol may have different precise semantics depending on the underlying transport protocol: the following is a general description of the WebSockets protocol.</p>
<p>This protocol does not make use of any WebSocket frames other than Binary, Ping, and Pong.
Pings should be responded to with a Pong.
These are only used to keep the connection alive.
All content is sent as Binary frames.
Binary frames in the current protocol version (1) are limited to 10MB. This includes the full serialized <code>KernelMessage</code>.</p>
<p>All data structures are serialized and deserialized using <a href="https://msgpack.org/index.html">MessagePack</a>.</p>
<h4 id="31-data-structures"><a class="header" href="#31-data-structures">3.1. Data Structures</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HandshakePayload {
    pub protocol_version: u8,
    pub name: String,
    pub signature: Vec&lt;u8&gt;,
    pub proxy_request: bool,
}

struct RoutingRequest {
    pub protocol_version: u8,
    pub source: String,
    pub signature: Vec&lt;u8&gt;,
    pub target: String,
}

/// TODO indicate where to find Address, Rsvp, Message, and LazyLoadBlob type definitions
struct KernelMessage {
    pub id: u64,
    pub source: Address,
    pub target: Address,
    pub rsvp: Rsvp,
    pub message: Message,
    pub lazy_load_blob: Option&lt;LazyLoadBlob&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="32-establishing-a-connection"><a class="header" href="#32-establishing-a-connection">3.2. Establishing a Connection</a></h4>
<p>The WebSockets protocol uses the <a href="http://www.noiseprotocol.org/noise.html">Noise Protocol Framework</a> to encrypt all messages end-to-end.
The parameters used are <code>Noise_XX_25519_ChaChaPoly_BLAKE2s</code>.</p>
<p>Using the XX pattern means we follow this interactive pattern:</p>
<pre><code>  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se
</code></pre>
<p>The initiator is the node that is trying to establish a connection.</p>
<p><strong>If the target is direct</strong>, the intiator uses the IP and port provided onchain to establish a WebSocket connection.
If the connection fails, the target is considered offline.</p>
<p><strong>If the target is indirect</strong>, the initiator uses the IP and port of one of the target's routers to establish a WebSocket connection.
If a given router is unreachable, or fails to comport to the protocol, others should be tried until they are exhausted or too much time has passed (subject to the specific implementation).
If this process fails, the target is considered offline.</p>
<p><strong>If the target is indirect</strong>, before beginning the XX handshake pattern, the initiator sends a <code>RoutingRequest</code> to the target.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RoutingRequest {
    pub protocol_version: u8,
    pub source: String,
    pub signature: Vec&lt;u8&gt;,
    pub target: String,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>protocol_version</code> is the current protocol version, which is 1.
The <code>source</code> is the initiator's node ID, as provided onchain.
The <code>signature</code> must be created by the initiator's networking public key. The content is the routing target's node ID (i.e., the node which the initiator would like to establish an e2e encrypted connection with) concatenated with the router's node ID (i.e., the node which the initiator is sending the <code>RoutingRequest</code> to, which will serve as a router for the connection if it accepts).
The <code>target</code> is the routing target's node ID that must be signed above.</p>
<p>Once a connection is established, the initiator sends an <code>e</code> message, containing an empty payload.</p>
<p>The target responds with the <code>e, ee, s, es</code> pattern, including a <code>HandshakePayload</code> serialized with MessagePack.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HandshakePayload {
    pub protocol_version: u8,
    pub name: String,
    pub signature: Vec&lt;u8, Global&gt;,
    pub proxy_request: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>The current <code>protocol_version</code> is 1.
The <code>name</code> is the name of the node, as provided onchain.
The <code>signature</code> must be created by the node's networking public key, visible onchain.
The content is the public key they will use to encrypt messages on this connection.
How often this key changes is implementation-specific but should be frequent.
The <code>proxy_request</code> is a boolean indicating whether the initiator is asking for routing service to another node.</p>
<p>As the target, or receiver of the new connection, <code>proxy_request</code> will always be false. This field is only used by the initiator.</p>
<p>Finally, the initiator responds with the <code>s, se</code> pattern, including a <code>HandshakePayload</code> of their own.</p>
<p>After this pattern is complete, the connection switches to transport mode and can be used to send and receive messages.</p>
<h4 id="32-sending-messages"><a class="header" href="#32-sending-messages">3.2. Sending Messages</a></h4>
<p>Every message sent over the connection is a <code>KernelMessage</code>, serialized with MessagePack, then encrypted using the keys exchanged in the Noise protocol XX pattern, sent in a single Binary WebSockets message.</p>
<h4 id="33-receiving-messages"><a class="header" href="#33-receiving-messages">3.3. Receiving Messages</a></h4>
<p>When listening for messages, the protocol may ignore messages other than Binary, but should also respond to Ping messages with Pongs.</p>
<p>When a Binary message is received, it should first be decrypted using the keys exchanged in the handshake exchange, then deserialized as a <code>KernelMessage</code>. If this fails, the message should be ignored and the connection must be closed.</p>
<p>Successfully decrypted and deserialized messages should have their <code>source</code> field checked for the correct node ID and then passed to the kernel.</p>
<h4 id="34-closing-a-connection"><a class="header" href="#34-closing-a-connection">3.4. Closing a Connection</a></h4>
<p>All connection errors must result in closing a connection.</p>
<p>Failure to send a message must be treated as a connection error.</p>
<p>Failure to decrypt or deserialize a message must be treated as a connection error.</p>
<p>If a <code>KernelMessage</code>'s source is not the node ID which the message recipient is expecting, it must be treated as a connection error.</p>
<p>These behaviors are necessary since they indicate that the networking information of a counterparty may have changed and a new connection must be established using the new data onchain.</p>
<p>Connections may be closed due to inactivity or load-balancing. This behavior is implementation-specific.</p>
<h3 id="4-connection-maintenance-and-errors"><a class="header" href="#4-connection-maintenance-and-errors">4. Connection Maintenance and Errors</a></h3>
<p>The system's networking module seeks to abstract away the many complexities of p2p networking from app developers.
To this end, it reduces all networking issues to either Offline or Timeout.</p>
<p>Messages do not have to expect a response.
If no response is expected, a networking-level offline or timeout error may still be thrown.
Local messages will only receive timeout errors if they expect a response.</p>
<p>If a peer is direct, i.e. they have networking information published onchain, determining their offline status is simple: try to create a connection and send a message; it will throw an offline error if this message fails. If a message is not responded to before the timeout counter expires, it will throw a timeout.</p>
<p>If a peer is indirect, i.e. they have routers, multiple attempts must be made before either an offline error is thrown.
The specific implementation of the protocol may vary in this regard (e.g. it may try to connect to all routers, or limit the number of attempts to a subset of routers).
As with direct peers, if a message is not responded to before the timeout counter expires, it will throw a timeout.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-key-infrastructure"><a class="header" href="#public-key-infrastructure">Public Key Infrastructure</a></h1>
<p>The following is a high level overview of Nectar's public key infrastructure, the Nectar Identity System, or NDNS.
You can find a more general discussion of the Nectar <a href="./identity_system.html">identity system</a> here.</p>
<h2 id="identity-registration"><a class="header" href="#identity-registration">Identity Registration</a></h2>
<p>The NDNS Registry and Resolver are coupled in the same contract, the <code>NDNSRegistryResolver</code>.
This contract issues nodes on the NDNS network and records the data necessary for a node to interact with other nodes.</p>
<p>At a high level, the PKI depends on two elements: public keys and networking information.</p>
<ol>
<li>The networking public key is used to encrypt and decrypt communications with other nodes.
When nodes first connect, they engage in an initial handshake ceremony (TODO: describe) to create an encryption channel using both of their public keys.
It is this credential that verifies the identity of each nodes.</li>
<li>Networking information depends on whether a node is direct or routed (for more, see <a href="./networking_protocol.html">networking protocol</a>).</li>
</ol>
<p>Direct nodes send and receive networking traffic directly to and from all nodes on the network. In doing so they must provide their IP address and one or more of:</p>
<ul>
<li>WebSockets port</li>
<li>WebTransport port</li>
<li>TCP port</li>
<li>UDP port</li>
</ul>
<p>Indirect nodes instead specify one or more &quot;router&quot; nodes.
These router nodes communicate between indirect nodes and the network at large.</p>
<h2 id="name-registration"><a class="header" href="#name-registration">Name Registration</a></h2>
<p>The <code>DotNecRegistrar</code> (AKA <code>.nec</code>) is responsible for registering all <code>.nec</code> domain names.
It is also responsible for authorizing alterations to <code>.nec</code> node records managed by the NDNSRegistryResolver. (Todo: just confused by this)
<code>DotNecRegistrar</code> implements ERC721 tokenization logic for the names it is charged with, so all <code>.nec</code> names are NFTs that may be transferred to and from any address.
There is currently a minimum length of 9 characters for Nectar IDs.</p>
<p><code>DotNecRegistrar</code> allows users to create subdomains underneath any <code>.nec</code> name they own.
Initially this grants them control over the subdomain, as a holder of the parent domain, but they may choose to irreversibly revoke this control if they desire to.
This applies at each level of subdomain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server--client"><a class="header" href="#http-server--client">HTTP Server &amp; Client</a></h1>
<p>No server or web services backend would be complete without an HTTP interface.
Nectar nodes must be able to both create and serve HTTP requests.
This enables Nectar apps to read data from the web (and other Nectar nodes), and also serve both public and private websites and APIs.
The HTTP server is how most processes in the NectarOS present their interface to the user, through an authenticated web browser.</p>
<p>The specification for the <a href="./apis/http_server.html">server</a> and <a href="./apis/http_client.html">client</a> APIs are available in the API reference.
These APIs are accessible via messaging the <code>http_server:sys:nectar</code> and <code>http_client:sys:nectar</code> runtime extensions, respectively.
The only <a href="./process-capabilities.html">capability</a> required to use either process is the one to message it, granted by the kernel.</p>
<p>WebSocket server/client functionality is presented alongside HTTP.</p>
<p>At startup, the server task finds an open port, starting its search at 8080, to bind at and listen for HTTP and WebSocket requests.
All server functionality can be either authenticated or public.
If a given functionality is public, it is presented open to the world.
Note that the configuration of the Nectar node will still determine whether it is accessible over IPv4/IPv6 – NectarOS does also not provide any DNS management for nodes.
Since direct nodes are expected to be accessible over IP, their HTTP server is likely to work, if the bound port is accessible.
However, indirect nodes are not expected to be accessible over IP, so in the near future, the HTTP server will include a proxying feature to allow indirect nodes to serve HTTP requests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="files"><a class="header" href="#files">Files</a></h1>
<h2 id="virtual-file-system-vfs"><a class="header" href="#virtual-file-system-vfs">Virtual File System (VFS)</a></h2>
<p>The primary way to access files within your node is through the <a href="./apis/vfs.html">VFS API</a>.
The VFS API follows std::fs closely, adding some capabilities checks on paths and some combinatory actions.</p>
<p>VFS files exist in the &quot;/vfs&quot; folder within your home node, and files are grouped by <code>package_id</code>.
For example, part of the VFS might look like:</p>
<pre><code class="language-text">.
├── app_store:nectar
│   └── pkg
│       ├── app_store.wasm
│       ├── ft_worker.wasm
│       ├── manifest.json
│       └── metadata.json
├── chess:nectar
│   └── pkg
│       ├── chess.html
│       ├── chess.wasm
│       ├── index.css
│       ├── index.js
│       ├── manifest.json
│       └── metadata.json
├── homepage:nectar
│   └── pkg
│       ├── homepage.wasm
│       ├── manifest.json
│       └── metadata.json
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To access files in the vfs, you need to create or open a drive, this can be done with the function <code>create_drive</code> from the <a href="./process_stdlib/overview.html">standard library</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let drive_path: String = create_drive(our.package_id(), &quot;drive_name&quot;)?;

let test_file = create_file(&amp;format(&quot;{}/test.txt&quot;, &amp;drive_path))?;

let text = b&quot;hello world!&quot;
file.write(&amp;text);
<span class="boring">}</span></code></pre></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="./apis/vfs.html">VFS API</a></li>
<li><a href="https://doc.rust-lang.org/std/fs/index.html">std::fs API</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="databases"><a class="header" href="#databases">Databases</a></h1>
<p>The runtime currently comes preloaded with 2 databases, a key value (RocksDB) and sqlite.</p>
<p>These can be created, accessed, and shared amongst processes.
The APIs for doing so you can find here: <a href="./apis/kv.html">KV</a> and <a href="./apis/sqlite.html">SQLite</a>.</p>
<p>Similarly to files in the VFS, they are accessed by <code>package_id</code> and a <code>db</code> name.
Capabilities to read and write can be shared with other processes; processes within a given package have access by default.</p>
<p>All examples are using the <a href="https://github.com/uqbar-dao/process_lib">nectar_process_lib</a> functions.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h4 id="kv"><a class="header" href="#kv">KV</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// opens or creates a kv db named birthdays in our package.
let kv = kv::open(our.package_id(), &quot;birthdays&quot;)?;

kv.set(b&quot;tacitus&quot;.to_vec(), b&quot;53 CE&quot;.to_vec(), None)?;

let bday = kv.get(b&quot;tacitus&quot;.to_vec())?;

println!(&quot;got a bday: {}&quot;, String::from_utf8(bday)?);
<span class="boring">}</span></code></pre></pre>
<h4 id="sqlite"><a class="header" href="#sqlite">SQLite</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// opens or creates sqlite db named users in our package.
let db = sqlite::open(our.package_id(), &quot;users&quot;)?;

let create_table_statement =
    &quot;CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL);&quot;.to_string();

db.write(create_table_statement, vec![], None)?;

let insert_statement = &quot;INSERT INTO users (name) VALUES (?), (?), (?);&quot;.to_string();
let params = vec![
    serde_json::Value::String(&quot;Bob&quot;.to_string()),
    serde_json::Value::String(&quot;Charlie&quot;.to_string()),
    serde_json::Value::String(&quot;Dave&quot;.to_string()),
];

sqlite.write(insert_statement, params, None)?;

let select_statement = &quot;SELECT * FROM users;&quot;.to_string();
let rows = sqlite.read(select_statement, vec![])?;
// rows: Vec&lt;HashMap&lt;String, serde_json::Value&gt;&gt;
println!(&quot;rows: {}&quot;, rows.len());
<span class="boring">}</span></code></pre></pre>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="./apis/kv.html">KV API</a></li>
<li><a href="./apis/sqlite.html">SQLite API</a></li>
<li><a href="https://github.com/rust-rocksdb/rust-rocksdb">RocksDB</a></li>
<li><a href="https://www.sqlite.org/docs.html">SQLite</a></li>
<li><a href="https://github.com/uqbar-dao/process_lib">nectar_process_lib</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>The <a href="https://github.com/uqbar-dao/process_lib">process standard library</a> is the easiest way to write Rust apps on NectarOS.</p>
<p>Since Nectar apps use the <a href="https://component-model.bytecodealliance.org/">WebAssembly Component Model</a>, they are built on top of a WIT (Wasm Interface Type) package.
This interface contains the core types and functions that are available to all Nectar apps, and these are automatically generated in Rust when building a Wasm app.
However, the types themselves are unwieldy to use directly, and runtime modules present APIs that can be drastically simplified by using helper functions and types in the process standard library.</p>
<p>[link to the crate]</p>
<p>[link to the crate-docs]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-build-and-deploy-an-app"><a class="header" href="#tutorial-build-and-deploy-an-app">Tutorial: Build and Deploy an App</a></h1>
<p>Welcome!
In these tutorials, you'll setup your development environment and learn about the <code>kit</code> tools.
You'll learn about templates and also walk through writing an application from the group up, backend and frontend.
And finally, you'll learn how to deploy applications through the Nectar app store.</p>
<p>For the purposes of this documentation, terminal commands are provided as-is for ease of copying EXCEPT when the output of the command is also shown.
In that case, the command is prepended with a <code>$ </code> to distinguish the command from the output.
The <code>$ </code> should not be copied into the terminal.</p>
<h1 id="environment-setup"><a class="header" href="#environment-setup">Environment Setup</a></h1>
<p>In this chapter, you'll walk through setting up an Nectar development environment.
By the end, you will have created an Nectar application, or package, composed of one or more processes that run on a live Nectar node.
The application will be a simple chat interface: <code>my_chat_app</code>.</p>
<p>The following assumes a Unix environment — macOS or Linux.
If on Windows, <a href="https://learn.microsoft.com/en-us/windows/wsl/install">get WSL</a> first.
In general, NectarOS does not support Windows.</p>
<h2 id="acquiring-rust-and-the-nectar-development-tools-kit"><a class="header" href="#acquiring-rust-and-the-nectar-development-tools-kit">Acquiring Rust and the Nectar Development Tools (<code>kit</code>)</a></h2>
<p>Install Rust and the Nectar Development Tools, or <code>kit</code>:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
cargo install --git https://github.com/uqbar-dao/kit
</code></pre>
<h2 id="creating-a-new-nectar-package-template"><a class="header" href="#creating-a-new-nectar-package-template">Creating a New Nectar Package Template</a></h2>
<p>The <code>kit</code> toolkit has a <a href="https://github.com/uqbar-dao/kit">variety of features</a>.
One of those tools is <code>new</code>, which creates a template for an Nectar package.
The <code>new</code> tool takes two arguments: a path to create the template directory and a name for the package:</p>
<pre><code>$ kit new --help
Create a Nectar template package

Usage: kit new [OPTIONS] &lt;DIR&gt;

Arguments:
  &lt;DIR&gt;  Path to create template directory at

Options:
  -a, --package &lt;PACKAGE&gt;      Name of the package [default: DIR]
  -u, --publisher &lt;PUBLISHER&gt;  Name of the publisher [default: template.nec]
  -l, --language &lt;LANGUAGE&gt;    Programming language of the template [default: rust] [possible values: rust, python, javascript]
  -t, --template &lt;TEMPLATE&gt;    Template to create [default: chat] [possible values: chat, fibonacci]
      --ui                     If set, use the template with UI
  -h, --help                   Print help
</code></pre>
<p>Create a package <code>my_chat_app</code>:</p>
<pre><code class="language-bash">kit new my_chat_app
</code></pre>
<h2 id="exploring-the-package"><a class="header" href="#exploring-the-package">Exploring the Package</a></h2>
<p>Nectar packages are sets of one or more Nectar <a href="my_first_app/../processes.html">processes</a>.
An Nectar package is represented in Unix as a directory that has a <code>pkg/</code> directory within.
Each process within the package is its own directory.
By default, the <code>kit new</code> command creates a simple, one-process package, a chat app.
Other templates, including a Python template and a UI-enabled template can be used by passing different flags to <code>kit new</code> (see <code>kit new --help</code>).
The default template looks like:</p>
<pre><code class="language-bash">$ tree my_chat_app
my_chat_app
├── my_chat_app
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
└── pkg
    ├── manifest.json
    └── metadata.json

3 directories, 4 files
</code></pre>
<p>The <code>my_chat_app/</code> package here contains one process, also named <code>my_chat_app/</code>.
The process directory contains source files and other metadata for compiling that process.</p>
<p>In Rust processes, the standard Rust <code>Cargo.toml</code> file is included: it specifies dependencies.
It is exhaustively defined <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">here</a>.
The <code>src/</code> directory is where the code for the process lives.</p>
<p>Also within the package directory is a <code>pkg/</code> directory.
The <code>pkg/</code> directory contains two files, <code>manifest.json</code> and <code>metadata.json</code>, that specify information the Nectar node needs to run the package, which will be enumerated below.
The <code>pkg/</code> directory is also where <code>.wasm</code> binaries will be deposited by <a href="my_first_app/chapter_1.html#building-the-package"><code>kit build</code></a>.
The files in the <code>pkg/</code> directory contents are injected into the Nectar node with <a href="my_first_app/chapter_1.html#starting-the-package"><code>kit start-package</code></a>.</p>
<p>Though not included in this template, packages with a frontend have a <code>ui/</code> directory as well.
For an example, look at the result of:</p>
<pre><code class="language-bash">kit new my_chat_app_with_ui --ui
tree my_chat_app_with_ui
</code></pre>
<p>Note that not all templates have a UI-enabled version.
As of 240111, only the Rust chat template has a UI-enabled version.</p>
<h3 id="pkgmanifestjson"><a class="header" href="#pkgmanifestjson"><code>pkg/manifest.json</code></a></h3>
<p>The <code>manifest.json</code> file contains information the Nectar node needs in order to run the package:</p>
<pre><code class="language-bash">$ cat my_chat_app/pkg/manifest.json
[
    {
        &quot;process_name&quot;: &quot;my_chat_app&quot;,
        &quot;process_wasm_path&quot;: &quot;/my_chat_app.wasm&quot;,
        &quot;on_exit&quot;: &quot;Restart&quot;,
        &quot;request_networking&quot;: true,
        &quot;request_capabilities&quot;: [
            &quot;net:sys:nectar&quot;
        ],
        &quot;grant_capabilities&quot;: [],
        &quot;public&quot;: true
    }
]
</code></pre>
<p>This is a JSON array of JSON objects.
Each object represents one process that will be started when the package is installed.
A package with multiple processes need not start them all at install time.
A package may start more than one of the same process, as long as they each have a unique <code>process_name</code>.</p>
<p>Each object has the following fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Required?</th><th>Value type</th></tr></thead><tbody>
<tr><td><code>&quot;process_name&quot;</code></td><td>Yes</td><td>string</td></tr>
<tr><td><code>&quot;process_wasm_path&quot;</code></td><td>Yes</td><td>string (representing a path)</td></tr>
<tr><td><code>&quot;on_exit&quot;</code></td><td>Yes</td><td>string (<code>&quot;None&quot;</code> or <code>&quot;Restart&quot;</code>) or object (covered <a href="my_first_app/./chapter_2.html#aside-on_exit">elsewhere</a>)</td></tr>
<tr><td><code>&quot;request_networking&quot;</code></td><td>Yes</td><td>bool</td></tr>
<tr><td><code>&quot;request_capabilities&quot;</code></td><td>No</td><td>array of strings to note process names, or objects to note custom capabilities and from what process to request them</td></tr>
<tr><td><code>&quot;grant_capabilities&quot;</code></td><td>No</td><td>array of strings to note process names, or objects to note custom capabilities to generate and send to a process</td></tr>
<tr><td><code>&quot;public&quot;</code></td><td>Yes</td><td>bool</td></tr>
</tbody></table>
</div>
<h3 id="pkgmetadatajson"><a class="header" href="#pkgmetadatajson"><code>pkg/metadata.json</code></a></h3>
<p>The <code>metadata.json</code> file contains information about the package and the publisher:</p>
<pre><code class="language-bash">$ cat my_chat_app/pkg/metadata.json
{
    &quot;package&quot;: &quot;my_chat_app&quot;,
    &quot;publisher&quot;: &quot;template.nec&quot;,
    &quot;version&quot;: [0, 1, 0]
}
</code></pre>
<p>Here, the <code>publisher</code> is some default value, but for a real package, this field should contain the NDNS id of the publishing node.
The <code>publisher</code> can also be set with a <code>kit new --publisher</code> flag.</p>
<h3 id="srclibrs"><a class="header" href="#srclibrs"><code>src/lib.rs</code></a></h3>
<p>TODO</p>
<h2 id="building-the-package"><a class="header" href="#building-the-package">Building the Package</a></h2>
<p>To build the package, use the <code>kit build</code> tool.</p>
<p>This tool accepts an optional directory path as the first argument, or, if none is provided, attempts to build the current working directory.
As such, either of the following will work:</p>
<pre><code class="language-bash">kit build my_chat_app
</code></pre>
<p>or</p>
<pre><code class="language-bash">cd my_chat_app
kit build
</code></pre>
<h2 id="booting-a-fake-nectar-node"><a class="header" href="#booting-a-fake-nectar-node">Booting a Fake Nectar Node</a></h2>
<p>Often, it is optimal to develop on a fake node.
Fake nodes are simple to set up, easy to restart if broken, and mocked networking makes development testing very straightforward.
To boot a fake Nectar node for development purposes, use the <code>kit boot-fake-node</code> tool.</p>
<p><code>kit boot-fake-node</code> downloads the OS- and architecture-appropriate Nectar core binary and runs it without connecting to the live network.
Instead, it connects to a mocked local network, allowing different fake nodes on the same machine to communicate with each other.
<code>kit boot-fake-node</code> has many optional configuration flags, but the defaults should work fine:</p>
<pre><code class="language-bash">kit boot-fake-node
</code></pre>
<p>The fake node, just like a real node, will accept inputs from the terminal.
To exit from the fake node, press <code>Ctrl + C</code>.</p>
<p>By default, the fake node will bind to port <code>8080</code>.
Note the port number in the output for <a href="my_first_app/chapter_1.html#starting-the-package">later</a>; it will look something like:</p>
<pre><code class="language-bash">Fri 12/8 15:43 http_server: running on port 8080
</code></pre>
<p><code>kit boot-fake-node</code> also accepts a <code>--runtime-path</code> argument.
When supplied, if it is a path to the Nectar core repo, it will compile and use that binary to start the node.
Or, if it is a path to an Nectar binary, it will use that binary to start the node.
For example:</p>
<pre><code class="language-bash">kit boot-fake-node --runtime-path ~/path/to/nectar
</code></pre>
<p>where <code>~/path/to/nectar</code> must be replaced with a path to the Nectar core repo or an Nectar binary.</p>
<h2 id="optional-starting-a-real-nectar-node"><a class="header" href="#optional-starting-a-real-nectar-node">Optional: Starting a Real Nectar Node</a></h2>
<p>Alternatively, development sometimes calls for a real node, which has access to the actual Nectar network and its providers, such as integrated LLMs.</p>
<p>To develop on a real Nectar node, connect to the network and follow the instructions to <a href="my_first_app/../install.html">setup an Nectar node</a>.</p>
<h2 id="starting-the-package"><a class="header" href="#starting-the-package">Starting the Package</a></h2>
<p>Time to load and initiate the <code>my_chat_app</code> package. For this, you will use the <code>kit start-package</code> tool.
Like <a href="my_first_app/chapter_1.html#building-the-package"><code>kit build</code></a>, the <code>kit start-package</code> tool receives an optional directory containing the package or, if no directory is received, tries the current working directory.
It also requires a URL: the address of the node on which to initiate the package.
The node's URL can be input in one of two ways:</p>
<ol>
<li>If running on localhost, the port can be supplied with <code>-p</code> or <code>--port</code>,</li>
<li>More generally, the node's entire URL can be supplied with a <code>-u</code> or <code>--url</code> flag.</li>
</ol>
<p>You can start the package from either within or outside <code>my_chat_app</code> directory.
After completing the previous step, you should be one directory above the <code>my_chat_app</code> directory and can use the following:</p>
<pre><code class="language-bash">kit start-package my_chat_app -p 8080
</code></pre>
<p>or, if you are already in the correct package directory:</p>
<pre><code class="language-bash">kit start-package -p 8080
</code></pre>
<p>where here the port provided following <code>-p</code> must match the port bound by the node or fake node (see discussion <a href="my_first_app/chapter_1.html#booting-a-fake-nectar-node">above</a>).</p>
<p>The node's terminal should display something like</p>
<pre><code>Fri 12/8 15:54 my_chat_app: begin
</code></pre>
<p>Congratulations on completing the first steps towards developing applications on Nectar!</p>
<h2 id="using-the-package"><a class="header" href="#using-the-package">Using the Package</a></h2>
<p>To test out the functionality of <code>my_chat_app</code>, spin up another fake node to chat with in a new terminal:</p>
<pre><code class="language-bash">kit boot-fake-node -h /tmp/nectar-fake-node-2 -p 8081 -f fake2.nec
</code></pre>
<p>The fake nodes communicate over a mocked local network.</p>
<p>To start the same <code>my_chat_app</code> on the second fake node, again note the port, and supply it with a <code>start-package</code>:</p>
<pre><code class="language-bash">kit start-package my_chat_app -p 8081
</code></pre>
<p>or, if already in the <code>my_chat_app/</code> package directory:</p>
<pre><code class="language-bash">kit start-package -p 8081
</code></pre>
<p>To send a chat message from the first node, run the following in its terminal:</p>
<pre><code>/m our@my_chat_app:my_chat_app:template.nec {&quot;Send&quot;: {&quot;target&quot;: &quot;fake2.nec&quot;, &quot;message&quot;: &quot;hello world&quot;}}
</code></pre>
<p>and replying, from the other terminal:</p>
<pre><code>/m our@my_chat_app:my_chat_app:template.nec {&quot;Send&quot;: {&quot;target&quot;: &quot;fake.nec&quot;, &quot;message&quot;: &quot;wow, it works!&quot;}}
</code></pre>
<p>Messages can also be injected from the outside.
From a bash terminal, use <code>uqdev inject-message</code>, like so:</p>
<pre><code class="language-bash">kit inject-message my_chat_app:my_chat_app:template.nec '{&quot;Send&quot;: {&quot;target&quot;: &quot;fake2.nec&quot;, &quot;message&quot;: &quot;hello from the outside world&quot;}}'
kit inject-message my_chat_app:my_chat_app:template.nec '{&quot;Send&quot;: {&quot;target&quot;: &quot;fake.nec&quot;, &quot;message&quot;: &quot;replying from fake2.nec using first method...&quot;}}' --node fake2.nec
kit inject-message my_chat_app:my_chat_app:template.nec '{&quot;Send&quot;: {&quot;target&quot;: &quot;fake.nec&quot;, &quot;message&quot;: &quot;and second!&quot;}}' -p 8081
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sending-some-messages-using-some-tools"><a class="header" href="#sending-some-messages-using-some-tools">Sending Some Messages, Using Some Tools</a></h1>
<p>This chapter assumes you've completed the steps outlined in <a href="my_first_app/./chapter_1.html">Chapter 1</a> to construct your dev environment or otherwise have a basic Nectar app open in your code editor of choice.
You should also be actively running an Nectar node (<a href="my_first_app/../login.html">live</a> or <a href="my_first_app/./chapter_1.html#booting-a-fake-nectar-node">fake</a>) such that you can quickly compile and test your code!
Tight feedback loops when building: very important.</p>
<h2 id="starting-from-scratch"><a class="header" href="#starting-from-scratch">Starting from Scratch</a></h2>
<p>If you want to hit the ground running, you can take the template code or the <a href="my_first_app/../chess_app/start.html">chess tutorial</a> and start hacking away.
Here, you'll start from scratch and learn about every line of boilerplate.</p>
<p>The last chapter explained packages, the package manifest, and metadata.
Every package contains one or more processes, which are the actual Wasm programs that will run on a node.
In order to compile properly to the Nectar environment, every process must generate the WIT bindings for the <code>process</code> &quot;world&quot;.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});
<span class="boring">}</span></code></pre></pre>
<p>After generating the bindings, every process must define a <code>Component</code> struct and implement the <code>Guest</code> trait for it defining a single function, <code>init()</code>.
This is the entry point for the process, and the <code>init()</code> function is the first function called by the Nectar runtime when the process is started.</p>
<p>The definition of the <code>Component</code> struct can be done manually, but it's easier to import the <a href="my_first_app/../process_stdlib/overview.html"><code>nectar_process_lib</code></a> crate (a sort of standard library for Nectar processes written in Rust) and use the <code>call_init!</code> macro.
Note that running the process below <a href="my_first_app/chapter_2.html#aside-on_exit">can lead to an infinite loop</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::{call_init, Address};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

call_init!(my_init_fn);

fn my_init_fn(our: Address) {
    println!(&quot;{our}: started&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Every Nectar process written in Rust will need code that does the same thing as the above.
The <code>Address</code> parameter tells our process what its globally-unique name is. (TODO: link to docs)</p>
<p>Let's fill out the init function with code that will stop it from exiting immediately.
Here's an infinite loop that will wait for a message and then print it out.
Note that you are importing a few more things from the <a href="my_first_app/../process_stdlib/overview.html">process_lib</a> including a <code>println!</code> macro that replaces the standard Rust one.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::{await_message, call_init, println, Address};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

call_init!(my_init_fn);

fn my_init_fn(our: Address) {
    println!(&quot;{our}: started&quot;);

    loop {
        let next_message = await_message();
        println!(&quot;{our}: got message: {next_message:?}&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="my_first_app/./apis/nectar_wit.html">nectar.wit</a> for more details on what is imported by the WIT bindgen macro.
These imports are the necessary &quot;system calls&quot; for talking to other processes and runtime components in NectarOS.</p>
<p>Run</p>
<pre><code class="language-bash">kit build your_pkg_name
kit start-package your_pkg_name -p 8080
</code></pre>
<p>to see this code in the node you set up in the last chapter.</p>
<h2 id="sending-a-message"><a class="header" href="#sending-a-message">Sending a Message</a></h2>
<p>Let's send a message to another process.
The <code>Request</code> type in <a href="my_first_app/../process_stdlib/overview.html">process_lib</a> will provide all the necessary functionality.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::{await_message, call_init, println, Address, Request};
<span class="boring">}</span></code></pre></pre>
<p><code>Request</code> is a builder struct that abstracts over the raw interface presented in the WIT bindings.
It's very simple to use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Request::new()
    .target(my_target_address)
    .body(my_body_bytes)
    .send();
<span class="boring">}</span></code></pre></pre>
<p>Because this process might not have capabilities to message any other (local or remote) processes, just send the message to itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Request::new()
    .target(our)
    .body(b&quot;hello world&quot;)
    .send();
<span class="boring">}</span></code></pre></pre>
<p>Note that <code>send()</code> returns a Result.
If you know that a <code>target</code> and <code>body</code> was set, you can safely unwrap this: send will only fail if one of those two fields are missing.</p>
<p>Here's the full process code, with both sending and handling the message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::{await_message, call_init, println, Address, Request};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

call_init!(my_init_fn);

fn my_init_fn(our: Address) {
    println!(&quot;{our}: started&quot;);

    Request::new()
        .target(&amp;our)
        .body(b&quot;hello world&quot;)
        .send()
        .unwrap();

    loop {
        let next_message = await_message();
        println!(&quot;{our}: got message: {next_message:?}&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Using <code>kit build</code> and <code>kit start-package</code> like before, you should be able to see in your node's terminal the message being received in the loop.
However, you'll see the &quot;hello world&quot; message as a byte vector.</p>
<p>Let's modify our request to expect a response, and our message-handling to send one back, as well as parse the received request into a string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Request::to(&amp;our)
    .body(b&quot;hello world&quot;)
    .expects_response(5)
    .send()
<span class="boring">}</span></code></pre></pre>
<p>The <code>expects_response</code> method takes a timeout in seconds.
If the timeout is reached, the request will be returned to the process that sent it as an error.
If you add that to the code above, you'll see the error after 5 seconds in your node's terminal.</p>
<p>Now, let's add some code to handle the request. The <code>await_message()</code> function returns a type that looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Result&lt;Message, SendError&gt;
<span class="boring">}</span></code></pre></pre>
<p>That <code>SendError</code> is what's coming when the request times out.
Let's add a <code>match</code> statement that first checks whether the incoming value is a message or an error, then see if the message is a request or a response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    match await_message() {
        Ok(message) =&gt; {
            if message.is_request() {
                println!(&quot;{our}: got request: {message:?}&quot;);
            } else {
                println!(&quot;{our}: got response: {message:?}&quot;);
            }
        }
        Err(_send_error) =&gt; {
            println!(&quot;got send error!&quot;);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This code won't send a response back yet.
To do that, import the <code>Response</code> type from <code>process_lib</code> and fire one off inside the request branch.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::{await_message, call_init, println, Address, Request, Response};
// ...
if message.is_request() {
    println!(&quot;{our}: got request: {message:?}&quot;);
    Response::new()
        .body(b&quot;hello world to you too!&quot;)
        .send()
        .unwrap();
}
// ...
<span class="boring">}</span></code></pre></pre>
<p>Building and starting the package now will show the request and response in the node's terminal.
But it's still ugly.
Let's put it all together and add a bit more handling to show the <code>body</code> value as a string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::{await_message, call_init, println, Address, Request, Response};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

call_init!(my_init_fn);

fn my_init_fn(our: Address) {
    println!(&quot;{our}: started&quot;);

    Request::new()
        .target(&amp;our)
        .body(b&quot;hello world&quot;)
        .expects_response(5)
        .send()
        .unwrap();

    loop {
        match await_message() {
            Ok(message) =&gt; {
                if message.is_request() {
                    println!(
                        &quot;{our}: got a message: {}&quot;,
                        String::from_utf8_lossy(message.body())
                    );
                    Response::new()
                        .body(b&quot;hello world to you too!&quot;)
                        .send()
                        .unwrap();
                } else {
                    println!(
                        &quot;{our}: got a response: {}&quot;,
                        String::from_utf8_lossy(message.body())
                    );
                }
            }
            Err(_send_error) =&gt; {
                println!(&quot;got send error!&quot;);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This basic structure can be found in the majority of Nectar processes.
The other common structure is a thread-like process, that sends and handles a fixed series of messages and then exits.</p>
<p>In the next chapter, we will cover how to turn this very basic request-response pattern into something that can be extensible and composable.</p>
<h2 id="aside-on_exit"><a class="header" href="#aside-on_exit">Aside: <code>on_exit</code></a></h2>
<p>As mentioned in the <a href="my_first_app/./chapter_1.html#pkgmanifestjson">previous chapter</a>, one of the fields in the <code>manifest.json</code> is <code>on_exit</code>.
When the process exits, it does one of:</p>
<div class="table-wrapper"><table><thead><tr><th><code>on_exit</code> setting</th><th>Behavior</th></tr></thead><tbody>
<tr><td><code>&quot;None&quot;</code></td><td>Do nothing</td></tr>
<tr><td><code>&quot;Restart&quot;</code></td><td>Restart the process</td></tr>
<tr><td>JSON object</td><td>Send the message described by the JSON object</td></tr>
</tbody></table>
</div>
<p>A process intended to do something once and exit should have <code>&quot;None&quot;</code> or a JSON object <code>on_exit</code>.
If it has <code>&quot;Restart&quot;</code>, it will repeat in an infinite loop, as reference <a href="my_first_app/chapter_2.html#starting-from-scratch">above</a>.</p>
<p>A process intended to run over a period of time and serve requests and responses will often have <code>&quot;Restart&quot;</code> <code>on_exit</code> so that, in case of crash, it will start again.
Alternatively, a JSON object <code>on_exit</code> can be used to inform another process of its untimely demise.
In this way, Nectar processes become quite similar to Erlang processes, and crashing can be <a href="https://ferd.ca/the-zen-of-erlang.html">designed into your process to increase reliability</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-your-protocol"><a class="header" href="#defining-your-protocol">Defining Your Protocol</a></h1>
<p>In the last chapter, you created a simple request-response pattern that uses strings as an <code>body</code> field type.
This is fine for certain limited cases, but in practice, most Nectar processes written in Rust use an <code>body</code> type that is serialized and deserialized to bytes using <a href="https://serde.rs/">Serde</a>.
There are a multitude of libraries that implement Serde's <code>Serialize</code> and <code>Deserialize</code> traits, and the process developer is responsible for selecting a strategy that is appropriate for their use case.</p>
<p>Some popular options are <code>bincode</code> and <code>serde_json</code>.
In this chapter, you will use <code>serde_json</code> to serialize your Rust structs to a byte vector of JSON.</p>
<p>Our old request looked like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Request::to(&amp;our)
    .body(b&quot;hello world&quot;)
    .expects_response(5)
    .send();
<span class="boring">}</span></code></pre></pre>
<p>What if you want to have two kinds of messages, which your process can handle differently?
Let's make a type that implements the <code>Serialize</code> and <code>Deserialize</code> traits, and use that as your <code>body</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Serialize, Deserialize};

// ...

#[derive(Serialize, Deserialize)]
enum MyBody {
    Hello(String),
    Goodbye,
}

impl MyBody {
    fn hello(text: &amp;str) -&gt; Vec&lt;u8&gt; {
        serde_json::to_vec(&amp;MyBody::Hello(text.to_string())).unwrap()
    }

    fn goodbye() -&gt; Vec&lt;u8&gt; {
        serde_json::to_vec(&amp;MyBody::Goodbye).unwrap()
    }

    fn parse(bytes: &amp;[u8]) -&gt; Result&lt;MyBody, serde_json::Error&gt; {
        serde_json::from_slice::&lt;MyBody&gt;(bytes)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now, when you form requests and response, instead of sticking a string in the <code>body</code> field, you can use the new <code>body</code> type.
This comes with a number of benefits:</p>
<ul>
<li>You can now use the <code>body</code> field to send arbitrary data, not just strings.</li>
<li>Other programmers can look at your code and see what kinds of messages this process might send to their code.</li>
<li>Other programmers can see what kinds of messages you expect to receive.</li>
<li>By using an <code>enum</code>, you can exhaustively handle all possible message types, and handle unexpected messages with a default case or an error.</li>
</ul>
<p>Defining <code>body</code> types is just one step towards writing interoperable code.
It's also critical to document the overall structure of the program along with message <code>blob</code>s and <code>metadata</code> used, if any.
Writing interoperable code is necessary for enabling permissionless composability, and NectarOS aims to make this the default kind of program, unlike the centralized web.</p>
<p>First, create a request that uses the new <code>body</code> type (and stop expecting a response):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Request::new()
    .target(&amp;our)
    .body(MyBody::hello(&quot;hello world&quot;))
    .send();
<span class="boring">}</span></code></pre></pre>
<p>Next, edit the way you handle a message in your process to use your new <code>body</code> type.
The process should attempt to parse every message into the <code>MyBody</code> enum, handle the two cases, and handle any message that doesn't comport to the type.
This code goes into the <code>Ok(message)</code> case of the <code>match</code> statement on <code>await_message()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Ok(body) = MyBody::parse(message.body()) else {
    println!(&quot;{our}: received a message with weird `body`!&quot;);
    continue;
};
if message.is_request() {
    // Respond to a Hello by printing it, and a Goodbye by exiting
    // the loop, which will cause the process to exit.
    match body {
        MyBody::Hello(text) =&gt; {
            println!(&quot;got a Hello: {text}&quot;);
        }
        MyBody::Goodbye =&gt; {
            println!(&quot;goodbye!&quot;);
            break;
        }
    }
} else {
    // we only expect Hello responses. If we get a Goodbye, ignore it.
    match body {
        MyBody::Hello(text) =&gt; {
            println!(&quot;got a Hello response: {text}&quot;);
        }
        MyBody::Goodbye =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, edit your <code>pkg/manifest.json</code> to grant the terminal process permission to send messages to this process.
That way, you can use the terminal to send Hello and Goodbye messages.
Go into the manifest, and under the process name, edit (or add) the <code>grant_capabilities</code> field like so:</p>
<pre><code class="language-json">...
&quot;grant_capabilities&quot;: [
    &quot;terminal:terminal:nectar&quot;
],
...
</code></pre>
<p>After all this, your code should look like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Serialize, Deserialize};
use nectar_process_lib::{await_message, call_init, println, Address, Request, Response};

#[derive(Serialize, Deserialize)]
enum MyBody {
    Hello(String),
    Goodbye,
}

impl MyBody {
    fn hello(text: &amp;str) -&gt; Vec&lt;u8&gt; {
        serde_json::to_vec(&amp;MyBody::Hello(text.to_string())).unwrap()
    }

    fn goodbye() -&gt; Vec&lt;u8&gt; {
        serde_json::to_vec(&amp;MyBody::Goodbye).unwrap()
    }

    fn parse(bytes: &amp;[u8]) -&gt; Result&lt;MyBody, serde_json::Error&gt; {
        serde_json::from_slice::&lt;MyBody&gt;(bytes)
    }
}

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

call_init!(my_init_fn);

fn my_init_fn(our: Address) {
    println!(&quot;{our}: started&quot;);

    Request::new()
        .target(&amp;our)
        .body(MyBody::hello(&quot;hello world&quot;))
        .send();

    loop {
        match await_message() {
            Ok(message) =&gt; {
                let Ok(body) = MyBody::parse(message.body()) else {
                    println!(&quot;{our}: received a message with weird `body`!&quot;);
                    continue;
                };
                if message.is_request() {
                    // Respond to a Hello by printing it, and a Goodbye by exiting
                    // the loop, which will cause the process to exit.
                    match body {
                        MyBody::Hello(text) =&gt; {
                            println!(&quot;got a Hello: {text}&quot;);
                        }
                        MyBody::Goodbye =&gt; {
                            println!(&quot;goodbye!&quot;);
                            break;
                        }
                    }
                } else {
                    // we only expect Hello responses. If we get a Goodbye, ignore it.
                    match body {
                        MyBody::Hello(text) =&gt; {
                            println!(&quot;got a Hello response: {text}&quot;);
                        }
                        MyBody::Goodbye =&gt; {}
                    }
                }
            }
            Err(_send_error) =&gt; {
                println!(&quot;got send error!&quot;);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You should be able to build and start your package, then see that initial Hello message.
At this point, you can use the terminal to test your message types!</p>
<p>First, try a hello. Get the address of your process by looking at the &quot;started&quot; printout that came from it in the terminal.
As a reminder, these values are set in the <code>metadata.json</code> and <code>manifest.json</code> package files.</p>
<pre><code class="language-bash">/m our@&lt;your_process&gt;:&lt;your_package&gt;:&lt;your_publisher&gt; {&quot;Hello&quot;: &quot;hey there&quot;}
</code></pre>
<p>You should see the message text printed. Next, try a goodbye.
This will cause the process to exit.</p>
<pre><code class="language-bash">/m our@&lt;your_process&gt;:&lt;your_package&gt;:&lt;your_publisher&gt; &quot;Goodbye&quot;
</code></pre>
<p>If you try to send another Hello now, nothing will happen, because the process has exited <a href="my_first_app/./chapter_2.html#aside-on_exit">(assuming you have set <code>on_exit: &quot;None&quot;</code>; with <code>on_exit: &quot;Restart&quot;</code> it will immediately start up again)</a>.
Nice!
You can use <code>kit start-package</code> to try again.</p>
<p>In the next chapter, you'll add some basic HTTP logic to serve a frontend from your simple process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frontend-time"><a class="header" href="#frontend-time">Frontend Time</a></h1>
<p>After the last chapter, you should have a simple process that responds to two commands from the terminal.
In this chapter, you'll add some basic HTTP logic to serve a frontend and accept an HTTP PUT request that contains a command.</p>
<p>If you're the type of person that prefers to learn by looking at a complete example, check out the <a href="my_first_app/../chess_app/frontend.html">chess frontend chapter</a> for a fleshed-out example and a link to some frontend code.</p>
<h2 id="adding-http-request-handling"><a class="header" href="#adding-http-request-handling">Adding HTTP request handling</a></h2>
<p>Using the built-in HTTP server will require handling a new type of request in our main loop, and serving a response to it.
The <a href="my_first_app/../process_stdlib/overview.html">process_lib</a> contains types and functions for doing so.</p>
<p>At the top of your process, import <code>http</code>, <code>get_blob</code>, and <code>Message</code> from <a href="my_first_app/../process_stdlib/overview.html"><code>nectar_process_lib</code></a> along with the rest of the imports.
You'll use <code>get_blob()</code> to grab the body bytes of an incoming HTTP request.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::{
    await_message, call_init, get_blob, http, println, Address, Message, Request, Response,
};
<span class="boring">}</span></code></pre></pre>
<p>Keep the custom <code>body</code> type the same, and keep using that for terminal input.</p>
<p>At the beginning of the init function, in order to receieve HTTP requests, you must use the <code>nectar_process_lib::http</code> library to bind a new path. Binding a path will cause the process to receive all HTTP requests that match that path.
You can also bind static content to a path using another function in the library.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
fn my_init_fn(our: Address) {
    println!(&quot;{our}: started&quot;);
    // the first argument is the path to bind. Note that requests will be namespaced
    // under the process name, so this will be accessible at /my_process/

    // the second argument marks whether to serve the path only to authenticated clients,
    // and the third argument marks whether to only serve the path locally.
    // in order to skip authentication, set the second argument to false here.
    http::bind_http_path(&quot;/&quot;, false, false).unwrap();
    // ...
}
// ...
<span class="boring">}</span></code></pre></pre>
<p>Now that you're handling multiple kinds of requests, let's refactor the loop to be more concise and move the request-specific logic to dedicated functions.
Put this right under the bind command:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    match await_message() {
        Ok(message) =&gt; {
            if message.source().process == &quot;http_server:sys:nectar&quot; {
                handle_http_message(&amp;our, &amp;message);
            } else {
                if handle_hello_message(&amp;message) {
                    break;
                }
            }
        }
        Err(_send_error) =&gt; {
            println!(&quot;got send error!&quot;);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that different apps will want to discriminate between incoming messages differently.
This code doesn't check the <code>source.node</code> at all, for example.</p>
<p>The <code>handle_hello_message</code> will look just like what was in chapter 3.
However, since this logic is no longer inside the main loop, return a boolean to indicate whether or not to exit out of the loop.
Request handling can be separated out into as many functions is needed to keep the code clean.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Returns true if the process should exit.
fn handle_hello_message(message: &amp;Message) -&gt; bool {
    let Ok(body) = MyBody::parse(message.body()) else {
        println!(&quot;received a message with weird `body`!&quot;);
        return false;
    };
    if message.is_request() {
        // Respond to a Hello with a Hello, and a Goodbye by exiting
        // the loop, which will cause the process to exit.
        match body {
            MyBody::Hello(text) =&gt; {
                println!(&quot;got a Hello: {text}&quot;);
            }
            MyBody::Goodbye =&gt; {
                println!(&quot;goodbye!&quot;);
                return true;
            }
        }
    } else {
        // we only expect Hello responses. If we get a Goodbye, ignore it.
        match body {
            MyBody::Hello(text) =&gt; {
                println!(&quot;got a Hello response: {text}&quot;);
            }
            MyBody::Goodbye =&gt; {}
        }
    }
    return false;
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, let's define <code>handle_http_message</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_http_message(our: &amp;Address, message: &amp;Message) {

}
<span class="boring">}</span></code></pre></pre>
<p>Instead of parsing our <code>body</code> type from the message, parse the type that the <code>http_server</code> process gives us. This type is defined in the <code>nectar_process_lib::http</code> module for us:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
let Ok(server_request) = http::HttpServerRequest::from_bytes(message.body()) else {
    println!(&quot;received a message with weird `body`!&quot;);
    return;
};
// ...
<span class="boring">}</span></code></pre></pre>
<p>Next, you must parse out the HTTP request from the general type.
This is necessary because the <code>HttpServerRequest</code> enum contains both HTTP protocol requests and requests related to WebSockets.
Note that it's quite possible to streamline this series of request refinements if you're only interested in one type of request — this example is overly thorough for demonstration purposes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
let Some(http_request) = server_request.request() else {
    println!(&quot;received a WebSocket message, skipping&quot;);
    return;
};
// ...
<span class="boring">}</span></code></pre></pre>
<p>Now, check the HTTP method in order to only handle PUT requests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
if http_request.method().unwrap() != http::Method::PUT {
    println!(&quot;received a non-PUT HTTP request, skipping&quot;);
    return;
}
// ...
<span class="boring">}</span></code></pre></pre>
<p>Finally, grab the <code>blob</code> from the request, send a 200 OK response to the client, and handle the <code>blob</code>, by sending a Request to ourselves with the <code>blob</code> as the <code>body</code>.
This could be done in a different way, but this simple pattern is useful for letting HTTP requests masquerade as in-Nectar requests.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
let Some(body) = get_blob() else {
    println!(&quot;received a PUT HTTP request with no body, skipping&quot;);
    return;
};
http::send_response(http::StatusCode::OK, None, vec![]).unwrap();
Request::to(our).body(body.bytes).send().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Putting it all together, you get a process which you can build and start, then use cURL to send Hello and Goodbye requests via HTTP PUTs!</p>
<p>Also, remember to request the capability to message <code>http_server</code> in <code>manifest.json</code>:</p>
<pre><code class="language-json">...
&quot;request_capabilities&quot;: [
    &quot;http_server:sys:nectar&quot;
],
...
</code></pre>
<p>Here's the full code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use nectar_process_lib::{
    await_message, call_init, get_blob, http, println, Address, Message, Request,
};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

#[derive(Serialize, Deserialize)]
enum MyBody {
    Hello(String),
    Goodbye,
}

impl MyBody {
    fn hello(text: &amp;str) -&gt; Vec&lt;u8&gt; {
        serde_json::to_vec(&amp;MyBody::Hello(text.to_string())).unwrap()
    }

    fn goodbye() -&gt; Vec&lt;u8&gt; {
        serde_json::to_vec(&amp;MyBody::Goodbye).unwrap()
    }

    fn parse(bytes: &amp;[u8]) -&gt; Result&lt;MyBody, serde_json::Error&gt; {
        serde_json::from_slice::&lt;MyBody&gt;(bytes)
    }
}

call_init!(my_init_fn);

fn my_init_fn(our: Address) {
    println!(&quot;{our}: started&quot;);

    http::bind_http_path(&quot;/&quot;, false, false).unwrap();

    Request::new()
        .target(&amp;our)
        .body(MyBody::hello(&quot;hello world&quot;))
        .send()
        .unwrap();

    loop {
        match await_message() {
            Ok(message) =&gt; {
                if message.source().process == &quot;http_server:sys:nectar&quot; {
                    handle_http_message(&amp;our, &amp;message);
                } else {
                    if handle_hello_message(&amp;message) {
                        break;
                    }
                }
            }
            Err(_send_error) =&gt; {
                println!(&quot;got send error!&quot;);
            }
        }
    }
}

/// Handle a message from the HTTP server.
fn handle_http_message(our: &amp;Address, message: &amp;Message) {
    let Ok(server_request) = http::HttpServerRequest::from_bytes(message.body()) else {
        println!(&quot;received a message with weird `body`!&quot;);
        return;
    };
    let Some(http_request) = server_request.request() else {
        println!(&quot;received a WebSocket message, skipping&quot;);
        return;
    };
    if http_request.method().unwrap() != http::Method::PUT {
        println!(&quot;received a non-PUT HTTP request, skipping&quot;);
        return;
    }
    let Some(body) = get_blob() else {
        println!(&quot;received a PUT HTTP request with no body, skipping&quot;);
        return;
    };
    http::send_response(http::StatusCode::OK, None, vec![]).unwrap();
    Request::to(our).body(body.bytes).send().unwrap();
}

/// Returns true if the process should exit.
fn handle_hello_message(message: &amp;Message) -&gt; bool {
    let Ok(body) = MyBody::parse(message.body()) else {
        println!(&quot;received a message with weird `body`!&quot;);
        return false;
    };
    if message.is_request() {
        // Respond to a Hello with a Hello, and a Goodbye by exiting
        // the loop, which will cause the process to exit.
        match body {
            MyBody::Hello(text) =&gt; {
                println!(&quot;got a Hello: {text}&quot;);
            }
            MyBody::Goodbye =&gt; {
                println!(&quot;goodbye!&quot;);
                return true;
            }
        }
    } else {
        // we only expect Hello responses. If we get a Goodbye, ignore it.
        match body {
            MyBody::Hello(text) =&gt; {
                println!(&quot;got a Hello response: {text}&quot;);
            }
            MyBody::Goodbye =&gt; {}
        }
    }
    return false;
}
<span class="boring">}</span></code></pre></pre>
<p>A cURL command to send a Hello request looks like this.
Make sure to replace the URL with your node's local port and the correct process name.
Note: if you had not set <code>authenticated</code> to false in the bind command, you would need to add an <code>Authorization</code> header to this request with the JWT cookie of your node.
This is saved in your browser automatically on login.</p>
<pre><code class="language-bash">curl -X PUT -H &quot;Content-Type: application/json&quot; -d '{&quot;Hello&quot;: &quot;greetings&quot;}' &quot;http://localhost:8080/tutorial:tutorial:template.nec&quot;
</code></pre>
<h2 id="serving-a-static-frontend"><a class="header" href="#serving-a-static-frontend">Serving a static frontend</a></h2>
<p>If you just want to serve an API, you've seen enough now to handle PUTs and GETs to your heart's content.
But the classic personal node app also serves a webpage that provides a user interface for your program.</p>
<p>You <em>could</em> add handling to our <code>/</code> path to dynamically serve some HTML on every GET.
But for maximum ease and efficiency, use the static bind command on <code>/</code> and move our PUT handling to <code>/api</code>.
To do this, edit the bind commands in <code>my_init_fn</code> to look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>http::bind_http_path(&quot;/api&quot;, true, false).unwrap();
http::serve_index_html(&amp;our, &quot;ui&quot;).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Now you can add a static <code>index.html</code> file to the package.
UI files are stored in the <code>ui/</code> directory and built into the application by <code>kit build</code> automatically.
Create a new file in <code>ui/index.html</code> with the following contents.
<strong>Make sure to replace the fetch URL with your process ID!</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;main&gt;
        &lt;h1&gt;This is a website!&lt;/h1&gt;
        &lt;p&gt;Enter a message to send to the process:&lt;/p&gt;
        &lt;form id=&quot;hello-form&quot; class=&quot;col&quot;&gt;
        &lt;input id=&quot;hello&quot; required=&quot;&quot; name=&quot;hello&quot; placeholder=&quot;hello world&quot; value=&quot;&quot;&gt;
        &lt;button&gt; PUT &lt;/button&gt;
      &lt;/form&gt;
    &lt;/main&gt;
	&lt;script&gt;
        async function say_hello(text) {
          const result = await fetch(&quot;/tutorial:tutorial:template.nec/api&quot;, {
            method: &quot;PUT&quot;,
            headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },
            body: JSON.stringify({ &quot;Hello&quot;: text }),
          });
          console.log(result);
        }


        document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
          const form = document.getElementById(&quot;hello-form&quot;);
          form.addEventListener(&quot;submit&quot;, (e) =&gt; {
            e.preventDefault();
            e.stopPropagation();
            const text = document.getElementById(&quot;hello&quot;).value;
            say_hello(text);
          });
        });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>This is a super barebones <code>index.html</code> that provides a form to make requests to the <code>/api</code> endpoint.</p>
<p>Finally, add one more entry to <code>manifest.json</code>: messaging capabilities to the VFS which is required to store and access the UI <code>index.html</code>:</p>
<pre><code class="language-json">...
&quot;request_capabilities&quot;: [
    &quot;vfs:sys:nectar&quot;
],
...
</code></pre>
<p>After saving this file to <code>ui/index.html</code>, rebuilding the program, and starting the package again, you should be able to navigate to you <code>http://localhost:8080/&lt;process_id&gt;</code> and see the form page.
Note that you can now set <code>authenticated</code> to <code>true</code> in the <code>/api</code> binding and the webpage will still work, but cURL will not.</p>
<p>This frontend is now fully packaged with the process — there are no more steps!
Of course, this can be made arbitrarily complex with various frontend frameworks that produce a static build.</p>
<p>In the next and final chapter, learn about the package metadata and how to share this app across the Nectar network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sharing-with-the-world"><a class="header" href="#sharing-with-the-world">Sharing with the World</a></h1>
<p>So, you've made a new process.
You've tested your code and are ready to share with friends, or perhaps just install across multiple nodes in order to do more testing.</p>
<p>First, it's a good idea to publish the code to a public repository.
This can be added to your package metadata.json like so:</p>
<pre><code class="language-json">...
&quot;website&quot;: &quot;https://github.com/your_package_repo&quot;,
...
</code></pre>
<p>Next, review all the data in <a href="my_first_app/./chapter_1.html#pkgmanifestjson"><code>pkg/manifest.json</code></a> and <a href="my_first_app/./chapter_1.html#pkgmetadatajson"><code>pkg/metadata.json</code></a>.
The <code>package</code> field in <code>metadata.json</code> determines the name of the package.
The <code>publisher</code> field determines the name of the publisher (you!).
<strong>Note: you <em>can</em> set any publisher name you want, but others will be able to verify that you are the publisher by comparing the value in this field with a signature attached to the entry in a (good) app store or package manager, so it's a good idea to put <em>your node identity</em> here.</strong></p>
<p>Once you're ready to share, it's quite easy.
If you are developing on a fake node, you'll have to boot a real one, then install this package locally in order to publish on the network.
If you're already on a real node, you can go ahead and navigate to the App Store on the homepage and go through the publishing flow.</p>
<p>In the near future, you will be able to quickly and easily publish your applications to the network using a GUI from the App Store.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-depth-guide-chess-app"><a class="header" href="#in-depth-guide-chess-app">In-Depth Guide: Chess App</a></h1>
<p>This guide will walk you through building a very simple chess app on NectarOS.
The final result will look like <a href="https://github.com/uqbar-dao/nectar/tree/main/modules/chess">this</a>: chess is in the basic runtime distribution so you can try it yourself.</p>
<p>To prepare for this tutorial, follow the environment setup guide <a href="chess_app/../my_first_app/chapter_1.html">here</a>, i.e. <a href="chess_app/../my_first_app/chapter_1.html#booting-a-fake-nectar-node">start a fake node</a> and then, in another terminal, run:</p>
<pre><code class="language-bash">kit new my_chess
cd my_chess
kit build
kit start-package -p 8080
</code></pre>
<p>Once you have the template app installed and can see it running on your testing node, continue...</p>
<h1 id="chess-engine"><a class="header" href="#chess-engine">Chess Engine</a></h1>
<p>Chess is a good example for an Nectar application walk-through because:</p>
<ol>
<li>The basic game logic is already readily available.
There are thousands of high-quality chess libraries across many languages that can be imported into a Wasm app that runs on Nectar.
We'll be using <a href="https://github.com/pleco-rs/Pleco">pleco</a></li>
<li>It is a multiplayer game, showing Nectar's p2p communications and ability to serve frontends</li>
<li>It is fun!</li>
</ol>
<p>In <code>my_chess/Cargo.toml</code>, which should be in the <code>my_chess/</code> process directory inside the <code>my_chess/</code> package directory, add <code>pleco = &quot;0.5&quot;</code> to your dependencies.
In your <code>my_chess/src/lib.rs</code>, replace the existing code with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pleco::Board;
use nectar_process_lib::{await_message, call_init, println, Address};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

call_init!(init);

fn init(our: Address) {
    println!(&quot;{our}: start&quot;);

    loop {
        let _ = await_message().map(|message| {
            if !message.is_request() { return };
            println!(
                &quot;{our}: got request from {}: {}&quot;,
                message.source().process(),
                String::from_utf8_lossy(message.body())
            );
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now, we have access to a chess board and can manipulate it easily.</p>
<p>The <a href="https://github.com/pleco-rs/Pleco#using-pleco-as-a-library">pleco docs</a> show everything you can do using the pleco library.
But this isn't very interesting by itself!
We want to play chess with other people.
Let's start by creating a persisted state for the chess app and an <code>body</code> format for sending messages to other nodes.</p>
<p>In <code>my_chess/src/lib.rs</code> add the following simple Request/Response interface and persistable game state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

#[derive(Debug, Serialize, Deserialize)]
enum ChessRequest {
    NewGame { white: String, black: String },
    Move { game_id: String, move_str: String },
    Resign(String),
}

#[derive(Debug, Eq, PartialEq, Serialize, Deserialize)]
enum ChessResponse {
    NewGameAccepted,
    NewGameRejected,
    MoveAccepted,
    MoveRejected,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct Game {
    pub id: String, // the node with whom we are playing
    pub turns: u64,
    pub board: String,
    pub white: String,
    pub black: String,
    pub ended: bool,
}

#[derive(Debug, Serialize, Deserialize)]
struct ChessState {
    pub games: HashMap&lt;String, Game&gt;, // game is by opposing player id
}
<span class="boring">}</span></code></pre></pre>
<p>Creating explicit <code>ChessRequest</code> and <code>ChessResponse</code> types is the easiest way to ensure reliable and easy-to-parse messages between two processes (TODO: something missing here gramatically, but can't quite find the correct word).
It makes message-passing very simple.
If you get a request, you can deserialize it to <code>ChessRequest</code> and ignore or throw an error if that fails.
If you get a response, you can do the same but with <code>ChessResponse</code>.
And every request and response that you send can be serialized in kind.
More advanced apps can take on different structures, but a top-level <code>enum</code> to serialize/deserialize and match on is always a good idea.</p>
<p>The <code>ChessState</code> <code>struct</code> shown above can also be persisted using the <code>set_state</code> and <code>get_state</code> commands exposed by Nectar's runtime.
Note that the <code>Game</code> <code>struct</code> here has <code>board</code> as a <code>String</code>.
This is because the <code>Board</code> type from pleco doesn't implement <code>Serialize</code> or <code>Deserialize</code>.
We'll have to convert it to a string using <code>fen()</code> before persisting it.
Then, we will convert it back to a <code>Board</code> with <code>Board::from_fen()</code> when we load it from state.</p>
<p>The code below will contain a version of the <code>init()</code> function that creates an event loop and handles ChessRequests.
First, however, it's important to note that these types already bake in some assumptions about our &quot;chess protocol&quot;.
Remember, requests can either expect a response, or be fired and forgotten.
Unless a response is expected, there's no way to know if a request was received or not.
In a game like chess, most actions have a logical response.
Otherwise, there's no way to easily alert the user that their counterparty has gone offline, or started to otherwise ignore our moves.
For the sake of the tutorial, there are three kinds of requests and only two expect a response.
In our code, the <code>NewGame</code> and <code>Move</code> requests will always await a response, blocking until they receive one (or the request times out).
<code>Resign</code>, however, will be fire-and-forget.
While a &quot;real&quot; game may prefer to wait for a response, it is important to let one player resign and thus clear their state <em>without</em> that resignation being &quot;accepted&quot; by a non-responsive player, so production-grade resignation logic is non-trivial.</p>
<p>An aside: when building consumer-grade peer-to-peer apps, you'll find that there are in fact very few &quot;trivial&quot; interaction patterns.
Something as simple as resigning from a one-on-one game, which would be a single POST request in a client-frontend &lt;&gt; server-backend architecture, requires well-thought-out negotiations to ensure that both players can walk away with a clean state machine, regardless of whether the counterparty is cooperating.
Adding more &quot;players&quot; to the mix makes this even more complex.
To keep things clean, leverage the request/response pattern and the <code>context</code> field to store information about how to handle a given response, if you're not awaiting it in a blocking fashion.</p>
<p>Below, you'll find the full code for the CLI version of the app.
You can build it and install it on a node using <code>kit</code>.
You can interact with it in the terminal, primitively, like so (assuming your first node is <code>fake.nec</code> and second is <code>fake2.nec</code>):</p>
<pre><code>/a our@my_chess:my_chess:template.nec
/m {&quot;NewGame&quot;: {&quot;white&quot;: &quot;fake.nec&quot;, &quot;black&quot;: &quot;fake2.nec&quot;}}
/m {&quot;Move&quot;: {&quot;game_id&quot;: &quot;fake2.nec&quot;, &quot;move_str&quot;: &quot;e2e4&quot;}}
</code></pre>
<p>(If you want to make a more ergonomic CLI app, consider parsing <code>body</code> as a string...)</p>
<p>As you read through the code, you might notice a problem with this app: there's no way to see your games!
A fun project would be to add a CLI command that shows you, in-terminal, the board for a given <code>game_id</code>.
But in the <a href="chess_app/./frontend.html">next chapter</a>, we'll add a frontend to this app so you can see your games in a browser.</p>
<p><code>my_chess/Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;my_chess&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[profile.release]
panic = &quot;abort&quot;
opt-level = &quot;s&quot;
lto = true

[dependencies]
anyhow = &quot;1.0&quot;
base64 = &quot;0.13&quot;
bincode = &quot;1.3.3&quot;
pleco = &quot;0.5&quot;
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
url = &quot;*&quot;
nectar_process_lib = { git = &quot;ssh://git@github.com/uqbar-dao/process_lib.git&quot;, rev = &quot;a2d3e9e&quot; }
wit-bindgen = { git = &quot;https://github.com/bytecodealliance/wit-bindgen&quot;, rev = &quot;efcc759&quot; }

[lib]
crate-type = [&quot;cdylib&quot;]

[package.metadata.component]
package = &quot;nectar:process&quot;
</code></pre>
<p><code>my_chess/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(let_chains)]
use pleco::Board;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use nectar_process_lib::{
    await_message, call_init, get_typed_state, println, set_state, Address, Message, NodeId, Request, Response,
};

extern crate base64;

// Boilerplate: generate the Wasm bindings for an Nectar app
wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

//
// Our &quot;chess protocol&quot; request/response format. We'll always serialize these
// to a byte vector and send them over `body`.
//

#[derive(Debug, Serialize, Deserialize)]
enum ChessRequest {
    NewGame { white: String, black: String },
    Move { game_id: String, move_str: String },
    Resign(String),
}

#[derive(Debug, Eq, PartialEq, Serialize, Deserialize)]
enum ChessResponse {
    NewGameAccepted,
    NewGameRejected,
    MoveAccepted,
    MoveRejected,
}

//
// Our serializable state format.
//

#[derive(Clone, Debug, Serialize, Deserialize)]
struct Game {
    pub id: String, // the node with whom we are playing
    pub turns: u64,
    pub board: String,
    pub white: String,
    pub black: String,
    pub ended: bool,
}

#[derive(Debug, Serialize, Deserialize)]
struct ChessState {
    pub games: HashMap&lt;String, Game&gt;, // game is by opposing player id
}

/// Helper function to serialize and save the process state.
fn save_chess_state(state: &amp;ChessState) {
    set_state(&amp;bincode::serialize(&amp;state.games).unwrap());
}

/// Helper function to deserialize the process state. Note that we use a helper function
/// from process_lib to fetch a typed state, which will return None if the state does
/// not exist OR fails to deserialize. In either case, we'll make an empty new state.
fn load_chess_state() -&gt; ChessState {
    match get_typed_state(|bytes| Ok(bincode::deserialize::&lt;HashMap&lt;String, Game&gt;&gt;(bytes)?)) {
        Some(games) =&gt; ChessState { games },
        None =&gt; ChessState {
            games: HashMap::new(),
        },
    }
}

call_init!(init);

fn init(our: Address) {
    // A little printout to show in terminal that the process has started.
    println!(
        &quot;{} by {}: start&quot;,
        our.process.process_name, our.process.publisher_node
    );

    // Grab our state, then enter the main event loop.
    let mut state: ChessState = load_chess_state();
    main_loop(&amp;our, &amp;mut state);
}

fn main_loop(our: &amp;Address, state: &amp;mut ChessState) {
    loop {
        // Call await_message() to wait for any incoming messages.
        // If we get a network error, make a print and throw it away.
        // In a high-quality consumer-grade app, we'd want to explicitly handle
        // this and surface it to the user.
        match await_message() {
            Err(send_error) =&gt; {
                println!(&quot;{our}: got network error: {send_error:?}&quot;);
                continue;
            }
            Ok(message) =&gt; match handle_request(&amp;our, &amp;message, state) {
                Ok(()) =&gt; continue,
                Err(e) =&gt; println!(&quot;{our}: error handling request: {:?}&quot;, e),
            },
        }
    }
}

/// Handle chess protocol messages from ourself *or* other nodes.
fn handle_request(our: &amp;Address, message: &amp;Message, state: &amp;mut ChessState) -&gt; anyhow::Result&lt;()&gt; {
    // Throw away responses. We never expect any responses *here*, because for every
    // chess protocol request, we *await* its response in-place. This is appropriate
    // for direct node&lt;&gt;node comms, less appropriate for other circumstances...
    if !message.is_request() {
        return Err(anyhow::anyhow!(&quot;message was response&quot;));
    }
    // If the request is from another node, handle it as an incoming request.
    // Note that we can enforce the ProcessId as well, but it shouldn't be a trusted
    // piece of information, since another node can easily spoof any ProcessId on a request.
    // It can still be useful simply as a protocol-level switch to handle different kinds of
    // requests from the same node, with the knowledge that the remote node can finagle with
    // which ProcessId a given message can be from. It's their code, after all.
    if message.source().node != our.node {
        // Deserialize the request `body` to our format, and throw it away if it
        // doesn't fit.
        let Ok(chess_request) = serde_json::from_slice::&lt;ChessRequest&gt;(message.body()) else {
            return Err(anyhow::anyhow!(&quot;invalid chess request&quot;));
        };
        handle_chess_request(&amp;message.source().node, state, &amp;chess_request)
    // ...and if the request is from ourselves, handle it as our own!
    // Note that since this is a local request, we *can* trust the ProcessId.
    // Here, we'll accept messages from the local terminal so as to make this a &quot;CLI&quot; app.
    } else if message.source().node == our.node
        &amp;&amp; message.source().process == &quot;terminal:terminal:nectar&quot;
    {
        let Ok(chess_request) = serde_json::from_slice::&lt;ChessRequest&gt;(message.body()) else {
            return Err(anyhow::anyhow!(&quot;invalid chess request&quot;));
        };
        handle_local_request(our, state, &amp;chess_request)
    } else {
        // If we get a request from ourselves that isn't from the terminal, we'll just
        // throw it away. This is a good place to put a printout to show that we've
        // received a request from ourselves that we don't know how to handle.
        return Err(anyhow::anyhow!(
            &quot;got request from not-the-terminal, ignoring&quot;
        ));
    }
}

/// handle chess protocol messages from other nodes
fn handle_chess_request(
    source_node: &amp;NodeId,
    state: &amp;mut ChessState,
    action: &amp;ChessRequest,
) -&gt; anyhow::Result&lt;()&gt; {
    println!(&quot;chess: handling action from {source_node}: {action:?}&quot;);

    // For simplicity's sake, we'll just use the node we're playing with as the game id.
    // This limits us to one active game per partner.
    let game_id = source_node;

    match action {
        ChessRequest::NewGame { white, black } =&gt; {
            // Make a new game with source.node
            // This will replace any existing game with source.node!
            if state.games.contains_key(game_id) {
                println!(&quot;chess: resetting game with {game_id} on their request!&quot;);
            }
            let game = Game {
                id: game_id.to_string(),
                turns: 0,
                board: Board::start_pos().fen(),
                white: white.to_string(),
                black: black.to_string(),
                ended: false,
            };
            // Use our helper function to persist state after every action.
            // The simplest and most trivial way to keep state. You'll want to
            // use a database or something in a real app, and consider performance
            // when doing intensive data-based operations.
            state.games.insert(game_id.to_string(), game);
            save_chess_state(&amp;state);
            // Send a response to tell them we've accepted the game.
            // Remember, the other player is waiting for this.
            Response::new()
                .body(serde_json::to_vec(&amp;ChessResponse::NewGameAccepted)?)
                .send()
        }
        ChessRequest::Move { ref move_str, .. } =&gt; {
            // Get the associated game, and respond with an error if
            // we don't have it in our state.
            let Some(game) = state.games.get_mut(game_id) else {
                // If we don't have a game with them, reject the move.
                return Response::new()
                    .body(serde_json::to_vec(&amp;ChessResponse::MoveRejected)?)
                    .send()
            };
            // Convert the saved board to one we can manipulate.
            let mut board = Board::from_fen(&amp;game.board).unwrap();
            if !board.apply_uci_move(move_str) {
                // Reject invalid moves!
                return Response::new()
                    .body(serde_json::to_vec(&amp;ChessResponse::MoveRejected)?)
                    .send();
            }
            game.turns += 1;
            if board.checkmate() || board.stalemate() {
                game.ended = true;
            }
            // Persist state.
            game.board = board.fen();
            save_chess_state(&amp;state);
            // Send a response to tell them we've accepted the move.
            Response::new()
                .body(serde_json::to_vec(&amp;ChessResponse::MoveAccepted)?)
                .send()
        }
        ChessRequest::Resign(_) =&gt; {
            // They've resigned. The sender isn't waiting for a response to this,
            // so we don't need to send one.
            match state.games.get_mut(game_id) {
                Some(game) =&gt; {
                    game.ended = true;
                    save_chess_state(&amp;state);
                }
                None =&gt; {}
            }
            Ok(())
        }
    }
}

/// Handle actions we are performing. Here's where we'll send_and_await various requests.
fn handle_local_request(
    our: &amp;Address,
    state: &amp;mut ChessState,
    action: &amp;ChessRequest,
) -&gt; anyhow::Result&lt;()&gt; {
    match action {
        ChessRequest::NewGame { white, black } =&gt; {
            // Create a new game. We'll enforce that one of the two players is us.
            if white != &amp;our.node &amp;&amp; black != &amp;our.node {
                return Err(anyhow::anyhow!(&quot;cannot start a game without us!&quot;));
            }
            let game_id = if white == &amp;our.node { black } else { white };
            // If we already have a game with this player, throw an error.
            if let Some(game) = state.games.get(game_id)
                &amp;&amp; !game.ended
            {
                return Err(anyhow::anyhow!(&quot;already have a game with {game_id}&quot;));
            };
            // Send the other player a NewGame request
            // The request is exactly the same as what we got from terminal.
            // We'll give them 5 seconds to respond...
            let Ok(Message::Response { ref body, .. }) = Request::new()
                .target((game_id.as_ref(), our.process.clone()))
                .body(serde_json::to_vec(&amp;action)?)
                .send_and_await_response(5)? else {
                    return Err(anyhow::anyhow!(&quot;other player did not respond properly to new game request&quot;))
                };
            // If they accept, create a new game — otherwise, error out.
            if serde_json::from_slice::&lt;ChessResponse&gt;(body)? != ChessResponse::NewGameAccepted {
                return Err(anyhow::anyhow!(&quot;other player rejected new game request!&quot;));
            }
            // New game with default board.
            let game = Game {
                id: game_id.to_string(),
                turns: 0,
                board: Board::start_pos().fen(),
                white: white.to_string(),
                black: black.to_string(),
                ended: false,
            };
            state.games.insert(game_id.to_string(), game);
            save_chess_state(&amp;state);
            Ok(())
        }
        ChessRequest::Move { game_id, move_str } =&gt; {
            // Make a move. We'll enforce that it's our turn. The game_id is the
            // person we're playing with.
            let Some(game) = state.games.get_mut(game_id) else {
                return Err(anyhow::anyhow!(&quot;no game with {game_id}&quot;));
            };
            if (game.turns % 2 == 0 &amp;&amp; game.white != our.node)
                || (game.turns % 2 == 1 &amp;&amp; game.black != our.node)
            {
                return Err(anyhow::anyhow!(&quot;not our turn!&quot;));
            } else if game.ended {
                return Err(anyhow::anyhow!(&quot;that game is over!&quot;));
            }
            let mut board = Board::from_fen(&amp;game.board).unwrap();
            if !board.apply_uci_move(move_str) {
                return Err(anyhow::anyhow!(&quot;illegal move!&quot;));
            }
            // Send the move to the other player, then check if the game is over.
            // The request is exactly the same as what we got from terminal.
            // We'll give them 5 seconds to respond...
            let Ok(Message::Response { ref body, .. }) = Request::new()
                .target((game_id.as_ref(), our.process.clone()))
                .body(serde_json::to_vec(&amp;action)?)
                .send_and_await_response(5)? else {
                    return Err(anyhow::anyhow!(&quot;other player did not respond properly to our move&quot;))
                };
            if serde_json::from_slice::&lt;ChessResponse&gt;(body)? != ChessResponse::MoveAccepted {
                return Err(anyhow::anyhow!(&quot;other player rejected our move&quot;));
            }
            game.turns += 1;
            if board.checkmate() || board.stalemate() {
                game.ended = true;
            }
            game.board = board.fen();
            save_chess_state(&amp;state);
            Ok(())
        }
        ChessRequest::Resign(ref with_who) =&gt; {
            // Resign from a game with a given player.
            let Some(game) = state.games.get_mut(with_who) else {
                return Err(anyhow::anyhow!(&quot;no game with {with_who}&quot;));
            };
            // send the other player an end game request — no response expected
            Request::new()
                .target((with_who.as_ref(), our.process.clone()))
                .body(serde_json::to_vec(&amp;action)?)
                .send()?;
            game.ended = true;
            save_chess_state(&amp;state);
            Ok(())
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-frontend"><a class="header" href="#adding-a-frontend">Adding a Frontend</a></h1>
<p>Here, we'll add a web frontend to the code from the <a href="chess_app/./chess_engine.html">previous section</a>.</p>
<p>Creating a web frontend has two parts:</p>
<ol>
<li>Altering the process code to serve and handle HTTP requests</li>
<li>Writing a webpage to interact with the process.
Here, you'll use React to make a single-page app that displays your current games and allows us to: create new games, resign from games, and make moves on the chess board.</li>
</ol>
<p>JavaScript and React development aren't in the scope of this tutorial, so we'll provide that code <a href="https://github.com/uqbar-dao/chess-ui">here</a>.</p>
<p>The important part of the frontend for the purpose of this tutorial is the build, specifically the <code>pkg/ui</code> directory that will be loaded into the VFS during installation.
Serve these as static files, <a href="https://github.com/uqbar-dao/chess-ui/tree/tutorial/tutorial_build">which you can get here</a> if you don't want to build them yourself.</p>
<p>Run <code>npm run build</code> in the <code>chess-ui</code> repo and copy the output <code>dist</code> folder into the <code>pkg</code> folder in your app, so it'll be ingested on-install.
This allows your process to fetch them from the virtual filesystem, as all files in <code>pkg</code> are mounted.
Rename it to <code>ui</code> so that you have the files in <code>pkg/ui</code>.
See the <a href="chess_app/../apis/vfs.html">VFS API overview</a> to see how to use files mounted in <code>pkg</code>.</p>
<p>Chess will use the <code>http_server</code> runtime module to serve a static frontend and receive HTTP requests from it.
You'll also use a WebSocket connection to send updates to the frontend when the game state changes.</p>
<p>In <code>my_chess/src/lib.rs</code>, inside <code>init()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use nectar_process_lib::http;
...
// Serve the index.html and other UI files found in pkg/ui at the root path.
http::serve_ui(&amp;our, &quot;ui&quot;).unwrap();

// Allow HTTP requests to be made to /games; they will be handled dynamically.
http::bind_http_path(&quot;/games&quot;, true, false).unwrap();

// Allow websockets to be opened at / (our process ID will be prepended).
http::bind_ws_path(&quot;/&quot;, true, false).unwrap();
...
<span class="boring">}</span></code></pre></pre>
<p>The above code should be inserted into the <code>init()</code> function such that the frontend is served when the process starts.</p>
<p>The <code>http</code> library in <a href="chess_app/../process_stdlib/overview.html">process_lib</a> provides a simple interface for serving static files and handling HTTP requests.
Use <code>serve_ui</code> to serve the static files includeded in the process binary, and <code>bind_http_path</code> to handle requests to <code>/games</code>.
<code>serve_ui</code> takes two arguments: the process' <code>&amp;Address</code> and the name of the folder inside <code>pkg</code> that contains the <code>index.html</code> and other associated UI files.
See <a href="chess_app/../process_stdlib/overview.html">process_lib docs</a> for more functions and documentation on their parameters.
These requests all serve HTTP that can only be accessed by a logged-in node user (the <code>true</code> parameter for <code>authenticated</code>) and can be accessed remotely (the <code>false</code> parameter for <code>local_only</code>).
This API is under active development!</p>
<p>Requests on the <code>/games</code> path will arrive as requests to your process, and you'll have to handle them and respond.
The request/response format can be imported from <code>http</code> in <code>process_lib</code>.
To do this, add a branch to the main request-handling function that takes requests from <code>http_server:sys:nectar</code>.</p>
<p>In <code>my_chess/src/lib.rs</code>, inside <code>handle_request()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
    } else if message.source().node == our.node
        &amp;&amp; message.source().process == &quot;http_server:sys:nectar&quot;
    {
        // receive HTTP requests and websocket connection messages from our server
        match serde_json::from_slice::&lt;http::HttpServerRequest&gt;(message.body())? {
            http::HttpServerRequest::Http(ref incoming) =&gt; {
                match handle_http_request(our, state, incoming) {
                    Ok(()) =&gt; Ok(()),
                    Err(e) =&gt; {
                        println!(&quot;chess: error handling http request: {:?}&quot;, e);
                        http::send_response(
                            http::StatusCode::SERVICE_UNAVAILABLE,
                            None,
                            &quot;Service Unavailable&quot;.to_string().as_bytes().to_vec(),
                        )
                    }
                }
            }
            http::HttpServerRequest::WebSocketOpen { channel_id, .. } =&gt; {
                // We know this is authenticated and unencrypted because we only
                // bound one path, the root path. So we know that client
                // frontend opened a websocket and can send updates
                state.clients.insert(channel_id);
                Ok(())
            }
            http::HttpServerRequest::WebSocketClose(channel_id) =&gt; {
                // client frontend closed a websocket
                state.clients.remove(&amp;channel_id);
                Ok(())
            }
            http::HttpServerRequest::WebSocketPush { .. } =&gt; {
                // client frontend sent a websocket message
                // we don't expect this! we only use websockets to push updates
                Ok(())
            }
        }
    } else {
...
<span class="boring">}</span></code></pre></pre>
<p>This code won't compile yet — you need a new function to handle HTTP requests, and a new state parameter to handle active frontend clients.</p>
<p>Before defining <code>handle_http_request</code>, you need to add a new state parameter in the process state.
The state will keep track of all connected clients in a <code>HashSet&lt;u32&gt;</code> and send updates to them when the game state changes.
You'll also need to update the <code>save_chess_state</code> and <code>load_chess_state</code> functions to handle this new state.</p>
<p>In <code>my_chess/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
#[derive(Debug, Serialize, Deserialize)]
struct ChessState {
    pub games: HashMap&lt;String, Game&gt;, // game is by opposing player id
    pub clients: HashSet&lt;u32&gt;,        // doesn't get persisted
}
...
<span class="boring">}</span></code></pre></pre>
<p><code>clients</code> now holds the channel IDs of all connected clients.
It'll be used to send updates over WebSockets to the frontend when the game state changes.
But wait!
This information shouldn't be persisted because those connections will disappear when the process is killed or the node running this process is turned off.
Instead, create another state type for persistence and convert to/from the in-memory one above when you save process state.</p>
<p>In <code>my_chess/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use std::collections::{HashMap, HashSet};
...
#[derive(Debug, Serialize, Deserialize)]
struct StoredChessState {
    pub games: HashMap&lt;String, Game&gt;, // game is by opposing player id
}

fn save_chess_state(state: &amp;ChessState) {
    set_state(&amp;bincode::serialize(&amp;state.games).unwrap());
}

fn load_chess_state() -&gt; ChessState {
    match get_typed_state(|bytes| Ok(bincode::deserialize::&lt;HashMap&lt;String, Game&gt;&gt;(bytes)?)) {
        Some(games) =&gt; ChessState {
            games,
            clients: HashSet::new(),
        },
        None =&gt; ChessState {
            games: HashMap::new(),
            clients: HashSet::new(),
        },
    }
}
...
<span class="boring">}</span></code></pre></pre>
<p>Now, change the <code>handle_http_request</code> function to take incoming HTTP requests and return HTTP responses.
This will serve the same purpose as the <code>handle_local_request</code> function from the previous chapter, meaning that the frontend will produce actions and the backend will execute them.</p>
<p>An aside: As a process dev, you should be aware that HTTP resources served in this way can be accessed by <em>other processes running on the same node</em>, regardless of whether the paths are authenticated or not.
This can be a security risk: if your app is handling sensitive actions from the frontend, a malicious app could make those API requests instead.
You should never expect users to &quot;only install non-malicious apps&quot; — instead, use a <em>secure subdomain</em> to isolate your app's HTTP resources from other processes.
See the <a href="chess_app/../apis/http_server.html">HTTP Server API</a> for more details.</p>
<p>In <code>my_chess/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use nectar_process_lib::get_blob;
...
fn handle_http_request(
    our: &amp;Address,
    state: &amp;mut ChessState,
    http_request: &amp;http::IncomingHttpRequest,
) -&gt; anyhow::Result&lt;()&gt; {
    if http_request.path()? != &quot;games&quot; {
        return http::send_response(
            http::StatusCode::NOT_FOUND,
            None,
            &quot;Not Found&quot;.to_string().as_bytes().to_vec(),
        );
    }
    match http_request.method.as_str() {
        // on GET: give the frontend all of our active games
        &quot;GET&quot; =&gt; http::send_response(
            http::StatusCode::OK,
            Some(HashMap::from([(
                String::from(&quot;Content-Type&quot;),
                String::from(&quot;application/json&quot;),
            )])),
            serde_json::to_vec(&amp;state.games)?,
        ),
        // on POST: create a new game
        &quot;POST&quot; =&gt; {
            let Some(blob) = get_blob() else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            let blob_json = serde_json::from_slice::&lt;serde_json::Value&gt;(&amp;blob.bytes)?;
            let Some(game_id) = blob_json[&quot;id&quot;].as_str() else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            if let Some(game) = state.games.get(game_id)
                &amp;&amp; !game.ended
            {
                return http::send_response(http::StatusCode::CONFLICT, None, vec![]);
            };

            let player_white = blob_json[&quot;white&quot;]
                .as_str()
                .unwrap_or(our.node.as_str())
                .to_string();
            let player_black = blob_json[&quot;black&quot;]
                .as_str()
                .unwrap_or(game_id)
                .to_string();

            // send the other player a new game request
            let Ok(msg) = Request::new()
                .target((game_id, our.process.clone()))
                .body(serde_json::to_vec(&amp;ChessRequest::NewGame {
                    white: player_white.clone(),
                    black: player_black.clone(),
                })?)
                .send_and_await_response(5)? else {
                    return Err(anyhow::anyhow!(&quot;other player did not respond properly to new game request&quot;))
                };
            // if they accept, create a new game
            // otherwise, should surface error to FE...
            if serde_json::from_slice::&lt;ChessResponse&gt;(msg.body())? != ChessResponse::NewGameAccepted
            {
                return Err(anyhow::anyhow!(&quot;other player rejected new game request&quot;));
            }
            // create a new game
            let game = Game {
                id: game_id.to_string(),
                turns: 0,
                board: Board::start_pos().fen(),
                white: player_white,
                black: player_black,
                ended: false,
            };
            let body = serde_json::to_vec(&amp;game)?;
            state.games.insert(game_id.to_string(), game);
            save_chess_state(&amp;state);
            http::send_response(
                http::StatusCode::OK,
                Some(HashMap::from([(
                    String::from(&quot;Content-Type&quot;),
                    String::from(&quot;application/json&quot;),
                )])),
                body,
            )
        }
        // on PUT: make a move
        &quot;PUT&quot; =&gt; {
            let Some(blob) = get_blob() else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            let blob_json = serde_json::from_slice::&lt;serde_json::Value&gt;(&amp;blob.bytes)?;
            let Some(game_id) = blob_json[&quot;id&quot;].as_str() else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            let Some(game) = state.games.get_mut(game_id) else {
                return http::send_response(http::StatusCode::NOT_FOUND, None, vec![]);
            };
            if (game.turns % 2 == 0 &amp;&amp; game.white != our.node)
                || (game.turns % 2 == 1 &amp;&amp; game.black != our.node)
            {
                return http::send_response(http::StatusCode::FORBIDDEN, None, vec![]);
            } else if game.ended {
                return http::send_response(http::StatusCode::CONFLICT, None, vec![]);
            }
            let Some(move_str) = blob_json[&quot;move&quot;].as_str() else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            let mut board = Board::from_fen(&amp;game.board).unwrap();
            if !board.apply_uci_move(move_str) {
                // reader note: can surface illegal move to player or something here
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            }
            // send the move to the other player
            // check if the game is over
            // if so, update the records
            let Ok(msg) = Request::new()
                .target((game_id, our.process.clone()))
                .body(serde_json::to_vec(&amp;ChessRequest::Move {
                    game_id: game_id.to_string(),
                    move_str: move_str.to_string(),
                })?)
                .send_and_await_response(5)? else {
                    return Err(anyhow::anyhow!(&quot;other player did not respond properly to our move&quot;))
                };
            if serde_json::from_slice::&lt;ChessResponse&gt;(msg.body())? != ChessResponse::MoveAccepted {
                return Err(anyhow::anyhow!(&quot;other player rejected our move&quot;));
            }
            // update the game
            game.turns += 1;
            if board.checkmate() || board.stalemate() {
                game.ended = true;
            }
            game.board = board.fen();
            // update state and return to FE
            let body = serde_json::to_vec(&amp;game)?;
            save_chess_state(&amp;state);
            // return the game
            http::send_response(
                http::StatusCode::OK,
                Some(HashMap::from([(
                    String::from(&quot;Content-Type&quot;),
                    String::from(&quot;application/json&quot;),
                )])),
                body,
            )
        }
        // on DELETE: end the game
        &quot;DELETE&quot; =&gt; {
            let Some(game_id) = http_request.query_params.get(&quot;id&quot;) else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            let Some(game) = state.games.get_mut(game_id) else {
                return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
            };
            // send the other player an end game request
            Request::new()
                .target((game_id.as_str(), our.process.clone()))
                .body(serde_json::to_vec(&amp;ChessRequest::Resign(our.node.clone()))?)
                .send()?;
            game.ended = true;
            let body = serde_json::to_vec(&amp;game)?;
            save_chess_state(&amp;state);
            http::send_response(
                http::StatusCode::OK,
                Some(HashMap::from([(
                    String::from(&quot;Content-Type&quot;),
                    String::from(&quot;application/json&quot;),
                )])),
                body,
            )
        }
        // Any other method will be rejected.
        _ =&gt; http::send_response(http::StatusCode::METHOD_NOT_ALLOWED, None, vec![]),
    }
}
...
<span class="boring">}</span></code></pre></pre>
<p>This is a lot of code.
Mostly, it just handles the different HTTP methods and returns the appropriate responses.
The only unfamiliar code here is the <code>get_blob()</code> function, which is used here to inspect the HTTP body.
See the HTTP API docs (<a href="chess_app/../apis/http_client.html">client</a>, <a href="chess_app/../apis/http_server.html">server</a>) for more details.</p>
<p>Are you ready to play chess?
Almost there!
One more missing piece: the backend needs to send WebSocket updates to the frontend after each move in order to update the board without a refresh.
Since open channels are already tracked in process state, you just need to send a push to each open channel when a move occurs.</p>
<p>In <code>my_chess/src/lib.rs</code>, add a helper function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use nectar_process_lib::LazyLoadBlob;
...
fn send_ws_update(
    our: &amp;Address,
    game: &amp;Game,
    open_channels: &amp;HashSet&lt;u32&gt;,
) -&gt; anyhow::Result&lt;()&gt; {
    for channel in open_channels {
        Request::new()
            .target((&amp;our.node, &quot;http_server&quot;, &quot;sys&quot;, &quot;nectar&quot;))
            .body(serde_json::to_vec(
                &amp;http::HttpServerAction::WebSocketPush {
                    channel_id: *channel,
                    message_type: http::WsMessageType::Binary,
                },
            )?)
            .blob(LazyLoadBlob {
                mime: Some(&quot;application/json&quot;.to_string()),
                bytes: serde_json::json!({
                    &quot;kind&quot;: &quot;game_update&quot;,
                    &quot;data&quot;: game,
                }).to_string().into_bytes(),
            })
            .send()?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Now, anywhere you receive an action from another node (in <code>handle_chess_request()</code>, for example), call <code>send_ws_update(&amp;our, &amp;game, &amp;state.clients)?</code> to send an update to all connected clients.
You'll need to add <code>our</code> as a parameter to the handler function.
A good place to do this is right before saving the updated state.
Local moves from the frontend will update on their own.</p>
<p>Finally, add requests for <code>http_server</code> and <code>vfs</code> messaging capabilities to the <code>manifest.json</code>:</p>
<pre><code class="language-json">...
&quot;request_capabilities&quot;: [
    &quot;http_server:sys:nectar&quot;,
    &quot;vfs:sys:nectar&quot;
],
...
</code></pre>
<p>Continue to <a href="chess_app/./putting_everything_together.html">Putting Everything Together</a> to see the full code and screenshots of the app in action.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="putting-everything-together"><a class="header" href="#putting-everything-together">Putting Everything Together</a></h1>
<p>After adding a frontend in the previous chapter, your chess game is ready to play.</p>
<p>Hopefully, you've been using <code>kit build &lt;your_chess_app_name&gt;</code> to test the code as the tutorial has progressed.
If not, do so now in order to get a compiled package we can install onto a node.</p>
<p>Next, use <code>kit start-package &lt;your_chess_app_name&gt; -p &lt;your_test_node_port&gt;</code> to install the package.
You should see the printout we added to <code>init()</code> in your terminal: <code>chess by &lt;your_node_name&gt;: start</code>.</p>
<p>Remember that you determine the process name, package name, and your developer name in the <code>manifest.json</code> and <code>metadata.json</code> files inside <code>/pkg</code>.
Open your chess frontend by navigating to your node's URL (probably something like <code>http://localhost:8080</code>), and use the names you chose as the path.
For example, if your chess process name is <code>my_chess</code>, and your package is named <code>my_chess</code>, and your publisher name is <code>template.nec</code>, you would navigate to <code>http://localhost:8080/my_chess:my_chess:template.nec</code>.</p>
<p>You should see something like this:
<img src="chess_app/./chess_home.png" alt="chess frontend" /></p>
<p>To try it out, boot up another node, execute the <code>kit start-package</code> command, and invite your new node to a game.
Presto!</p>
<p>This concludes the main Chess tutorial.
If you're interested in learning more about how to write Nectar processes, there are several great options to extend the app:</p>
<ul>
<li>Consider how to handle network errors and surface those to the user</li>
<li>Add game tracking to the processes state, such that players can see their history</li>
<li>Consider what another app might look like that uses the chess engine as a library.
Alter the process to serve this use case, or add another process that can be spawned to do such a thing.</li>
</ul>
<p>There are also three extensions to this tutorial which dive into specific use cases which make the most of NectarOS:</p>
<ul>
<li><a href="chess_app/./chat.html">Chat</a></li>
<li><a href="chess_app/./payment.html">Payment Integration (using ETH)</a> [coming soon]</li>
<li><a href="chess_app/./llm.html">LLM Integration (play chess against the AI!)</a> [coming soon]</li>
</ul>
<p>The full code is available <a href="https://github.com/uqbar-dao/nectar/tree/main/modules/chess">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extension-1-chat"><a class="header" href="#extension-1-chat">Extension 1: Chat</a></h1>
<p>So, at this point you've got a working chess game with a frontend.
There are a number of obvious improvements to the program to be made, as listed at the end of the <a href="chess_app/./putting_everything_together.html">last chapter</a>.
The best way to understand those improvements is to start exploring other areas of the docs, such as the chapters on <a href="chess_app/../process-capabilities.html">capabilities-based security</a> and the <a href="chess_app/../networking_protocol.html">networking protocol</a>, for error handling.</p>
<p>This chapter will instead focus on how to <em>extend</em> an existing program with new functionality.
Chat is a basic feature for a chess program, but will touch the existing code in many places.
This will give you a good idea of how to extend your own programs.</p>
<p>You need to alter at least 4 things about the program:</p>
<ul>
<li>The request-response types it can handle (i.e. the protocol itself)</li>
<li>The incoming request handler for HTTP requests, to receive chats sent by <code>our</code> node</li>
<li>The outgoing websocket update, to send received chats to the frontend</li>
<li>The frontend, to display the chat</li>
</ul>
<p>Handling them in that order, first, look at the types used for request-response now:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize, Deserialize)]
enum ChessRequest {
    NewGame { white: String, black: String },
    Move { game_id: String, move_str: String },
    Resign(String),
}

#[derive(Debug, Eq, PartialEq, Serialize, Deserialize)]
enum ChessResponse {
    NewGameAccepted,
    NewGameRejected,
    MoveAccepted,
    MoveRejected,
}
<span class="boring">}</span></code></pre></pre>
<p>These types need to be exhaustive, since incoming messages will be fed into a <code>match</code> statement that uses <code>ChessRequest</code> and <code>ChessResponse</code>.
For more complex apps, one could introduce a new type that serves as an umbrella over multiple &quot;kinds&quot; of message, but since a simple chat will only be a few extra entries into the existing types, it's unnecessary for this example.</p>
<p>In order to add chat, the request type above will need a new variant, something like <code>Message(String)</code>.
It doesn't need a <code>from</code> field, since that's just the <code>source</code> of the message!</p>
<p>A new response type will make the chat more robust, by acknowledging received messages.
Something like <code>MessageAck</code> will do, with no fields — since this will be sent in response to a <code>Message</code> request, the sender will know which message it's acknowledging.</p>
<p>The new types will look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize, Deserialize)]
enum ChessRequest {
    NewGame { white: String, black: String },
    Move { game_id: String, move_str: String },
    Resign(String),
    Message(String),
}

#[derive(Debug, Eq, PartialEq, Serialize, Deserialize)]
enum ChessResponse {
    NewGameAccepted,
    NewGameRejected,
    MoveAccepted,
    MoveRejected,
    MessageAck,
}
<span class="boring">}</span></code></pre></pre>
<p>If you are modifying these types inside the finished chess app from this tutorial, your IDE should indicate that there are a few errors now: these new message types are not handled in their respective <code>match</code> statements.
Those errors, in <code>handle_chess_request</code> and <code>handle_local_request</code>, are where you'll need logic to handle messages other nodes send to this node, and messages this node sends to others, respectively.</p>
<p>In <code>handle_chess_request</code>, the app receives requests from other nodes.
A reasonable way to handle incoming messages is to add them to a vector of messages that's saved for each active game.
The frontend could reflect this by adding a chat box next to each game, and displaying all messages sent over that game's duration.</p>
<p>To do that, the <code>Game</code> struct must be altered to hold such a vector.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    pub id: String, // the node with whom we are playing
    pub turns: u64,
    pub board: String,
    pub white: String,
    pub black: String,
    pub ended: bool,
    /// messages stored in order as (sender, content)
    pub messages: Vec&lt;(String, String)&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Then in the main switch statement in <code>handle_chess_request</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
ChessRequest::Message(content) =&gt; {
    // Earlier in this code, we define game_id as the source node.
    let Some(game) = state.games.get_mut(game_id) else {
        return Err(anyhow::anyhow!(&quot;no game with {game_id}&quot;));
    };
    game.messages.push((game_id.to_string(), content.to_string()));
    Ok(())
}
...
<span class="boring">}</span></code></pre></pre>
<p>In <code>handle_local_request</code>, the app sends requests to other nodes.
Note, however, that requests to message <code>our</code>self don't really make sense — what should really happen is that the chess frontend performs a PUT request, or sends a message over a websocket, and the chess backend process turns that into a message request to the other player.
So instead of handling <code>Message</code> requests in <code>handle_local_request</code>, the process should reject or ignore them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ChessRequest::Message(_) =&gt; {
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Instead, the chess backend will handle a new kind of PUT request in <code>handle_http_request</code>, such that the local frontend can be used to send messages in games being played.</p>
<p>This is the current (super gross!!) code for handling PUT requests in <code>handle_http_request</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// on PUT: make a move
&quot;PUT&quot; =&gt; {
    let Some(blob) = get_blob() else {
        return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
    };
    let blob_json = serde_json::from_slice::&lt;serde_json::Value&gt;(&amp;blob.bytes)?;
    let Some(game_id) = blob_json[&quot;id&quot;].as_str() else {
        return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
    };
    let Some(game) = state.games.get_mut(game_id) else {
        return http::send_response(http::StatusCode::NOT_FOUND, None, vec![]);
    };
    if (game.turns % 2 == 0 &amp;&amp; game.white != our.node)
        || (game.turns % 2 == 1 &amp;&amp; game.black != our.node)
    {
        return http::send_response(http::StatusCode::FORBIDDEN, None, vec![]);
    } else if game.ended {
        return http::send_response(http::StatusCode::CONFLICT, None, vec![]);
    }
    let Some(move_str) = blob_json[&quot;move&quot;].as_str() else {
        return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
    };
    let mut board = Board::from_fen(&amp;game.board).unwrap();
    if !board.apply_uci_move(move_str) {
        // reader note: can surface illegal move to player or something here
        return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
    }
    // send the move to the other player
    // check if the game is over
    // if so, update the records
    let Ok(msg) = Request::new()
        .target((game_id, our.process.clone()))
        .body(serde_json::to_vec(&amp;ChessRequest::Move {
            game_id: game_id.to_string(),
            move_str: move_str.to_string(),
        })?)
        .send_and_await_response(5)?
    else {
        return Err(anyhow::anyhow!(
            &quot;other player did not respond properly to our move&quot;
        ));
    };
    if serde_json::from_slice::&lt;ChessResponse&gt;(msg.body())? != ChessResponse::MoveAccepted {
        return Err(anyhow::anyhow!(&quot;other player rejected our move&quot;));
    }
    // update the game
    game.turns += 1;
    if board.checkmate() || board.stalemate() {
        game.ended = true;
    }
    game.board = board.fen();
    // update state and return to FE
    let body = serde_json::to_vec(&amp;game)?;
    save_chess_state(&amp;state);
    // return the game
    http::send_response(
        http::StatusCode::OK,
        Some(HashMap::from([(
            String::from(&quot;Content-Type&quot;),
            String::from(&quot;application/json&quot;),
        )])),
        body,
    )
}
<span class="boring">}</span></code></pre></pre>
<p>Let's modify this to handle more than just making moves.
Note that there's an implicit JSON structure enforced by the code above, where PUT requests from your frontend look like this:</p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;game_id&quot;,
    &quot;move&quot;: &quot;e2e4&quot;
}
</code></pre>
<p>An easy way to allow messages is to match on whether the key <code>&quot;move&quot;</code> is present, and if not, look for the key <code>&quot;message&quot;</code>.
This could also easily be codified as a Rust type and deserialized.</p>
<p>Now, instead of assuming <code>&quot;move&quot;</code> exists, let's add a branch that handles the <code>&quot;message&quot;</code> case.
This is a modification of the code above:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// on PUT: make a move OR send a message
&quot;PUT&quot; =&gt; {
    // ... same as the previous snippet ...
    let Some(move_str) = blob_json[&quot;move&quot;].as_str() else {
        let Some(message) = blob_json[&quot;message&quot;].as_str() else {
            return http::send_response(http::StatusCode::BAD_REQUEST, None, vec![]);
        };
        // handle sending message to another player
        let Ok(_ack) = Request::new()
            .target((game_id, our.process.clone()))
            .body(serde_json::to_vec(&amp;ChessRequest::Message(message.to_string()))?)
            .send_and_await_response(5)?
        else {
            // Reader Note: handle a failed message send!
            return Err(anyhow::anyhow!(
                &quot;other player did not respond properly to our message&quot;
            ));
        };
        game.messages.push((our.node.clone(), message.to_string()));
        let body = serde_json::to_vec(&amp;game)?;
        save_chess_state(&amp;state);
        // return the game
        return http::send_response(
            http::StatusCode::OK,
            Some(HashMap::from([(
                String::from(&quot;Content-Type&quot;),
                String::from(&quot;application/json&quot;),
            )])),
            body,
        );
    };
    //
    // ... the rest of the move-handling code, same as previous snippet ...
    //
}
<span class="boring">}</span></code></pre></pre>
<p>That's it.
A simple demonstration of how to extend the functionality of a given process.
There are a few key things to keep in mind when doing this, if you want to build stable, maintainable, upgradable applications:</p>
<ul>
<li>
<p>By adding chat, you changed the format of the &quot;chess protocol&quot; implicitly declared by this program.
If a user is running the old code, their version won't know how to handle the new <code>Message</code> request type we added.
<strong>Depending on the serialization/deserialization strategy used, this might even create incompatibilities with the other types of requests.</strong>
This is a good reason to use a serialization strategy that allows for &quot;unknown&quot; fields, such as JSON.
If you're using a binary format, you'll need to be more careful about how you add new fields to existing types.</p>
</li>
<li>
<p>It's <em>okay</em> to break backwards compatibility with old versions of an app, but once a protocol is established, it's best to stick to it or start a new project.
Backwards compatibility can always be achieved by adding a version number to the request/response type(s) directly.
That's a simple way to know which version of the protocol is being used and handle it accordingly.</p>
</li>
<li>
<p>By adding a <code>messages</code> field to the <code>Game</code> struct, you changed the format of the state that gets persisted.
If a user was running the previous version of this process, and upgrades to this version, the old state will fail to properly deserialize.
If you are building an upgrade to an existing app, you should always test that the new version can appropriately handle old state.
If you have many versions, you might need to make sure that state types from <em>any</em> old version can be handled.
Again, inserting a version number that can be deserialized from persisted state is a useful strategy.
The best way to do this depends on the serialization strategy used.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kit"><a class="header" href="#kit">kit</a></h1>
<p><code>kit</code> is a tool<strong>kit</strong> that make development on NectarOS ergonomic.</p>
<p>These documents describe some ways you can use these tools, but do not attempt to be completely exhaustive.
You are encouraged to make use of the <code>--help</code> flag, which can be used for the top-level <code>kit</code>:</p>
<pre><code class="language-bash">$ kit --help
Development toolkit for NectarOS

Usage: kit &lt;COMMAND&gt;

Commands:
  boot-fake-node       Boot a fake node for development [aliases: f]
  build                Build a Nectar package [aliases: b]
  build-start-package  Build and start a Nectar package [aliases: bs]
  dev-ui               Start the web UI development server with hot reloading (same as `cd ui &amp;&amp; npm i &amp;&amp; npm start`) [aliases: d]
  inject-message       Inject a message to a running Nectar node [aliases: i]
  new                  Create a Nectar template package [aliases: n]
  run-tests            Run Nectar tests [aliases: t]
  remove-package       Remove a running package from a node [aliases: r]
  setup                Fetch &amp; setup kit dependencies
  start-package        Start a built Nectar process [aliases: s]
  update               Fetch the most recent version of kit
  help                 Print this message or the help of the given subcommand(s)

Options:
  -v, --version  Print version
  -h, --help     Print help
</code></pre>
<p>or for any of the subcommands, e.g.:</p>
<pre><code class="language-bash">kit new --help
</code></pre>
<p>The first chapter of the <a href="kit/../my_first_app/chapter_1.html">Build and Deploy an App tutorial</a> shows the <code>kit</code> tools in action.</p>
<h2 id="getting-kit"><a class="header" href="#getting-kit">Getting kit</a></h2>
<p>To get <code>kit</code>, run</p>
<pre><code class="language-bash">cargo install --git https://github.com/uqbar-dao/kit
</code></pre>
<p>To update, run that same command or</p>
<pre><code class="language-bash">kit update
</code></pre>
<p>You can find the source for <code>kit</code> at <a href="https://github.com/uqbar-dao/kit">https://github.com/uqbar-dao/kit</a>.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="kit/./boot-fake-node.html"><code>kit boot-fake-node</code></a></li>
<li><a href="kit/./new.html"><code>kit new</code></a></li>
<li><a href="kit/./build.html"><code>kit build</code></a></li>
<li><a href="kit/./start-package.html"><code>kit start-package</code></a></li>
<li><a href="kit/./dev-ui.html"><code>kit dev-ui</code></a></li>
<li><a href="kit/./inject-message.html"><code>kit inject-message</code></a></li>
<li><a href="kit/./run-tests.html"><code>kit run-tests</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kit-boot-fake-node"><a class="header" href="#kit-boot-fake-node"><code>kit boot-fake-node</code></a></h1>
<p><code>kit boot-fake-node</code> starts a &quot;fake&quot; (i.e. not connected to the live network) node, e.g.,</p>
<pre><code class="language-bash">kit boot-fake-node
</code></pre>
<p>By default, <code>boot-fake-node</code> fetches a prebuilt binary and launches the node using it.
Alternatively, <code>boot-fake-node</code> can use a local binary or build a local Nectar core repo and use the resulting binary.</p>
<h2 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h2>
<p>You can start a network of fake nodes that can communicate with each other (but not the live network).
You'll need to start a new terminal for each fake node.
For example, to start two fake nodes, <code>fake.nec</code> and <code>fake2.nec</code>:</p>
<pre><code class="language-bash">kit boot-fake-node

# In a new terminal
kit boot-fake-node -h /tmp/nectar-fake-node-2 -p 8081 -f fake2.nec
</code></pre>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>Fake nodes make development easier.
A fake node is not connected to the network, but otherwise behaves the same as a live node.
Fake nodes are connected to each other on your local machine through a network router that passes messages between them.
Fake nodes also clean up after themselves, so you don't have to worry about state from a previous iterations messing up the current one.
Thus, fake nodes are an excellent testing ground during development for fast iteration.</p>
<p>There are some cases where fake nodes are not appropriate.
One is for testing persistence of a package.
Because fake nodes clean up after themselves, they will not persist data from run to run.
Another weakness of fake nodes is also their strength: they are not connected to the live network.
Though this lack of connectivity makes them easy to spin up and throw away, the downside is no access to services on the network, like remote LLMs.</p>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<pre><code class="language-bash">$ kit f --help
Boot a fake node for development

Usage: kit boot-fake-node [OPTIONS]

Options:
  -r, --runtime-path &lt;PATH&gt;
          Path to Nectar core repo or runtime binary (overrides --version)
  -v, --version &lt;VERSION&gt;
          Version of Nectar binary to use (overridden by --runtime-path) [default: 0.4.0]
  -p, --port &lt;NODE_PORT&gt;
          The port to run the fake node on [default: 8080]
  -h, --home &lt;HOME&gt;
          Where to place the home directory for the fake node [default: /tmp/nectar-fake-node]
  -f, --fake-node-name &lt;NODE_NAME&gt;
          Name for fake node [default: fake.nec]
      --network-router-port &lt;NETWORK_ROUTER_PORT&gt;
          The port to run the network router on (or to connect to) [default: 9001]
      --rpc &lt;RPC_ENDPOINT&gt;
          Ethereum RPC endpoint (wss://)
      --persist
          If set, do not delete node home after exit
      --password &lt;PASSWORD&gt;
          Password to login [default: secret]
      --help
          Print help
</code></pre>
<h3 id="--runtime-path"><a class="header" href="#--runtime-path"><code>--runtime-path</code></a></h3>
<p>Pass to run a local binary or build a local Nectar core repo and use the resulting binary, e.g.</p>
<pre><code class="language-bash">kit boot-fake-node --runtime-path ~/git/nectar
</code></pre>
<p>for a system with the Nectar core repo living at <code>~/git/nectar</code>.</p>
<p>Overrides <code>--version</code>.</p>
<h3 id="--version"><a class="header" href="#--version"><code>--version</code></a></h3>
<p>Fetch and run a specific version of the binary; defaults to most recent version (here, <code>0.5.0</code>).
Overridden by <code>--runtime-path</code>.</p>
<h3 id="--port"><a class="header" href="#--port"><code>--port</code></a></h3>
<p>Run the fake node on this port; defaults to <code>8080</code>.</p>
<h3 id="--home"><a class="header" href="#--home"><code>--home</code></a></h3>
<p>Path to place fake node home directory at; defaults to <code>/tmp/nectar-fake-node</code>.</p>
<h3 id="--fake-node-name"><a class="header" href="#--fake-node-name"><code>--fake-node-name</code></a></h3>
<p>The name of the fake node; defaults to <code>fake.nec</code>.</p>
<h3 id="--network-router-port"><a class="header" href="#--network-router-port"><code>--network-router-port</code></a></h3>
<p>Run the fake node network router on this port; defaults to <code>9001</code>.
Additional fake nodes must point to the same port to connect to the fake node network.</p>
<h3 id="--rpc"><a class="header" href="#--rpc"><code>--rpc</code></a></h3>
<p>The Ethereum RPC endpoint to use, if desired.</p>
<h3 id="--persist"><a class="header" href="#--persist"><code>--persist</code></a></h3>
<p>Persist the node home directory after exit, rather than cleaning it up.</p>
<h3 id="--password"><a class="header" href="#--password"><code>--password</code></a></h3>
<p>The password of the fake node; defaults to <code>secret</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kit-new"><a class="header" href="#kit-new"><code>kit new</code></a></h1>
<p><code>kit new</code> creates a Nectar package template at the specified path, e.g.,</p>
<pre><code class="language-bash">kit new foo
</code></pre>
<p>creates the default template (a Rust chat app with no UI) in the <code>foo/</code> directory.</p>
<h2 id="example-usage-1"><a class="header" href="#example-usage-1">Example Usage</a></h2>
<pre><code class="language-bash"># Create the default template: rust chat with no UI
kit new my_rust_chat

# Create rust chat with UI
kit new my_rust_chat_with_ui --ui

# Create fibonacci in python
kit new my_py_fib -l python -t fibonacci
</code></pre>
<h2 id="discussion-1"><a class="header" href="#discussion-1">Discussion</a></h2>
<p>You can create a variety of templates using <code>kit new</code>.
Currently, three languages are supported: <code>rust</code> (the default), <code>python</code>, and <code>javascript</code>.
Two templates are currently supported: <code>chat</code>, a simple chat application, and <code>fibonacci</code>, which computes Fibonacci numbers.
In addition, some subset of these templates also have a UI-enabled version.</p>
<p>The following table describes the matrix of &quot;Exists/Has UI-enabled version&quot; for each template/language combination:</p>
<h3 id="existshas-ui-enabled-vesion"><a class="header" href="#existshas-ui-enabled-vesion">Exists/Has UI-enabled vesion</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Language</th><th><code>chat</code></th><th><code>echo</code></th><th><code>fibonacci</code></th></tr></thead><tbody>
<tr><td><code>rust</code></td><td>yes/yes</td><td>yes/no</td><td>yes/no</td></tr>
<tr><td><code>python</code></td><td>yes/no</td><td>yes/no</td><td>yes/no</td></tr>
<tr><td><code>javascript</code></td><td>yes/no</td><td>yes/no</td><td>yes/no</td></tr>
</tbody></table>
</div>
<h2 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h2>
<pre><code class="language-bash">$ kit n --help
Create a Nectar template package

Usage: kit new [OPTIONS] &lt;DIR&gt;

Arguments:
  &lt;DIR&gt;  Path to create template directory at

Options:
  -a, --package &lt;PACKAGE&gt;      Name of the package [default: DIR]
  -u, --publisher &lt;PUBLISHER&gt;  Name of the publisher [default: template.nec]
  -l, --language &lt;LANGUAGE&gt;    Programming language of the template [default: rust] [possible values: rust, python, javascript]
  -t, --template &lt;TEMPLATE&gt;    Template to create [default: chat] [possible values: chat, echo, fibonacci]
      --ui                     If set, use the template with UI
  -h, --help                   Print help
</code></pre>
<h3 id="positional-arg-dir"><a class="header" href="#positional-arg-dir">Positional arg: <code>DIR</code></a></h3>
<p>Where to create the template package.
The package name is set to this by default if not supplied by <code>--package</code>.</p>
<h3 id="--package"><a class="header" href="#--package"><code>--package</code></a></h3>
<p>Name of the package; defaults to <code>DIR</code>.
Must be URL-safe.</p>
<h3 id="--publisher"><a class="header" href="#--publisher"><code>--publisher</code></a></h3>
<p>Name of the publisher; defaults to <code>template.uq</code>.
Must be URL-safe.</p>
<h3 id="--language"><a class="header" href="#--language"><code>--language</code></a></h3>
<p>Template language; defaults to <code>rust</code>.
Currently support <code>rust</code>, <code>python</code>, and <code>javascript</code>.</p>
<h3 id="--template"><a class="header" href="#--template"><code>--template</code></a></h3>
<p>Which template to create; defaults to <code>chat</code>.
Currently have <code>chat</code>, a simple chat application, <code>echo</code>, an application that prints and responds with the received message, and <code>fibonacci</code>, a naive fibonacci-number-computer.</p>
<h3 id="--ui"><a class="header" href="#--ui"><code>--ui</code></a></h3>
<p>Create the template with a UI.
Currently, only <code>rust</code> <code>chat</code> has UI support.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kit-build"><a class="header" href="#kit-build"><code>kit build</code></a></h1>
<p><code>kit build</code> builds the indicated package directory, or the current working directory if none supplied, e.g.,</p>
<pre><code class="language-bash">kit build foo
</code></pre>
<p>or</p>
<pre><code class="language-bash">kit build
</code></pre>
<p><code>kit build</code> builds each process in the package and places the <code>.wasm</code> binaries into the <code>pkg/</code> directory for installation.
It automatically detects what language each process is, and builds it appropriately (from amongst the supported <code>rust</code>, <code>python</code>, and <code>javascript</code>).</p>
<h2 id="discussion-2"><a class="header" href="#discussion-2">Discussion</a></h2>
<p><code>kit build</code> builds a Nectar package directory.
Specifically, it iterates through all directories within the given package directory and looks for <code>src/lib.??</code>, where the <code>??</code> is the file extension.
Currently, <code>rs</code>, <code>py</code>, and <code>js</code> are supported, corresponding to processes written in <code>rust</code>, <code>python</code>, and <code>javascript</code>, respectively.
Note that a package may have more than one process and those processes need not be written in the same language.</p>
<p>After compiling each process, it places the output <code>.wasm</code> binaries within the <code>pkg/</code> directory at the top-level of the given package directory.
The <code>pkg/</code> directory is the one that is zipped and injected into the node by <a href="kit/./start-package.html"><code>kit start-package</code></a>.
Thus, after <code>build</code>ing, the package is ready for <code>start-package</code>.</p>
<p><code>kit build</code> also builds the UI if found in <code>ui/</code>.
There must exist a <code>ui/package.json</code> file with <code>scripts</code> defined like:</p>
<pre><code>&quot;build&quot;: &quot;tsc &amp;&amp; vite build&quot;,
&quot;copy&quot;: &quot;mkdir -p ../pkg/ui &amp;&amp; rm -rf ../pkg/ui/* &amp;&amp; cp -r dist/* ../pkg/ui/&quot;,
&quot;build:copy&quot;: &quot;npm run build &amp;&amp; npm run copy&quot;,
</code></pre>
<p>To both <code>build</code> and <code>start-package</code> in one command, use <code>kit build-start-package</code>.</p>
<h2 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h2>
<pre><code class="language-bash">$ kit b --help
Build a Nectar package

Usage: kit build [OPTIONS] [DIR]

Arguments:
  [DIR]  The package directory to build [default: /home/nick/git/kit]

Options:
      --ui-only          If set, build ONLY the web UI for the process
  -q, --quiet            If set, do not print build stdout/stderr
  -s, --skip-deps-check  If set, do not check for dependencies
  -h, --help             Print help
</code></pre>
<h3 id="optional-positional-arg-dir"><a class="header" href="#optional-positional-arg-dir">Optional positional arg: <code>DIR</code></a></h3>
<p>The package directory to build; defaults to the current working directory.</p>
<h3 id="--ui-only"><a class="header" href="#--ui-only"><code>--ui-only</code></a></h3>
<p>Build ONLY the UI for a package with a UI.
Otherwise, for a package with a UI, both the package and the UI will be built.</p>
<h3 id="--quiet"><a class="header" href="#--quiet"><code>--quiet</code></a></h3>
<p>Don't print the build stdout/stderr.</p>
<h3 id="--skip-deps-check"><a class="header" href="#--skip-deps-check"><code>--skip-deps-check</code></a></h3>
<p>Don't check for dependencies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kit-start-package"><a class="header" href="#kit-start-package"><code>kit start-package</code></a></h1>
<p><code>kit start-package</code> installs and starts the indicated package directory (or current working directory) on the given Nectar node, e.g.,</p>
<pre><code class="language-bash">kit start-package foo
</code></pre>
<p>or</p>
<pre><code class="language-bash">kit start-package
</code></pre>
<h2 id="discussion-3"><a class="header" href="#discussion-3">Discussion</a></h2>
<p><code>kit start-package</code> injects a built package into the given node and starts it.
<code>start-package</code> is designed to be used after a package has been built with <a href="kit/./build.html"><code>kit build</code></a>.
Specifically, it first zips and injects the <code>pkg/</code> directory within the given package directory, which contains metadata about the package for the node as well as the <code>.wasm</code> binaries for each process.
Then it injects a message to the node to start the package.</p>
<p>To both <code>build</code> and <code>start-package</code> in one command, use <code>kit build-start-package</code>.</p>
<h2 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h2>
<pre><code class="language-bash">$ kit s --help
Start a built Nectar process

Usage: kit start-package [OPTIONS] [DIR]

Arguments:
  [DIR]  The package directory to build [default: /home/nick/git/kit]

Options:
  -p, --port &lt;NODE_PORT&gt;  Node port: for use on localhost (overridden by URL) [default: 8080]
  -u, --url &lt;URL&gt;         Node URL (overrides NODE_PORT)
  -h, --help              Print help
</code></pre>
<h3 id="optional-positional-arg-dir-1"><a class="header" href="#optional-positional-arg-dir-1">Optional positional arg: <code>DIR</code></a></h3>
<p>The package directory to install and start on the node; defaults to current working directory.</p>
<h3 id="--port-1"><a class="header" href="#--port-1"><code>--port</code></a></h3>
<p>For nodes running on localhost, the port of the node; defaults to <code>8080</code>.
<code>--port</code> is overridden by <code>--url</code> if both are supplied.</p>
<h3 id="--url"><a class="header" href="#--url"><code>--url</code></a></h3>
<p>The URL the node is hosted at.
Can be either localhost or remote.
<code>--url</code> overrides <code>--port</code> if both are supplied.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kit-remove-package"><a class="header" href="#kit-remove-package"><code>kit remove-package</code></a></h1>
<p><code>kit remove-package</code> removes an installed package from the given node.
If passed an optional positional argument <code>DIR</code>, the path to a package directory, the <code>pkg/metadata.json</code> therein is parsed and that package is removed from the node.
If no arguments are provided, the same process happens for the current working directory.
Alternatively, a <code>--package</code> and <code>--publisher</code> can be provided as arguments, and that package will be removed.</p>
<p>For example,</p>
<pre><code class="language-bash">kit remove-package foo
</code></pre>
<p>or</p>
<pre><code class="language-bash">kit remove-package -package foo --publisher template.uq
</code></pre>
<h2 id="discussion-4"><a class="header" href="#discussion-4">Discussion</a></h2>
<p><code>kit start-package</code> injects a built package into the given node and starts it.
<code>start-package</code> is designed to be used after a package has been built with <a href="kit/./build.html"><code>kit build</code></a>.
Specifically, it first zips and injects the <code>pkg/</code> directory within the given package directory, which contains metadata about the package for the node as well as the <code>.wasm</code> binaries for each process.
Then it injects a message to the node to start the package.</p>
<h2 id="arguments-4"><a class="header" href="#arguments-4">Arguments</a></h2>
<pre><code class="language-bash">$ kit r --help
Remove a running package from a node

Usage: kit remove-package [OPTIONS] [DIR]

Arguments:
  [DIR]  The package directory to remove (Overridden by PACKAGE/PUBLISHER) [default: /home/nick/git/kit]

Options:
  -a, --package &lt;PACKAGE&gt;      Name of the package (Overrides DIR)
      --publisher &lt;PUBLISHER&gt;  Name of the publisher (Overrides DIR)
  -p, --port &lt;NODE_PORT&gt;       Node port: for use on localhost (overridden by URL) [default: 8080]
  -u, --url &lt;URL&gt;              Node URL (overrides NODE_PORT)
  -h, --help                   Print help
</code></pre>
<h3 id="optional-positional-arg-dir-2"><a class="header" href="#optional-positional-arg-dir-2">Optional positional arg: <code>DIR</code></a></h3>
<p>The package directory to install and start on the node; defaults to current working directory.</p>
<h3 id="--package-1"><a class="header" href="#--package-1"><code>--package</code></a></h3>
<p>The package name of the package to be removed; default is derived from <code>DIR</code>.</p>
<h3 id="--publisher-1"><a class="header" href="#--publisher-1"><code>--publisher</code></a></h3>
<p>The publisher of the package to be removed; default is derived from <code>DIR</code>.</p>
<h3 id="--port-2"><a class="header" href="#--port-2"><code>--port</code></a></h3>
<p>For nodes running on localhost, the port of the node; defaults to <code>8080</code>.
<code>--port</code> is overridden by <code>--url</code> if both are supplied.</p>
<h3 id="--url-1"><a class="header" href="#--url-1"><code>--url</code></a></h3>
<p>The URL the node is hosted at.
Can be either localhost or remote.
<code>--url</code> overrides <code>--port</code> if both are supplied.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kit-dev-ui"><a class="header" href="#kit-dev-ui"><code>kit dev-ui</code></a></h1>
<p><code>kit dev-ui</code> starts a web development server with hot reloading for the indicated UI-enabled package (or the current working directory), e.g.,</p>
<pre><code class="language-bash">kit dev-ui foo
</code></pre>
<p>or</p>
<pre><code class="language-bash">kit dev-ui
</code></pre>
<h2 id="arguments-5"><a class="header" href="#arguments-5">Arguments</a></h2>
<pre><code class="language-bash">$ kit d --help
Start the web UI development server with hot reloading (same as `cd ui &amp;&amp; npm i &amp;&amp; npm start`)

Usage: kit dev-ui [OPTIONS] [DIR]

Arguments:
  [DIR]  The package directory to build (must contain a `ui` directory) [default: /home/nick/git/kit]

Options:
  -p, --port &lt;NODE_PORT&gt;  Node port: for use on localhost (overridden by URL) [default: 8080]
  -u, --url &lt;URL&gt;         Node URL (overrides NODE_PORT)
  -s, --skip-deps-check   If set, do not check for dependencies
  -h, --help              Print help
</code></pre>
<h3 id="optional-positional-arg-dir-3"><a class="header" href="#optional-positional-arg-dir-3">Optional positional arg: <code>DIR</code></a></h3>
<p>The UI-enabled package directory to serve; defaults to current working directory.</p>
<h3 id="--port-3"><a class="header" href="#--port-3"><code>--port</code></a></h3>
<p>For nodes running on localhost, the port of the node; defaults to <code>8080</code>.
<code>--port</code> is overridden by <code>--url</code> if both are supplied.</p>
<h3 id="--url-2"><a class="header" href="#--url-2"><code>--url</code></a></h3>
<p>The URL the node is hosted at.
Can be either localhost or remote.
<code>--url</code> overrides <code>--port</code> if both are supplied.</p>
<h3 id="--skip-deps-check-1"><a class="header" href="#--skip-deps-check-1"><code>--skip-deps-check</code></a></h3>
<p>Don't check for dependencies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kit-inject-message"><a class="header" href="#kit-inject-message"><code>kit inject-message</code></a></h1>
<p><code>kit inject-message</code> injects the given message to the node running at given port/URL, e.g.,</p>
<pre><code class="language-bash">kit inject-message foo:foo:template.nec '{&quot;Send&quot;: {&quot;target&quot;: &quot;fake2.nec&quot;, &quot;message&quot;: &quot;hello world&quot;}}'
</code></pre>
<h2 id="discussion-5"><a class="header" href="#discussion-5">Discussion</a></h2>
<p><code>kit inject-message</code> injects the given message into the given node.
It is useful for:</p>
<ol>
<li>Testing processes from the outside world during development</li>
<li>Injecting data into the node</li>
<li>Combining the above with <code>bash</code> or other scripting.
For example, using the <a href="kit/inject-message.html#--blob"><code>--blob</code></a> flag you can directly inject the contents of a file.
You can script in the outside world, dump the result to a file, and inject it with <code>inject-message</code>.</li>
</ol>
<p>By default, <code>inject-message</code> expects a Response from the target process.
To instead &quot;fire and forget&quot; a message and exit immediately, use the <a href="kit/inject-message.html#--non-block"><code>--non-block</code></a> flag.</p>
<h2 id="arguments-6"><a class="header" href="#arguments-6">Arguments</a></h2>
<pre><code class="language-bash">$ kit i --help
Inject a message to a running Nectar node

Usage: kit inject-message [OPTIONS] &lt;PROCESS&gt; &lt;BODY_JSON&gt;

Arguments:
  &lt;PROCESS&gt;    PROCESS to send message to
  &lt;BODY_JSON&gt;  Body in JSON format

Options:
  -p, --port &lt;NODE_PORT&gt;  Node port: for use on localhost (overridden by URL) [default: 8080]
  -u, --url &lt;URL&gt;         Node URL (overrides NODE_PORT)
  -n, --node &lt;NODE_NAME&gt;  Node ID (default: our)
  -b, --blob &lt;PATH&gt;       Send file at Unix path as bytes blob
  -l, --non-block         If set, don't block on the full node response
  -h, --help              Print help
</code></pre>
<h3 id="first-positional-arg-process"><a class="header" href="#first-positional-arg-process">First positional arg: <code>PROCESS</code></a></h3>
<p>The process to send the injected message to in the form of <code>&lt;process_name&gt;:&lt;package_name&gt;:&lt;publisher&gt;</code>.</p>
<h3 id="second-positional-arg-body_json"><a class="header" href="#second-positional-arg-body_json">Second positional arg: <code>BODY_JSON</code></a></h3>
<p>The message body.</p>
<h3 id="--port-4"><a class="header" href="#--port-4"><code>--port</code></a></h3>
<p>For nodes running on localhost, the port of the node; defaults to <code>8080</code>.
<code>--port</code> is overridden by <code>--url</code> if both are supplied.</p>
<h3 id="--url-3"><a class="header" href="#--url-3"><code>--url</code></a></h3>
<p>The URL the node is hosted at.
Can be either localhost or remote.
<code>--url</code> overrides <code>--port</code> if both are supplied.</p>
<h3 id="--node"><a class="header" href="#--node"><code>--node</code></a></h3>
<p>Node to target (i.e. the node portion of the address).
E.g.</p>
<pre><code class="language-bash">kit inject-message foo:foo:template.nec '{&quot;Send&quot;: {&quot;target&quot;: &quot;fake.nec&quot;, &quot;message&quot;: &quot;wow, it works!&quot;}}' --node fake2.nec
</code></pre>
<p>sent to the port running <code>fake.nec</code> will forward the message from <code>fake.nec</code>s HTTP server to <code>fake2@foo:foo:template.nec</code>.</p>
<h3 id="--blob"><a class="header" href="#--blob"><code>--blob</code></a></h3>
<p>Path to file to include as <code>lazy_load_blob</code>.</p>
<h3 id="--non-block"><a class="header" href="#--non-block"><code>--non-block</code></a></h3>
<p>Don't block waiting for a Response from target process.
Instead, inject the message and immediately return.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kit-run-tests"><a class="header" href="#kit-run-tests"><code>kit run-tests</code></a></h1>
<p><code>kit run-tests</code> runs the tests specified by the given <code>.toml</code> file, or <code>tests.toml</code>, e.g.,</p>
<pre><code class="language-bash">kit run-tests my_tests.toml
</code></pre>
<p>or</p>
<pre><code class="language-bash">kit run-tests
</code></pre>
<p>to run the current working directory's <code>tests.toml</code>.</p>
<h2 id="discussion-6"><a class="header" href="#discussion-6">Discussion</a></h2>
<p><code>kit run-tests</code> runs a series of tests specified  by <a href="kit/run-tests.html#teststoml">a <code>.toml</code> file</a>.
Each test is run in a fresh environment of one or more fake nodes.
A test can setup one or more packages before running a series of test packages.
Each test package is <a href="kit/run-tests.html#test-package-format">a single-process package that accepts and responds with certain messages</a>.</p>
<p>Tests are orchestrated from the outside of the node by <code>kit run-tests</code> and run on the inside of the node by the <code>tester</code> core package.
For a given test, the <code>tester</code> package runs the specified test packages in order.
Each test package must respond to the <code>tester</code> package with a <code>Pass</code> or <code>Fail</code>.
The <code>tester</code> package stops on the first <code>Fail</code>, or responds with a <code>Pass</code> if all tests <code>Pass</code>.
If a given test <code>Pass</code>es, the next test in the series is run.</p>
<h2 id="arguments-7"><a class="header" href="#arguments-7">Arguments</a></h2>
<pre><code class="language-bash">$ kit t --help
Run Nectar tests

Usage: kit run-tests [PATH]

Arguments:
  [PATH]  Path to tests configuration file [default: tests.toml]

Options:
  -h, --help  Print help
</code></pre>
<h3 id="optional-positional-arg-path"><a class="header" href="#optional-positional-arg-path">Optional positional arg: <code>PATH</code></a></h3>
<p>Path to <a href="https://toml.io/en/"><code>.toml</code></a> file specifying tests to run; defaults to <code>tests.toml</code> in current working directory.</p>
<h2 id="teststoml"><a class="header" href="#teststoml"><code>tests.toml</code></a></h2>
<p>The testing protocol is specified by a <code>.toml</code> file.
Consider the following example, from <a href="kit/">core tests</a>:</p>
<pre><code class="language-toml">runtime = { FetchVersion = &quot;0.5.0&quot; }
runtime_build_verbose = false


[[tests]]

setup_package_paths = [&quot;chat&quot;]
test_packages = [
    { path = &quot;chat_test&quot;, &quot;grant_capabilities&quot; = [&quot;chat:chat:nectar&quot;] }
    { path = &quot;key_value_test&quot;, grant_capabilities = [] },
    { path = &quot;sqlite_test&quot;, grant_capabilities = [] },
]
package_build_verbose = false
timeout_secs = 5
network_router = { port = 9001, defects = &quot;None&quot; }

[[tests.nodes]]

port = 8080
home = &quot;home/first&quot;
fake_node_name = &quot;first.nec&quot;
runtime_verbose = false

[[tests.nodes]]

port = 8081
home = &quot;home/second&quot;
fake_node_name = &quot;second.nec&quot;
runtime_verbose = false


[[tests]]

setup_package_paths = []
test_packages = [
    { path = &quot;key_value_test&quot;, grant_capabilities = [] }
]
package_build_verbose = false
timeout_secs = 5
network_router = { port = 9001, defects = &quot;None&quot; }

[[tests.nodes]]

port = 8080
home = &quot;home/first&quot;
fake_node_name = &quot;first.nec&quot;
runtime_verbose = false
</code></pre>
<p>which has the directory structure</p>
<pre><code class="language-bash">core_tests
├── chat
│   ├── chat
│   │   ├── Cargo.lock
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   └── pkg
│       ├── manifest.json
│       └── metadata.json
├── chat_test
│   ├── chat_test
│   │   ├── Cargo.lock
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── lib.rs
│   │       └── tester_types.rs
│   └── pkg
│       ├── manifest.json
│       └── metadata.json
├── key_value_test
│   ├── key_value_test
│   │   ├── Cargo.lock
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── key_value_types.rs
│   │       ├── lib.rs
│   │       └── tester_types.rs
│   └── pkg
│       ├── key_value_test.wasm
│       ├── manifest.json
│       └── metadata.json
├── sqlite_test
│   ├── pkg
│   │   ├── manifest.json
│   │   └── metadata.json
│   └── sqlite_test
│       ├── Cargo.lock
│       ├── Cargo.toml
│       └── src
│           ├── lib.rs
│           ├── sqlite_types.rs
│           └── tester_types.rs
└── tests.toml

</code></pre>
<p>The top-level consists of three fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Value Type</th></tr></thead><tbody>
<tr><td><a href="kit/run-tests.html#runtime"><code>runtime</code></a></td><td><code>{ FetchVersion = &quot;&lt;version&gt;&quot; }</code> or <code>{ RepoPath = &quot;~/path/to/repo&quot; }</code></td></tr>
<tr><td><a href="kit/run-tests.html#runtime_build_verbose"><code>runtime_build_verbose</code></a></td><td>Boolean</td></tr>
<tr><td><a href="kit/run-tests.html#tests"><code>tests</code></a></td><td>Array of Tables</td></tr>
</tbody></table>
</div>
<h3 id="runtime"><a class="header" href="#runtime"><code>runtime</code></a></h3>
<p>Specify the runtime to use for the tests.
Two option variants are supported.
An option variant is specified with the key of an Table.</p>
<p>The first, and recommended is <code>FetchVersion</code>.
The value of the <code>FetchVersion</code> Table is the version number to fetch and use (or <code>&quot;latest&quot;</code>).
That version of the runtime binary will be fetched from remote if not found locally.</p>
<p>The second is <code>RepoPath</code>.
The value of the <code>RepoPath</code> Table is the path to a local copy of the runtime repo.
Given a valid path, that repo will be compiled and used.</p>
<h3 id="runtime_build_verbose"><a class="header" href="#runtime_build_verbose"><code>runtime_build_verbose</code></a></h3>
<p>Whether to print <code>stdout</code>/<code>stderr</code> from building the given repo, if given <code>RepoPath</code> <code>runtime</code>.</p>
<h3 id="tests"><a class="header" href="#tests"><code>tests</code></a></h3>
<p>An Array of Tables.
Each Table specifies one test to run.
That test consists of:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Value Type</th><th>Value Description</th></tr></thead><tbody>
<tr><td><code>setup_package_paths</code></td><td>Array of Paths</td><td>Paths to packages to load into all nodes before running test</td></tr>
<tr><td><code>test_packages</code></td><td>Array of Tables</td><td>Table containing <code>path</code> (to test package) and <code>grant_capabilities</code> (which will be granted by test package)</td></tr>
<tr><td><code>package_build_verbose</code></td><td>Boolean</td><td>Whether to print <code>stdout</code>/<code>stderr</code> from building the setup &amp; test packages</td></tr>
<tr><td><code>timeout_secs</code></td><td>Integer &gt; 0</td><td>Timeout for this entire series of test packages</td></tr>
<tr><td><code>network_router</code></td><td>Table</td><td>Table containing <code>port</code> (of network router server) and <code>defects</code> (to simulate network weather/defects; currently only <code>&quot;None&quot;</code> accepted)</td></tr>
<tr><td><a href="kit/run-tests.html#nodes"><code>nodes</code></a></td><td>Array of Tables</td><td>Each Table specifies configuration of one node to spin up for test</td></tr>
</tbody></table>
</div>
<p>Each test package is <a href="kit/run-tests.html#test-package-format">a single-process package that accepts and responds with certain messages</a>.</p>
<h4 id="nodes"><a class="header" href="#nodes"><code>nodes</code></a></h4>
<p>Each test specifies one or more nodes: fake nodes that the tests will be run on.
The first node is the &quot;master&quot; node that will orchestrate the test.
Each node is specified by a Table.
That Table consists of:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Value Type</th><th>Value Description</th></tr></thead><tbody>
<tr><td><code>port</code></td><td>Integer &gt; 0</td><td>Port to run node on (must not be already bound)</td></tr>
<tr><td><code>home</code></td><td>Path</td><td>Where to place node's home directory</td></tr>
<tr><td><code>fake_node_name</code></td><td>String</td><td>Name of fake node</td></tr>
<tr><td><code>password</code></td><td>String or Null</td><td>Password of fake node (default: <code>&quot;secret&quot;</code>)</td></tr>
<tr><td><code>rpc</code></td><td>String or Null</td><td><a href="kit/../login.html#starting-the-nectar-node"><code>wss://</code> URI of Ethereum RPC</a></td></tr>
<tr><td><code>runtime_verbose</code></td><td>Boolean</td><td>Whether to print <code>stdout</code>/<code>stderr</code> from the node</td></tr>
</tbody></table>
</div>
<h2 id="test-package-format"><a class="header" href="#test-package-format">Test package format</a></h2>
<p>A test package is a single-process package that accepts and responds with certain messages.
Those certain messages are:</p>
<pre><code class="language-json">{
    &quot;Run&quot;: {
        &quot;input_node_names&quot;: [
            &quot;&lt;master_node_name&gt;&quot;,
            &quot;&lt;second_node_name&gt;&quot;,
            ...
        ],
        test_timeout: &lt;number&gt;
    }
}
</code></pre>
<p>which starts the test,</p>
<pre><code class="language-json">&quot;Pass&quot;
</code></pre>
<p>which should be sent as a Response after the test has completed successfully, and</p>
<pre><code class="language-json">{
    &quot;Fail&quot;: {
        &quot;test&quot;: &quot;test_where_error_occurred&quot;,
        &quot;file&quot;: &quot;file_where_error_occurred&quot;,
        &quot;line&quot;: &lt;line_number_where_failure_occurred&gt;,
        &quot;column&quot;: &lt;column_number_where_failure_occurred&gt;
    }
}
</code></pre>
<p>which should be sent as a Response if the test fails.</p>
<p>In the Rust language, there is a helper macro for failutres in <code>tester_types.rs</code>.
That file can be found in the core <code>modules/tester/tester_types.rs</code>.
The macro is <code>fail!()</code>: it automatically sends the Response, filing out the fields, and exits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cookbook-overview"><a class="header" href="#cookbook-overview">Cookbook Overview</a></h1>
<p>The Cookbook is a collection of how-tos for common programming techniques that may be useful for the Nectar developer.
The entries include a basic explanation as well as some bare bones sample code to illustrate how you might use the technique.
Think of them as individual recipes that can be combined to form the outline for any variety of useful, interesting applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawning-and-managing-child-processes"><a class="header" href="#spawning-and-managing-child-processes">Spawning and Managing Child Processes</a></h1>
<p>In NectarOS, a &quot;parent&quot; process can create additional processes, known as &quot;children&quot;.
These child processes are particularly useful for handling intensive tasks (referred to as &quot;workers&quot;) that require long computation times without hindering the performance of the main application.
They are also beneficial for segregating distinct logical components.
Each process is its own subdirectory within the package.
E.g., for Rust processes, each is its own Rust project, complete with a separate Cargo.toml file.</p>
<p>Your package's file structure might resemble the following:</p>
<pre><code>my-package/
├─ pkg/
│  ├─ metadata.json
│  ├─ manifest.json
├─ parent/
│  ├─ src/
│  ├─ Cargo.toml
│  ├─ Cargo.lock
├─ child/
│  ├─ src/
│  ├─ Cargo.toml
│  ├─ Cargo.lock
</code></pre>
<p>To initiate a child process, use the <code>spawn</code> function from <code>nectar_process_lib</code>.
The following example demonstrates a basic parent process whose sole function is to spawn a child process and grant it the ability to send messages using <code>http_client</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// imports
use nectar_process_lib::{println, spawn, Address, Capability, OnExit};

// boilerplate to generate types
wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

struct Component;

// parent app component boilerplate
impl Guest for Component {
    fn init(our: String) {
        // unpack the address string and print it to the terminal
        let our = Address::from_str(&amp;our).unwrap();
        println!(&quot;{our}: start&quot;);

        // this function actually spawns the child process
        let spawned_process_id: ProcessId = match spawn(
            // name of the child process
            Some(&quot;spawned_child_process&quot;.to_string()),
            // path to find the compiled Wasm file for the child process
            &quot;/child.wasm&quot;,
            // what to do when this process crashes/panics/finishes
            OnExit::None,
            // capabilities to pass onto the child
            vec![
                // the parents app already has the capability to message http_client here
                // so we are just passing it onto the child
                Capability {
                    issuer: Address::new(&amp;our.node, ProcessId::from_str(&quot;http_client:sys:nectar&quot;).unwrap()),
                    params: &quot;\&quot;messaging\&quot;&quot;.into(),
                }
            ]),
            vec![],
            // this process will not be public
            false,
        ) {
            Ok(spawned_process_id) =&gt; spawned_process_id,
            Err(e) =&gt; {
                panic!(&quot;couldn't spawn&quot;); //  TODO
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The child process can be anything, for simplicity's sake let's make it a degenerate process that does nothing but print it's name and die:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// same boilerplate as above
use nectar_process_lib::{println, Address};

wit_bindgen::generate!({
    // note that the WIT file can be in any directory
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

struct Component;

// child app component boilerplate
impl Guest for Component {
    fn init(our: String) {
        // unpack the address string and print it to the terminal
        let our = Address::from_str(&amp;our).unwrap();
        println!(&quot;{our}: start&quot;);

        // print something else out
        println!(&quot;this is the child process, wow!&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The spawn function in Nectar comprises several parameters, each serving a specific purpose in the process creation:</p>
<ul>
<li>
<p><code>name: Option&lt;String&gt;</code>: This parameter specifies the name of the process.
If set to None, the process is automatically assigned a numerical identifier, resulting in a ProcessId formatted like <code>123456789:my-package:john.nec</code>.</p>
</li>
<li>
<p><code>wasm_path: String</code>: Indicates the location of the compiled WebAssembly (Wasm) bytecode for the process.
This path should be relative to the <code>/pkg</code> directory in your project.</p>
</li>
<li>
<p><code>on_exit: OnExit</code>: Determines the behavior of the process upon termination, whether due to completion, a crash, or a panic.
OnExit is an enum with three potential values:</p>
<ul>
<li><code>None</code>: The process will take no action upon exiting.</li>
<li><code>Restart</code>: The process will automatically restart after termination.</li>
<li><code>Requests: Vec&lt;(Address, Request, Option&lt;LazyLoadBlob&gt;)&gt;</code>: Upon process termination, a series of predefined requests will be dispatched.</li>
</ul>
</li>
<li>
<p><code>request_capabilities: Vec&lt;Capability&gt;</code>: This argument is for passing immediate capabilities to the child process.
As illustrated in the provided example, the parent's <code>http_client</code> messaging capability was shared with the child.</p>
</li>
<li>
<p><code>grant_capabilities: Vec&lt;ProcessId&gt;</code>: This argument is for granting capabilities to other processes on start.
However, for security reasons, you limit it just to the <code>&quot;messaging&quot;</code> cap for messaging this process back, hence why it is a <code>Vec&lt;ProcessId&gt;</code> instead of vector of arbitrary capabilities.</p>
</li>
<li>
<p><code>public: bool</code>: This boolean value determines whether the process can receive messages from other processes by default.</p>
</li>
</ul>
<p>The fields within the spawn function closely mirror those found in the pkg/manifest.json file of your project, providing a consistent and intuitive setup for process management.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-a-website-or-web-app"><a class="header" href="#publishing-a-website-or-web-app">Publishing a Website or Web App</a></h1>
<p>Publishing a website or web app is quite simple.
There are helper functions to make this a one-line call if you have properly uploaded the relevant files from your development <code>/pkg</code> directory.</p>
<p>All of these functions expect you to place your <code>index.html</code> within a directory in <code>/pkg</code>.
In the following examples, that directory would be <code>/pkg/ui</code>.
All other files should be in a directory called <code>assets</code> inside of <code>ui</code>, so <code>/pkg/ui/assets</code>.
The structure should look like this:</p>
<pre><code>my_package
└── pkg
    └── ui
        ├── assets
        └── index.html
</code></pre>
<h2 id="serving-static-assets"><a class="header" href="#serving-static-assets">Serving Static Assets</a></h2>
<p>The simplest way to serve a UI is using the <code>serve_ui</code> function from <code>process_lib</code>:</p>
<pre><code>serve_ui(&amp;our, &quot;ui&quot;).unwrap();
</code></pre>
<p><code>serve_ui</code> takes two arguments: <code>&amp;our</code> (&amp;Address) and the directory where the UI assets are stored.
By convention, this is the <code>ui</code> directory inside of the <code>pkg</code> directory that will be uploaded when you install the process.
There must be an <code>index.html</code> in the <code>&quot;ui&quot;</code> directory (or whatever your top-level directory is called).</p>
<p>Under the hood, <code>serve_ui</code> uses <code>http_bind_static_path</code> which caches files in memory with <code>http_server</code> to respond to HTTP requests more quickly.
The signature for <code>http_bind_static_path</code> is below:</p>
<pre><code>pub fn bind_http_static_path&lt;T&gt;(
    path: T,
    authenticated: bool,
    local_only: bool,
    content_type: Option&lt;String&gt;,
    content: Vec&lt;u8&gt;,
) -&gt; anyhow::Result&lt;()&gt;
</code></pre>
<p>The two additional parameters are the <code>content_type</code> (an optional String) and the <code>content</code> (bytes).
The content will be served at the named route with the <code>Content-Type</code> header set appropriately.</p>
<p>Note that <code>serve_ui</code> caches all files in <code>http_server</code>, so if your website or web app has hundreds of MBs of asset files (like high-res images), then you will want to use a different method to serve content.
In this case, you would bind the <code>index.html</code> file to your main route, and then bind a given HTTP route to serve all of your assets like so:</p>
<pre><code>serve_index_html(&amp;our, &quot;ui&quot;).unwrap();
bind_http_path(&quot;/assets/*&quot;, true, false).unwrap();
</code></pre>
<p>Then in your request handler, you can use <code>handle_ui_asset_request</code> to get the file whose path matches the HTTP route of the request:</p>
<pre><code>let body = message.body();
if let Ok(http_request) = serde_json::from_slice::&lt;HttpServerRequest&gt;(body) {
    match http_request {
        HttpServerRequest::Http(IncomingHttpRequest { raw_path, .. }) =&gt; {
            if raw_path.contains(&amp;format!(&quot;/{}/assets/&quot;, our.process.to_string())) {
                return handle_ui_asset_request(our, &quot;ui&quot;, &amp;raw_path);
            }
        }
        _ =&gt; {}
    }
}
</code></pre>
<p><code>handle_ui_asset_request</code> takes our (&amp;Address), the top-level directory that contains the files, and the <code>raw_path</code> of the incoming request.
In this case, the <code>/assets</code> directory must be in the <code>/ui</code> directory which must be uploaded from <code>pkg</code> when the process is installed.
So your project would look like this:</p>
<pre><code>my_package
└── pkg
    └── ui
        ├── assets
        └── index.html
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-transfer"><a class="header" href="#file-transfer">File Transfer</a></h1>
<p>This entry will teach you to build a simple file transfer app, allowing nodes to download files from a public directory.
It will use the vfs to read and write files, and will spin up worker processes for the transfer.</p>
<p>This guide assumes a basic understanding of Nectar process building, some familiarity with <code>kit</code>, requests and responses, and some knowledge of rust syntax.</p>
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<ul>
<li><a href="cookbook/file_transfer.html#start">Start</a></li>
<li><a href="cookbook/file_transfer.html#transfer">Transfer</a></li>
<li><a href="cookbook/file_transfer.html#final-code">Final Code</a></li>
<li><a href="cookbook/file_transfer.html#conclusion">Conclusion</a></li>
<li><a href="cookbook/../apis/vfs.html">VFS API</a></li>
<li><a href="https://github.com/bitful-pannul/file_transfer">Github Repo</a></li>
</ul>
<h2 id="start"><a class="header" href="#start">Start</a></h2>
<p>First, initialize a new project with <code>kit new file_transfer</code></p>
<p>Here's a clean template so you have a complete fresh start:</p>
<p>This guide will use the following <code>nectar_process_lib</code> version in <code>Cargo.toml</code> for this app:</p>
<pre><code>nectar_process_lib = { git = &quot;ssh://git@github.com/uqbar-dao/process_lib.git&quot;, rev = &quot;64d2856&quot; }
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use std::str::FromStr;

use nectar_process_lib::{await_message, println, Address, Message, ProcessId, Request, Response};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

fn handle_message(our: &amp;Address) -&gt; anyhow::Result&lt;()&gt; {
    let message = await_message()?;
    println!(&quot;file_transfer: got message!: {:?}&quot;, message);
    Ok(())
}

struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer: begin&quot;);

        let our = Address::from_str(&amp;our).unwrap();

        loop {
            match handle_message(&amp;our) {
                Ok(()) =&gt; {}
                Err(e) =&gt; {
                    println!(&quot;file_transfer: error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Before delving into the code, you can handle the capabilities you need to request at spawn, these will be messaging capabilities to &quot;net:sys:nectar&quot; (as you'll want to talk to other nodes), and one to &quot;vfs:sys:nectar&quot; as you'll want to talk to the filesystem.</p>
<p><code>pkg/manifest.json</code></p>
<pre><code class="language-json">[
    {
        &quot;process_name&quot;: &quot;file_transfer&quot;,
        &quot;process_wasm_path&quot;: &quot;/file_transfer.wasm&quot;,
        &quot;on_exit&quot;: &quot;Restart&quot;,
        &quot;request_networking&quot;: true,
        &quot;request_capabilities&quot;: [
            &quot;net:sys:nectar&quot;,
            &quot;vfs:sys:nectar&quot;
        ],
        &quot;grant_capabilities&quot;: [],
        &quot;public&quot;: true
    }
]
</code></pre>
<p>Now, start by creating a drive (folder) in your vfs and opening it, where files will be downloaded by other nodes.
You can add a whitelist a bit later!</p>
<p>Also, import some vfs functions from the <code>process_lib</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::vfs::{create_drive, metadata, open_dir, Directory, FileType},

let drive_path = create_drive(our.package_id(), &quot;files&quot;).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>To start, this will be an app without UI, so to upload files into your public directory, simply copy them into the &quot;files&quot; folder located in <code>your_node/vfs/file_transfer:file_transfer:template.uq/files</code></p>
<p>You now need to let other nodes know what files they can download from you, so add some message types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub enum TransferRequest {
    ListFiles,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferResponse {
    ListFiles(Vec&lt;FileInfo&gt;),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct FileInfo {
    pub name: String,
    pub size: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>You can handle these messages cleanly by modifying the handle message function slightly, it will match on whether a message is a request or a response, the errors get thrown to the main loop automatically with the <code>?</code> after the await_message() function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::{
    await_message, println,
    vfs::{create_drive, metadata, open_dir, Directory, FileType},
    Address, Message, ProcessId, Request, Response,
};
use serde::{Deserialize, Serialize};
use std::str::FromStr;

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferRequest {
    ListFiles,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct FileInfo {
    pub name: String,
    pub size: u64,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferResponse {
    ListFiles(Vec&lt;FileInfo&gt;),
}

fn handle_message(our: &amp;Address, file_dir: &amp;Directory) -&gt; anyhow::Result&lt;()&gt; {
    let message = await_message()?;

    match message {
        Message::Response {
            ref source,
            ref body,
            ..
        } =&gt; {
            handle_transfer_response(our, source, body, file_dir)?;
        }
        Message::Request {
            ref source,
            ref body,
            ..
        } =&gt; {
            handle_transfer_request(&amp;our, source, body, file_dir)?;
        }
    };

    Ok(())
}

struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer: begin&quot;);

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = create_drive(our.package_id(), &quot;files&quot;).unwrap();
        let file_dir = open_dir(&amp;drive_path, false).unwrap();

        loop {
            match handle_message(&amp;our, &amp;file_dir) {
                Ok(()) =&gt; {}
                Err(e) =&gt; {
                    println!(&quot;file_transfer: error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can then add the <code>handle_transfer_request</code> and <code>handle_transfer_response</code> functions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_transfer_request(
    our: &amp;Address,
    source: &amp;Address,
    body: &amp;Vec&lt;u8&gt;,
    files_dir: &amp;Directory,
) -&gt; anyhow::Result&lt;()&gt; {
    let transfer_request = serde_json::from_slice::&lt;TransferRequest&gt;(body)?;

    match transfer_request {
        TransferRequest::ListFiles =&gt; {
            let entries = files_dir.read()?;
            let files: Vec&lt;FileInfo&gt; = entries
                .iter()
                .filter_map(|file| match file.file_type {
                    FileType::File =&gt; match metadata(&amp;file.path) {
                        Ok(metadata) =&gt; Some(FileInfo {
                            name: file.path.clone(),
                            size: metadata.len,
                        }),
                        Err(_) =&gt; None,
                    },
                    _ =&gt; None,
                })
                .collect();

            Response::new()
                .body(serde_json::to_vec(&amp;TransferResponse::ListFiles(files))?)
                .send()?;
        }
    }
}

fn handle_transfer_response(
    our: &amp;Address,
    source: &amp;Address,
    body: &amp;Vec&lt;u8&gt;,
    file_dir: &amp;Directory,
) -&gt; anyhow::Result&lt;()&gt; {
    let transfer_response = serde_json::from_slice::&lt;TransferResponse&gt;(body)?;

    match transfer_response {
        TransferResponse::ListFiles(files) =&gt; {
            println!(&quot;got files from node: {:?} ,files: {:?}&quot;, source, files);
        }
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Now try this out by booting two nodes (fake or real), placing files in the /files folder of one of them, and sending a request.</p>
<pre><code>/m node2.nec@file_transfer:file_transfer:template.uq &quot;ListFiles&quot;
</code></pre>
<p>You should see a printed response.</p>
<pre><code class="language-md">Thu 1/11 13:14 response from node2.nec@file_transfer:file_transfer:template.nec: {&quot;ListFiles&quot;:[{&quot;name&quot;:&quot;file_transfer:template.nec/files/barry-lyndon.mp4&quot;,&quot;size&quot;:8760244}, {&quot;name&quot;:&quot;file_transfer:template.nec/files/blue-danube.mp3&quot;,&quot;size&quot;:9668359}]}
</code></pre>
<h3 id="transfer"><a class="header" href="#transfer">Transfer</a></h3>
<p>Now the fun part, downloading/sending files!</p>
<p>You could handle all of this within the file_transfer process, but you can also spin up another process, a worker, that handles the downloading/sending and then sends progress updates back to the main file_transfer.</p>
<p>This way you can download several files downloading at the same time without waiting for one to finish.</p>
<p>Start by defining some types.</p>
<p>You'll need a request that tells our main process to spin up a worker, requesting the node you're downloading from to do the same. Also, a progress report would be nice!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub enum TransferRequest {
    ListFiles,
    Download { name: String, target: Address },
    Progress { name: String, progress: u64 },
}
<span class="boring">}</span></code></pre></pre>
<p>Now, a request to downoad a file will result in a respose to the requesting process to download the file using a worker.</p>
<p>Add a simple Start and Done variant, so you'll know when the worker has successfully been spawned and initialized.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub enum TransferResponse {
    ListFiles(Vec&lt;FileInfo&gt;),
    Download { name: String, worker: Address },
    Start,
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p>Now, add the intra worker communication types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub enum WorkerRequest {
    Initialize {
        name: String,
        target_worker: Option&lt;Address&gt;,
    },
    Chunk {
        name: String,
        offset: u64,
        length: u64,
    },
    Size(u64),
}
<span class="boring">}</span></code></pre></pre>
<p>Workers will take an <code>Inititialize</code> request from their own node, that either tells them they're a receiver or a sender based on if they have a target worker <code>Option&lt;Address&gt;</code>.</p>
<p>Progress reports are sent back to the main process, which you can then pipe them through as websocket updates to the frontend.</p>
<p>To enable spawning, import the <code>spawn</code> function from the <code>process_lib</code>.</p>
<p>The only additional part you need to handle in the transfer app is the Download request you've added.</p>
<p><code>TransferRequest::Download</code> will handle 2 cases:</p>
<ol>
<li>A node sent us a download request, you spawn a worker, and tell it to send chunks to the <code>target_worker</code> you got in the request.</li>
<li>You want to download a file from another node, you send yourself a download request, you spin up a worker and send it's address to the remote node.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    match transfer_request {
        TransferRequest::ListFiles =&gt; {
            // like before
        }
        TransferRequest::Progress { name, progress } =&gt; {
            // for now, progress reports are just printed
            println!(&quot;file: {} progress: {}%&quot;, name, progress);
        }
        TransferRequest::Download { name, target } =&gt; {
            // spin up a worker, initialize based on whether it's a downloader or a sender.
            let our_worker = spawn(
                None,
                &amp;format!(&quot;{}/pkg/worker.wasm&quot;, our.package_id()),
                OnExit::None,
                our_capabilities(),
                vec![],
                false,
            )?;

            let our_worker_address = Address {
                node: our.node.clone(),
                process: our_worker,
            };

            match source.node == our.node {
                true =&gt; {
                    // we want to download a file
                    let _resp = Request::new()
                        .body(serde_json::to_vec(&amp;WorkerRequest::Initialize {
                            name: name.clone(),
                            target_worker: None,
                        })?)
                        .target(&amp;our_worker_address)
                        .send_and_await_response(5)??;

                    // send our initialized worker address to the other node
                    Request::new()
                        .body(serde_json::to_vec(&amp;TransferRequest::Download {
                            name: name.clone(),
                            target: our_worker_address,
                        })?)
                        .target(&amp;target)
                        .send()?;
                }
                false =&gt; {
                    // they want to download a file
                    Request::new()
                        .body(serde_json::to_vec(&amp;WorkerRequest::Initialize {
                            name: name.clone(),
                            target_worker: Some(target),
                        })?)
                        .target(&amp;our_worker_address)
                        .send()?;
                }
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>There you go.
As you can see, the main transfer doesn't actually do much — it only handles a handshake.
This makes adding more features later on very simple.</p>
<p>Now, the actual worker.
Add this bit by bit:</p>
<p>First, because when you spawn your worker you give it <code>our_capabilities()</code> (i.e. it has the same capabilities as the parent process), the worker will have the ability to message both <code>&quot;net:sys:nectar&quot;</code> and <code>&quot;vfs:sys:nectar&quot;</code>.
As it's also within the same package, you can simply open the <code>files_dir</code> without issue.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer worker: begin&quot;);

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = format!(&quot;{}/files&quot;, our.package_id());
        let files_dir = open_dir(&amp;drive_path, false).unwrap();

        loop {
            match handle_message(&amp;our, &amp;files_dir) {
                Ok(()) =&gt; {}
                Err(e) =&gt; {
                    println!(&quot;file_transfer: error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You'll also need a bit of state for the receiving worker.
This is not persisted (you'll add that soon!), but when different chunks arrive, you need to know what file to write to and how long that file should eventually become to generate progress updates.
This is not known at the point of spawning (<code>init</code> takes just an <code>our: String</code>), but you've created a <code>WorkerRequest::Initialize</code> precisely for this reason.</p>
<p>The state you'll initialize at the start of the worker will look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut file: Option&lt;File&gt; = None;
let mut size: Option&lt;u64&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>And then in the main loop we pass it to <code>handle_message</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer worker: begin&quot;);

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = format!(&quot;{}/files&quot;, our.package_id());
        let files_dir = open_dir(&amp;drive_path, false).unwrap();

        let mut file: Option&lt;File&gt; = None;
        let mut size: Option&lt;u64&gt; = None;
        loop {
            match handle_message(&amp;our, &amp;mut file, &amp;files_dir, &amp;mut size) {
                Ok(()) =&gt; {}
                Err(e) =&gt; {
                    println!(&quot;file_transfer: error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>handle_message</code> function will handle 3 types: the requests Initialize, Chunk and Size.</p>
<p><code>WorkerRequest::Initialize</code> runs once, received from the spawner:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn handle_message(
    our: &amp;Address,
    file: &amp;mut Option&lt;File&gt;,
    files_dir: &amp;Directory,
    size: &amp;mut Option&lt;u64&gt;,
) -&gt; anyhow::Result&lt;()&gt; {
    let message = await_message()?;

    match message {
        Message::Request {
            ref source,
            ref body,
            ..
        } =&gt; {
            let request = serde_json::from_slice::&lt;WorkerRequest&gt;(body)?;

            match request {
                WorkerRequest::Initialize {
                    name,
                    target_worker,
                } =&gt; {
                    // initialize command from main process,
                    // sets up worker, matches on if it's a sender or receiver.
                    // target_worker = None, we are receiver, else sender.

                    // open/create empty file in both cases.
                    let mut active_file =
                        open_file(&amp;format!(&quot;{}/{}&quot;, files_dir.path, &amp;name), true)?;

                    match target_worker {
                        Some(target_worker) =&gt; {
                            // we have a target, chunk the data, and send it.
                            let size = active_file.metadata()?.len;
                            let num_chunks = (size as f64 / CHUNK_SIZE as f64).ceil() as u64;

                            // give the receiving worker a size request so it can track it's progress!
                            Request::new()
                                .body(serde_json::to_vec(&amp;WorkerRequest::Size(size))?)
                                .target(target_worker.clone())
                                .send()?;

                            active_file.seek(SeekFrom::Start(0))?;

                            for i in 0..num_chunks {
                                let offset = i * CHUNK_SIZE;
                                let length = CHUNK_SIZE.min(size - offset);

                                let mut buffer = vec![0; length as usize];
                                active_file.read_at(&amp;mut buffer)?;

                                Request::new()
                                    .body(serde_json::to_vec(&amp;WorkerRequest::Chunk {
                                        name: name.clone(),
                                        offset,
                                        length,
                                    })?)
                                    .target(target_worker.clone())
                                    .blob_bytes(buffer)
                                    .send()?;
                            }
                            Response::new().body(serde_json::to_vec(&amp;&quot;Done&quot;)?).send()?;
                            return Ok(());
                        }
                        None =&gt; {
                            // waiting for response, store created empty file.
                            *file = Some(active_file);
                            Response::new()
                                .body(serde_json::to_vec(&amp;&quot;Started&quot;)?)
                                .send()?;
                        }
                    }
                }
               _ =&gt; {
                println!(&quot;Chunk and Size next!&quot;)
               }
            }
        }
        _ =&gt; {
            println!(&quot;file_transfer worker: got something else than request...&quot;);
        }
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>So upon <code>Initialize</code>, you open the existing file or create an empty one. Then, depending on whether the worker is a sender or receiver, you take one of two options:</p>
<ul>
<li>if receiver, save the File to your state, and then send a Started response to parent.</li>
<li>if sender, get the file's length, send it as Size to the <code>target_worker</code>, and then chunk the data, loop, read into a buffer and send to <code>target_worker</code>.</li>
</ul>
<p><code>WorkerRequest::Chunk</code> will look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// someone sending a chunk to us!
WorkerRequest::Chunk {
    name,
    offset,
    length,
} =&gt; {
    let file = match file {
        Some(file) =&gt; file,
        None =&gt; {
            return Err(anyhow::anyhow!(
                &quot;file_transfer: receive error: no file initialized&quot;
            ));
        }
    };

    let bytes = match get_blob() {
        Some(blob) =&gt; blob.bytes,
        None =&gt; {
            return Err(anyhow::anyhow!(&quot;file_transfer: receive error: no blob&quot;));
        }
    };

    file.write_all(&amp;bytes)?;

    // if sender has sent us a size, give a progress update to main transfer!
    if let Some(size) = size {
        let progress = ((offset + length) as f64 / *size as f64 * 100.0) as u64;

        // send update to main process
        let main_app = Address {
            node: our.node.clone(),
            process: ProcessId::from_str(
                &quot;file_transfer:file_transfer:template.nec&quot;,
            )?,
        };

        Request::new()
            .body(serde_json::to_vec(&amp;TransferRequest::Progress {
                name,
                progress,
            })?)
            .target(&amp;main_app)
            .send()?;

        if progress &gt;= 100 {
            Response::new().body(serde_json::to_vec(&amp;&quot;Done&quot;)?).send()?;
            return Ok(());
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And <code>WorkerRequest::Size</code> is easy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>WorkerRequest::Size(incoming_size) =&gt; {
    *size = Some(incoming_size);
}
<span class="boring">}</span></code></pre></pre>
<p>One more thing: once you're done sending, you can exit the process; the worker is not needed anymore.
Change your <code>handle_message</code> function to return a <code>Result&lt;bool&gt;</code> instead telling the main loop whether it should exit or not.</p>
<p>As a bonus, we can add a print when it exits of how long it took to send/receive!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_message(
    our: &amp;Address,
    file: &amp;mut Option&lt;File&gt;,
    files_dir: &amp;Directory,
    size: &amp;mut Option&lt;u64&gt;,
) -&gt; anyhow::Result&lt;bool&gt; {
<span class="boring">}</span></code></pre></pre>
<p>Changing the main loop and the places we return <code>Ok(())</code> appropriately.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer worker: begin&quot;);
        let start = std::time::Instant::now();

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = format!(&quot;{}/files&quot;, our.package_id());
        let files_dir = open_dir(&amp;drive_path, false).unwrap();

        let mut file: Option&lt;File&gt; = None;
        let mut size: Option&lt;u64&gt; = None;

        loop {
            match handle_message(&amp;our, &amp;mut file, &amp;files_dir, &amp;mut size) {
                Ok(exit) =&gt; {
                    if exit {
                        println!(
                            &quot;file_transfer worker done: exiting, took {:?}&quot;,
                            start.elapsed()
                        );
                        break;
                    }
                }
                Err(e) =&gt; {
                    println!(&quot;file_transfer: worker error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="final-code"><a class="header" href="#final-code">Final Code</a></h3>
<p>And Voilà! The worker and then the main process in entirety:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use std::str::FromStr;

use nectar_process_lib::{
    await_message, get_blob, println,
    vfs::{open_dir, open_file, Directory, File, SeekFrom},
    Address, Message, ProcessId, Request, Response,
};

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

const CHUNK_SIZE: u64 = 1048576; // 1MB

#[derive(Serialize, Deserialize, Debug)]
pub enum WorkerRequest {
    Initialize {
        name: String,
        target_worker: Option&lt;Address&gt;,
    },
    Chunk {
        name: String,
        offset: u64,
        length: u64,
    },
    Size(u64),
}

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferRequest {
    Progress { name: String, progress: u64 },
}

fn handle_message(
    our: &amp;Address,
    file: &amp;mut Option&lt;File&gt;,
    files_dir: &amp;Directory,
    size: &amp;mut Option&lt;u64&gt;,
) -&gt; anyhow::Result&lt;bool&gt; {
    let message = await_message()?;

    match message {
        Message::Request {
            ref source,
            ref body,
            ..
        } =&gt; {
            let request = serde_json::from_slice::&lt;WorkerRequest&gt;(body)?;

            match request {
                WorkerRequest::Initialize {
                    name,
                    target_worker,
                } =&gt; {
                    // initialize command from main process,
                    // sets up worker, matches on if it's a sender or receiver.
                    // target_worker = None, we are receiver, else sender.

                    // open/create empty file in both cases.
                    let mut active_file =
                        open_file(&amp;format!(&quot;{}/{}&quot;, files_dir.path, &amp;name), true)?;

                    match target_worker {
                        Some(target_worker) =&gt; {
                            // we have a target, chunk the data, and send it.
                            let size = active_file.metadata()?.len;
                            let num_chunks = (size as f64 / CHUNK_SIZE as f64).ceil() as u64;

                            // give the receiving worker a size request so it can track it's progress!
                            Request::new()
                                .body(serde_json::to_vec(&amp;WorkerRequest::Size(size))?)
                                .target(target_worker.clone())
                                .send()?;

                            active_file.seek(SeekFrom::Start(0))?;

                            for i in 0..num_chunks {
                                let offset = i * CHUNK_SIZE;
                                let length = CHUNK_SIZE.min(size - offset);

                                let mut buffer = vec![0; length as usize];
                                active_file.read_at(&amp;mut buffer)?;

                                Request::new()
                                    .body(serde_json::to_vec(&amp;WorkerRequest::Chunk {
                                        name: name.clone(),
                                        offset,
                                        length,
                                    })?)
                                    .target(target_worker.clone())
                                    .blob_bytes(buffer)
                                    .send()?;
                            }
                            Response::new().body(serde_json::to_vec(&amp;&quot;Done&quot;)?).send()?;
                            return Ok(true);
                        }
                        None =&gt; {
                            // waiting for response, store created empty file.
                            *file = Some(active_file);
                            Response::new()
                                .body(serde_json::to_vec(&amp;&quot;Started&quot;)?)
                                .send()?;
                        }
                    }
                }
                // someone sending a chunk to us!
                WorkerRequest::Chunk {
                    name,
                    offset,
                    length,
                } =&gt; {
                    let file = match file {
                        Some(file) =&gt; file,
                        None =&gt; {
                            return Err(anyhow::anyhow!(
                                &quot;file_transfer: receive error: no file initialized&quot;
                            ));
                        }
                    };

                    let bytes = match get_blob() {
                        Some(blob) =&gt; blob.bytes,
                        None =&gt; {
                            return Err(anyhow::anyhow!(&quot;file_transfer: receive error: no blob&quot;));
                        }
                    };

                    file.write_all(&amp;bytes)?;
                    // if sender has sent us a size, give a progress update to main transfer!
                    if let Some(size) = size {
                        let progress = ((offset + length) as f64 / *size as f64 * 100.0) as u64;

                        // send update to main process
                        let main_app = Address {
                            node: our.node.clone(),
                            process: ProcessId::from_str(
                                &quot;file_transfer:file_transfer:template.nec&quot;,
                            )?,
                        };

                        Request::new()
                            .body(serde_json::to_vec(&amp;TransferRequest::Progress {
                                name,
                                progress,
                            })?)
                            .target(&amp;main_app)
                            .send()?;

                        if progress &gt;= 100 {
                            Response::new().body(serde_json::to_vec(&amp;&quot;Done&quot;)?).send()?;
                            return Ok(true);
                        }
                    }
                }
                WorkerRequest::Size(incoming_size) =&gt; {
                    *size = Some(incoming_size);
                }
            }
        }
        _ =&gt; {
            println!(&quot;file_transfer worker: got something else than request...&quot;);
        }
    }
    Ok(false)
}

struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer worker: begin&quot;);
        let start = std::time::Instant::now();

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = format!(&quot;{}/files&quot;, our.package_id());
        let files_dir = open_dir(&amp;drive_path, false).unwrap();

        let mut file: Option&lt;File&gt; = None;
        let mut size: Option&lt;u64&gt; = None;

        loop {
            match handle_message(&amp;our, &amp;mut file, &amp;files_dir, &amp;mut size) {
                Ok(exit) =&gt; {
                    if exit {
                        println!(
                            &quot;file_transfer worker done: exiting, took {:?}&quot;,
                            start.elapsed()
                        );
                        break;
                    }
                }
                Err(e) =&gt; {
                    println!(&quot;file_transfer: worker error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And the main process:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::{
    await_message, our_capabilities, println, spawn,
    vfs::{create_drive, metadata, open_dir, Directory, FileType},
    Address, Message, OnExit, Request, Response,
};
use serde::{Deserialize, Serialize};
use std::str::FromStr;

wit_bindgen::generate!({
    path: &quot;wit&quot;,
    world: &quot;process&quot;,
    exports: {
        world: Component,
    },
});

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferRequest {
    ListFiles,
    Download { name: String, target: Address },
    Progress { name: String, progress: u64 },
}

#[derive(Serialize, Deserialize, Debug)]
pub enum TransferResponse {
    ListFiles(Vec&lt;FileInfo&gt;),
    Download { name: String, worker: Address },
    Done,
    Started,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct FileInfo {
    pub name: String,
    pub size: u64,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum WorkerRequest {
    Initialize {
        name: String,
        target_worker: Option&lt;Address&gt;,
    },
}

fn handle_transfer_request(
    our: &amp;Address,
    source: &amp;Address,
    body: &amp;Vec&lt;u8&gt;,
    files_dir: &amp;Directory,
) -&gt; anyhow::Result&lt;()&gt; {
    let transfer_request = serde_json::from_slice::&lt;TransferRequest&gt;(body)?;

    match transfer_request {
        TransferRequest::ListFiles =&gt; {
            let entries = files_dir.read()?;
            let files: Vec&lt;FileInfo&gt; = entries
                .iter()
                .filter_map(|file| match file.file_type {
                    FileType::File =&gt; match metadata(&amp;file.path) {
                        Ok(metadata) =&gt; Some(FileInfo {
                            name: file.path.clone(),
                            size: metadata.len,
                        }),
                        Err(_) =&gt; None,
                    },
                    _ =&gt; None,
                })
                .collect();

            Response::new()
                .body(serde_json::to_vec(&amp;TransferResponse::ListFiles(files))?)
                .send()?;
        }
        TransferRequest::Download { name, target } =&gt; {
            // spin up a worker, initialize based on whether it's a downloader or a sender.
            let our_worker = spawn(
                None,
                &amp;format!(&quot;{}/pkg/worker.wasm&quot;, our.package_id()),
                OnExit::None,
                our_capabilities(),
                vec![],
                false,
            )?;

            let our_worker_address = Address {
                node: our.node.clone(),
                process: our_worker,
            };

            match source.node == our.node {
                true =&gt; {
                    // we want to download a file
                    let _resp = Request::new()
                        .body(serde_json::to_vec(&amp;WorkerRequest::Initialize {
                            name: name.clone(),
                            target_worker: None,
                        })?)
                        .target(&amp;our_worker_address)
                        .send_and_await_response(5)??;

                    // send our initialized worker address to the other node
                    Request::new()
                        .body(serde_json::to_vec(&amp;TransferRequest::Download {
                            name: name.clone(),
                            target: our_worker_address,
                        })?)
                        .target(&amp;target)
                        .send()?;
                }
                false =&gt; {
                    // they want to download a file
                    Request::new()
                        .body(serde_json::to_vec(&amp;WorkerRequest::Initialize {
                            name: name.clone(),
                            target_worker: Some(target),
                        })?)
                        .target(&amp;our_worker_address)
                        .send()?;
                }
            }
        }
        TransferRequest::Progress { name, progress } =&gt; {
            println!(&quot;file: {} progress: {}%&quot;, name, progress);
        }
    }

    Ok(())
}

fn handle_transfer_response(source: &amp;Address, body: &amp;Vec&lt;u8&gt;) -&gt; anyhow::Result&lt;()&gt; {
    let transfer_response = serde_json::from_slice::&lt;TransferResponse&gt;(body)?;

    match transfer_response {
        TransferResponse::ListFiles(files) =&gt; {
            println!(&quot;got files from node: {:?} ,files: {:?}&quot;, source, files);
        }
        _ =&gt; {}
    }

    Ok(())
}

fn handle_message(our: &amp;Address, files_dir: &amp;Directory) -&gt; anyhow::Result&lt;()&gt; {
    let message = await_message()?;

    match message {
        Message::Response {
            ref source,
            ref body,
            ..
        } =&gt; {
            handle_transfer_response(source, body)?;
        }
        Message::Request {
            ref source,
            ref body,
            ..
        } =&gt; {
            handle_transfer_request(&amp;our, source, body, files_dir)?;
        }
    };

    Ok(())
}

struct Component;
impl Guest for Component {
    fn init(our: String) {
        println!(&quot;file_transfer: begin&quot;);

        let our = Address::from_str(&amp;our).unwrap();

        let drive_path = create_drive(our.package_id(), &quot;files&quot;).unwrap();
        let files_dir = open_dir(&amp;drive_path, false).unwrap();

        loop {
            match handle_message(&amp;our, &amp;files_dir) {
                Ok(()) =&gt; {}
                Err(e) =&gt; {
                    println!(&quot;file_transfer: error: {:?}&quot;, e);
                }
            };
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h3>
<p>There you have it!</p>
<p>Try and run it, you can download a file with the command</p>
<pre><code>/m our@file_transfer:file_transfer:template.nec {&quot;Download&quot;: {&quot;name&quot;: &quot;dawg.jpeg&quot;, &quot;target&quot;: &quot;buenosaires.nec@file_transfer:file_transfer:template.nec&quot;}}
</code></pre>
<p>replacing node name and file name!</p>
<p>Stay tuned for additions to this guide, including restarting transfers after rebooting your node or losing connections, and a simple UI!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apis-overview"><a class="header" href="#apis-overview">APIs Overview</a></h1>
<p>The APIs documented in this section refer to Nectar runtime modules.
Specifically, they are the patterns of Requests and Responses that an app can use to interact with these modules.</p>
<p><strong>Note: App developers usually should not use these APIs directly.
Most standard use-cases are better served by using functions in the <a href="apis/../process_stdlib/overview.html">Process Standard Library</a>.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-api"><a class="header" href="#http-api">HTTP API</a></h1>
<p>In NectarOS, incoming HTTP requests are handled by a Rust <code>warp</code> server in the core <code>http_server:sys:nectar</code> process.
This process handles binding (registering) routes, simple JWT-based authentication, and serving a <code>/login</code> page if auth is missing.</p>
<h2 id="binding-registering-http-paths"><a class="header" href="#binding-registering-http-paths">Binding (Registering) HTTP Paths</a></h2>
<p>Any process that you build can bind (register) any number of HTTP paths with <code>http_server</code>.
Every path that you bind will be automatically prepended with the current process' ID.
For example, bind the route <code>/messages</code> within a process called <code>main:my_package:myname.nec</code> like so:</p>
<pre><code>use nectar_process_lib::{http::bind_http_path};

bind_http_path(&quot;/messages&quot;, true, false).unwrap();
</code></pre>
<p>Now, any HTTP requests to your node at <code>/main:my_package:myname.nec/messages</code> will be routed to your process.</p>
<p>The other two parameters to <code>bind_http_path</code> are <code>authenticated: bool</code> and <code>local_only: bool</code>.
<code>authenticated</code> means that <code>http_server</code> will check for an auth cookie (set at login/registration), and <code>local_only</code> means that <code>http_server</code> will only allow requests that come from <code>localhost</code>.</p>
<p>Incoming HTTP requests will come via <code>http_server</code> and have both an <code>body</code> and a <code>lazy_load_blob</code>.
The <code>lazy_load_blob</code> is the HTTP request body, and the <code>body</code> is an <code>IncomingHttpRequest</code>:</p>
<pre><code>pub struct IncomingHttpRequest {
    pub source_socket_addr: Option&lt;String&gt;, // will parse to SocketAddr
    pub method: String,                     // will parse to http::Method
    pub raw_path: String,
    pub headers: HashMap&lt;String, String&gt;,
    pub query_params: HashMap&lt;String, String&gt;,
}
</code></pre>
<p>Note that <code>raw_path</code> is the host and full path of the original HTTP request that came in.</p>
<h2 id="handling-http-requests"><a class="header" href="#handling-http-requests">Handling HTTP Requests</a></h2>
<p>Usually, you will want to:</p>
<ol>
<li>determine if an incoming request is a HTTP request.</li>
<li>figure out what kind of <code>IncomingHttpRequest</code> it is.</li>
<li>handle the request based on the path and method.</li>
</ol>
<p>Here is an example from the <code>kit</code> UI-enabled chat app template that handles both <code>POST</code> and <code>GET</code> requests to the <code>/messages</code> path:</p>
<pre><code>fn handle_http_server_request(
    our: &amp;Address,
    message_archive: &amp;mut MessageArchive,
    source: &amp;Address,
    body: &amp;[u8],
    our_channel_id: &amp;mut u32,
) -&gt; anyhow::Result&lt;()&gt; {
    let Ok(server_request) = serde_json::from_slice::&lt;HttpServerRequest&gt;(body) else {
        // Fail silently if we can't parse the request
        return Ok(());
    };

    match server_request {

        // IMPORTANT BIT:

        HttpServerRequest::Http(IncomingHttpRequest { method, raw_path, .. }) =&gt; {
            // Check the path
            if raw_path.ends_with(&amp;format!(&quot;{}{}&quot;, our.process.to_string(), &quot;/messages&quot;)) {
                // Match on the HTTP method
                match method.as_str() {
                    // Get all messages
                    &quot;GET&quot; =&gt; {
                        let mut headers = HashMap::new();
                        headers.insert(&quot;Content-Type&quot;.to_string(), &quot;application/json&quot;.to_string());

                        send_response(
                            StatusCode::OK,
                            Some(headers),
                            serde_json::to_vec(&amp;ChatResponse::History {
                                messages: message_archive.clone(),
                            })
                            .unwrap(),
                        )?;
                    }
                    // Send a message
                    &quot;POST&quot; =&gt; {
                        print_to_terminal(0, &quot;1&quot;);
                        let Some(blob) = get_blob() else {
                            return Ok(());
                        };
                        print_to_terminal(0, &quot;2&quot;);
                        handle_chat_request(
                            our,
                            message_archive,
                            our_channel_id,
                            source,
                            &amp;blob.bytes,
                            true,
                        )?;

                        // Send an http response via the http server
                        send_response(StatusCode::CREATED, None, vec![])?;
                    }
                    _ =&gt; {
                        // Method not allowed
                        send_response(StatusCode::METHOD_NOT_ALLOWED, None, vec![])?;
                    }
                }
            }
        }

        _ =&gt; {}
    };

    Ok(())
}
</code></pre>
<p><code>send_response</code> is a <code>process_lib</code> function that sends an HTTP response. The function signature is as follows:</p>
<pre><code>pub fn send_response(
    status: StatusCode,
    headers: Option&lt;HashMap&lt;String, String&gt;&gt;,
    body: Vec&lt;u8&gt;,
) -&gt; anyhow::Result&lt;()&gt;
</code></pre>
<h2 id="app-specific-authentication"><a class="header" href="#app-specific-authentication">App-Specific Authentication</a></h2>
<p>COMING SOON</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-client-api"><a class="header" href="#http-client-api">HTTP Client API</a></h1>
<p><em>See also: docs.rs for HTTP Client part of <a href="apis/../process_stdlib/overview.html">process_lib</a></em></p>
<p><strong>Note: Most processes will not use this API directly. Instead, they will use the <a href="apis/./process_stdlib/overview.html"><code>process_lib</code></a> library, which papers over this API and provides a set of types and functions which are much easier to natively use. This is mostly useful for re-implementing this module in a different client or performing niche actions unsupported by the library.</strong></p>
<p>The HTTP client is used for sending and receiving HTTP requests and responses.
It is also used for connecting to a websocket endpoint as a client.
From a process, you may send an <code>HttpClientAction</code> to the <code>http_client:sys:nectar</code> process.
The action must be serialized to JSON and sent in the <code>body</code> of a request.
<code>HttpClientAction</code> is an <code>enum</code> type that includes both HTTP and websocket actions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Request type that can be shared over WASM boundary to apps.
/// This is the one you send to the `http_client:sys:nectar` service.
#[derive(Debug, Serialize, Deserialize)]
pub enum HttpClientAction {
    Http(OutgoingHttpRequest),
    WebSocketOpen {
        url: String,
        headers: HashMap&lt;String, String&gt;,
        channel_id: u32,
    },
    WebSocketPush {
        channel_id: u32,
        message_type: WsMessageType,
    },
    WebSocketClose {
        channel_id: u32,
    },
}
<span class="boring">}</span></code></pre></pre>
<p>The websocket actions, <code>WebSocketOpen</code>, <code>WebSocketPush</code>, and <code>WebSocketClose</code> all require a <code>channel_id</code>.
The <code>channel_id</code> is used to identify the connection, and must be unique for each connection from a given process.
Two or more connections can have the same <code>channel_id</code> if they are from different processes.
<code>OutgoingHttpRequest</code> is used to send an HTTP request.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// HTTP Request type that can be shared over WASM boundary to apps.
/// This is the one you send to the `http_client:sys:nectar` service.
#[derive(Debug, Serialize, Deserialize)]
pub struct OutgoingHttpRequest {
    pub method: String,          // must parse to http::Method
    pub version: Option&lt;String&gt;, // must parse to http::Version
    pub url: String,             // must parse to url::Url
    pub headers: HashMap&lt;String, String&gt;,
    // BODY is stored in the lazy_load_blob, as bytes
    // TIMEOUT is stored in the message expect_response
}
<span class="boring">}</span></code></pre></pre>
<p>All requests to the HTTP client will receive a response of <code>Result&lt;HttpClientResponse, HttpClientError&gt;</code> serialized to JSON.
The process can await or ignore this response, although the desired information will be in the <code>HttpClientResponse</code> if the request was successful.
An HTTP request will have an <code>HttpResponse</code> defined in the <a href="apis/./apis/http_server.html"><code>http_server</code></a> module.
A websocket request (open, push, close) will simply respond with a <code>HttpClientResponse::WebSocketAck</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// HTTP Client Response type that can be shared over WASM boundary to apps.
/// This is the one you receive from the `http_client:sys:nectar` service.
#[derive(Debug, Serialize, Deserialize)]
pub enum HttpClientResponse {
    Http(HttpResponse),
    WebSocketAck,
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Error, Debug, Serialize, Deserialize)]
pub enum HttpClientError {
    // HTTP errors, may also be applicable to OutgoingWebSocketClientRequest::Open
    #[error(&quot;http_client: request is not valid HttpClientRequest: {}.&quot;, req)]
    BadRequest { req: String },
    #[error(&quot;http_client: http method not supported: {}&quot;, method)]
    BadMethod { method: String },
    #[error(&quot;http_client: url could not be parsed: {}&quot;, url)]
    BadUrl { url: String },
    #[error(&quot;http_client: http version not supported: {}&quot;, version)]
    BadVersion { version: String },
    #[error(&quot;http_client: failed to execute request {}&quot;, error)]
    RequestFailed { error: String },

    // WebSocket errors
    #[error(&quot;websocket_client: failed to open connection {}&quot;, url)]
    WsOpenFailed { url: String },
    #[error(&quot;websocket_client: failed to send message {}&quot;, req)]
    WsPushFailed { req: String },
    #[error(&quot;websocket_client: failed to close connection {}&quot;, channel_id)]
    WsCloseFailed { channel_id: u32 },
}
<span class="boring">}</span></code></pre></pre>
<p>The HTTP client can also receive external websocket messages over an active client connection.
These incoming websocket messages are processed and sent as <code>HttpClientRequest</code> to the process that originally opened the websocket.
The message itself is accessible with <code>get_blob()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// WebSocket Client Request type that can be shared over WASM boundary to apps.
/// This comes from an open websocket client connection in the `http_client:sys:nectar` service.
#[derive(Debug, Serialize, Deserialize)]
pub enum HttpClientRequest {
    WebSocketPush {
        channel_id: u32,
        message_type: WsMessageType,
    },
    WebSocketClose {
        channel_id: u32,
    },
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server-api"><a class="header" href="#http-server-api">HTTP Server API</a></h1>
<p><em>See also: docs.rs for HTTP Server part of process_lib</em></p>
<p><strong>Note: Most processes will not use this API directly. Instead, they will use the <a href="apis/./process_stdlib/overview.html"><code>process_lib</code></a> library, which papers over this API and provides a set of types and functions which are much easier to natively use. This is mostly useful for re-implementing this module in a different client or performing niche actions unsupported by the library.</strong></p>
<p>The HTTP server is used by sending and receiving requests and responses.
From a process, you may send an <code>HttpServerAction</code> to the <code>http_server:sys:nectar</code> process.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Request type sent to `http_server:sys:nectar` in order to configure it.
/// You can also send [`type@HttpServerAction::WebSocketPush`], which
/// allows you to push messages across an existing open WebSocket connection.
///
/// If a response is expected, all HttpServerActions will return a Response
/// with the shape Result&lt;(), HttpServerActionError&gt; serialized to JSON.
#[derive(Debug, Serialize, Deserialize)]
pub enum HttpServerAction {
    /// Bind expects a lazy_load_blob if and only if `cache` is TRUE. The lazy_load_blob should
    /// be the static file to serve at this path.
    Bind {
        path: String,
        /// Set whether the HTTP request needs a valid login cookie, AKA, whether
        /// the user needs to be logged in to access this path.
        authenticated: bool,
        /// Set whether requests can be fielded from anywhere, or only the loopback address.
        local_only: bool,
        /// Set whether to bind the lazy_load_blob statically to this path. That is, take the
        /// lazy_load_blob bytes and serve them as the response to any request to this path.
        cache: bool,
    },
    /// SecureBind expects a lazy_load_blob if and only if `cache` is TRUE. The lazy_load_blob should
    /// be the static file to serve at this path.
    ///
    /// SecureBind is the same as Bind, except that it forces requests to be made from
    /// the unique subdomain of the process that bound the path. These requests are
    /// *always* authenticated, and *never* local_only. The purpose of SecureBind is to
    /// serve elements of an app frontend or API in an exclusive manner, such that other
    /// apps installed on this node cannot access them. Since the subdomain is unique, it
    /// will require the user to be logged in separately to the general domain authentication.
    SecureBind {
        path: String,
        /// Set whether to bind the lazy_load_blob statically to this path. That is, take the
        /// lazy_load_blob bytes and serve them as the response to any request to this path.
        cache: bool,
    },
    /// Bind a path to receive incoming WebSocket connections.
    /// Doesn't need a cache since does not serve assets.
    WebSocketBind {
        path: String,
        authenticated: bool,
        encrypted: bool,
    },
    /// SecureBind is the same as Bind, except that it forces new connections to be made
    /// from the unique subdomain of the process that bound the path. These are *always*
    /// authenticated. Since the subdomain is unique, it will require the user to be
    /// logged in separately to the general domain authentication.
    WebSocketSecureBind { path: String, encrypted: bool },
    /// When sent, expects a lazy_load_blob containing the WebSocket message bytes to send.
    WebSocketPush {
        channel_id: u32,
        message_type: WsMessageType,
    },
    /// Sending will close a socket the process controls.
    WebSocketClose(u32),
}

/// The possible message types for WebSocketPush. Ping and Pong are limited to 125 bytes
/// by the WebSockets protocol. Text will be sent as a Text frame, with the lazy_load_blob bytes
/// being the UTF-8 encoding of the string. Binary will be sent as a Binary frame containing
/// the unmodified lazy_load_blob bytes.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum WsMessageType {
    Text,
    Binary,
    Ping,
    Pong,
    Close,
}
<span class="boring">}</span></code></pre></pre>
<p>This struct must be serialized to JSON and placed in the <code>body</code> of a requests to <code>http_server:sys:nectar</code>.
For actions that take additional data, such as <code>Bind</code> and <code>WebSocketPush</code>, it is placed in the <code>lazy_load_blob</code> of that request.</p>
<p>After handling such a request, the HTTP server will always give a response of the shape <code>Result&lt;(), HttpServerError&gt;</code>, also serialized to JSON. This can be ignored, or awaited and handled.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Part of the Response type issued by http_server
#[derive(Error, Debug, Serialize, Deserialize)]
pub enum HttpServerError {
    #[error(
        &quot;http_server: request could not be parsed to HttpServerAction: {}.&quot;,
        req
    )]
    BadRequest { req: String },
    #[error(&quot;http_server: action expected blob&quot;)]
    NoBlob,
    #[error(&quot;http_server: path binding error: {:?}&quot;, error)]
    PathBindError { error: String },
    #[error(&quot;http_server: WebSocket error: {:?}&quot;, error)]
    WebSocketPushError { error: String },
}
<span class="boring">}</span></code></pre></pre>
<p>Certain actions will cause the HTTP server to send requests to the process in the future.
If a process uses <code>Bind</code> or <code>SecureBind</code>, that process will need to field future requests from the HTTP server. The server will handle incoming HTTP protocol messages to that path by sending an <code>HttpServerRequest</code> to the process which performed the binding, and will expect a response that it can then send to the client.</p>
<p><strong>Note: Paths bound using the HTTP server are <em>always</em> prefixed by the ProcessId of the process that bound them.</strong></p>
<p><strong>Note 2: If a process creates a static binding by setting <code>cache</code> to <code>true</code>, the HTTP server will serve whatever bytes were in the accompanying <code>lazy_load_blob</code> to all GET requests on that path.</strong></p>
<p>If a process uses <code>WebSocketBind</code> or <code>WebSocketSecureBind</code>, future WebSocket connections to that path will be sent to the process, which is expected to issue a response that can then be sent to the client.</p>
<p>The incoming request, whether the binding is for HTTP or WebSocket, will look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// HTTP Request type that can be shared over WASM boundary to apps.
/// This is the one you receive from the `http_server:sys:nectar` service.
#[derive(Debug, Serialize, Deserialize)]
pub enum HttpServerRequest {
    Http(IncomingHttpRequest),
    /// Processes will receive this kind of request when a client connects to them.
    /// If a process does not want this websocket open, they should issue a *request*
    /// containing a [`type@HttpServerAction::WebSocketClose`] message and this channel ID.
    WebSocketOpen {
        path: String,
        channel_id: u32,
    },
    /// Processes can both SEND and RECEIVE this kind of request
    /// (send as [`type@HttpServerAction::WebSocketPush`]).
    /// When received, will contain the message bytes as lazy_load_blob.
    WebSocketPush {
        channel_id: u32,
        message_type: WsMessageType,
    },
    /// Receiving will indicate that the client closed the socket. Can be sent to close
    /// from the server-side, as [`type@HttpServerAction::WebSocketClose`].
    WebSocketClose(u32),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct IncomingHttpRequest {
    pub source_socket_addr: Option&lt;String&gt;, // will parse to SocketAddr
    pub method: String,                     // will parse to http::Method
    pub raw_path: String,
    pub headers: HashMap&lt;String, String&gt;,
    pub query_params: HashMap&lt;String, String&gt;,
    // BODY is stored in the lazy_load_blob, as bytes
}
<span class="boring">}</span></code></pre></pre>
<p>Processes that use the HTTP server should expect to field this request type, serialized to JSON.
The process must issue a response with this structure in the body, serialized to JSON:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// HTTP Response type that can be shared over WASM boundary to apps.
/// Respond to [`IncomingHttpRequest`] with this type.
#[derive(Debug, Serialize, Deserialize)]
pub struct HttpResponse {
    pub status: u16,
    pub headers: HashMap&lt;String, String&gt;,
    // BODY is stored in the lazy_load_blob, as bytes
}
<span class="boring">}</span></code></pre></pre>
<p>This response is only required for HTTP requests.
<code>WebSocketOpen</code>, <code>WebSocketPush</code>, and <code>WebSocketClose</code> requests do not require a response.
If a process is meant to send data over an open WebSocket connection, it must issue a <code>HttpServerAction::WebSocketPush</code> request with the appropriate <code>channel_id</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-api"><a class="header" href="#kernel-api">Kernel API</a></h1>
<p>Generally, userspace applications will not have the capability to message the kernel.
Those that can, such as the app store, have full control over starting and stopping all userspace processes.</p>
<p>The kernel runtime task accepts one kind of <code>Request</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize, Deserialize)]
pub enum KernelCommand {
    /// RUNTIME ONLY: used to notify the kernel that booting is complete and
    /// all processes have been loaded in from their persisted or bootstrapped state.
    Booted,
    /// Tell the kernel to install and prepare a new process for execution.
    /// The process will not begin execution until the kernel receives a
    /// `RunProcess` command with the same `id`.
    ///
    /// The process that sends this command will be given messaging capabilities
    /// for the new process if `public` is false.
    ///
    /// All capabilities passed into initial_capabilities must be held by the source
    /// of this message, or the kernel will discard them (silently for now).
    InitializeProcess {
        id: ProcessId,
        wasm_bytes_handle: String,
        wit_version: Option&lt;u32&gt;,
        on_exit: OnExit,
        initial_capabilities: HashSet&lt;Capability&gt;,
        public: bool,
    },
    /// Create an arbitrary capability and grant it to a process.
    GrantCapabilities {
        target: ProcessId,
        capabilities: Vec&lt;Capability&gt;,
    },
    /// Tell the kernel to run a process that has already been installed.
    /// TODO: in the future, this command could be extended to allow for
    /// resource provision.
    RunProcess(ProcessId),
    /// Kill a running process immediately. This may result in the dropping / mishandling of messages!
    KillProcess(ProcessId),
    /// RUNTIME ONLY: notify the kernel that the runtime is shutting down and it
    /// should gracefully stop and persist the running processes.
    Shutdown,
    /// Ask kernel to produce debugging information
    Debug(KernelPrint),
}
<span class="boring">}</span></code></pre></pre>
<p>All <code>KernelCommand</code>s are sent in the body field of a <code>Request</code>, serialized to JSON.
Only <code>InitializeProcess</code>, <code>RunProcess</code>, and <code>KillProcess</code> will give back a <code>Response</code>, also serialized to JSON text bytes using <code>serde_json</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum KernelResponse {
    InitializedProcess,       // given back after a successful InitializeProcess
    InitializeProcessError,   // given back after a failed InitializeProcess
    StartedProcess,           // given back after a successful RunProcess
    RunProcessError,          // given back after a failed RunProcess
    KilledProcess(ProcessId), // given back after a KillProcess request
}
<span class="boring">}</span></code></pre></pre>
<h2 id="booted"><a class="header" href="#booted"><code>Booted</code></a></h2>
<p>Purely for internal use within the kernel.
Sent by the kernel, to the kernel, to indicate that all persisted processes have been initialized and are ready to run.</p>
<h2 id="initializeprocess"><a class="header" href="#initializeprocess"><code>InitializeProcess</code></a></h2>
<p>The first command used to start a new process.
Generally available to apps via the <code>spawn()</code> function in the WIT interface.
The <code>wasm_bytes_handle</code> is a pointer generated by the <a href="apis/filesystem.html">filesystem</a> API — it should be a valid <code>.wasm</code> file compiled using the <a href="apis/../kit/kit.html">Nectar tooling</a>.
The <code>on_panic</code> field is an enum that specifies what to do if the process panics.
The <code>initial_capabilities</code> field is a set of capabilities that the process will have access to — note that the capabilities are signed by this kernel.
The <code>public</code> field specifies whether the process should be visible to other processes <em>without</em> needing to grant a messaging capability.</p>
<p><code>InitializeProcess</code> must be sent with a <code>lazy_load_blob</code>.
The blob must be the same .wasm file, in raw bytes, that the <code>wasm_bytes_handle</code> points to.</p>
<p>This will <em>not</em> cause the process to begin running.
To do that, send a <code>RunProcess</code> command after a successful <code>InitializeProcess</code> command.</p>
<h2 id="grantcapabilities"><a class="header" href="#grantcapabilities"><code>GrantCapabilities</code></a></h2>
<p>This command directly inserts a list of capabilities into another process' state.
While you generally don't want to do this for security reasons, it helps you clean up the &quot;handshake&quot; process by which capabilities must be handed off between two processes before engaging in the business logic.
For instance, if you want a kernel module like <code>http_server</code> to be able to message a process back, you do this by directly inserting that <code>&quot;messaging&quot;</code> cap into <code>http_server</code>'s store.
Only the <code>app_store</code> and <code>tester</code> make use of this.</p>
<h2 id="runprocess"><a class="header" href="#runprocess"><code>RunProcess</code></a></h2>
<p>Takes a process ID and tells kernel to call the <code>init</code> function.
The process must have first been initialized with a successful <code>InitializeProcess</code>.</p>
<h2 id="killprocess"><a class="header" href="#killprocess"><code>KillProcess</code></a></h2>
<p>Takes a process ID and kills it.
This is a dangerous operation as messages queued for the process will be lost.
The process will be removed from the kernel's process table and will no longer be able to receive messages.</p>
<h2 id="shutdown"><a class="header" href="#shutdown"><code>Shutdown</code></a></h2>
<p>Send to the kernel in order to gracefully shut down the system.
The runtime must perform this request before exiting in order to see that all processes are properly cleaned up.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="kv-api"><a class="header" href="#kv-api">KV API</a></h3>
<p>Useful helper functions can be found in the <a href="https://github.com/uqbar-dao/process_lib">nectar_process_lib</a></p>
<h4 id="creatingopening-a-database"><a class="header" href="#creatingopening-a-database">Creating/Opening a database</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::kv;

let kv = kv::open(our.package_id(), &quot;birthdays&quot;)?;

// You can now pass this KV struct as a reference to other functions
<span class="boring">}</span></code></pre></pre>
<h4 id="set"><a class="header" href="#set">Set</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let key = b&quot;hello&quot;;
let value= b&quot;world&quot;;

let returnvalue = kv.set(&amp;key, &amp;value, None)?;
// The third argument None is for tx_id. 
// You can group sets and deletes and commit them later. 
<span class="boring">}</span></code></pre></pre>
<h4 id="get"><a class="header" href="#get">Get</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let key = b&quot;hello&quot;;

let returnvalue = kv.get(&amp;key)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="delete"><a class="header" href="#delete">Delete</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let key = b&quot;hello&quot;;

kv.delete(&amp;key, None)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="transactions"><a class="header" href="#transactions">Transactions</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tx_id = kv.begin_tx()?;

let key = b&quot;hello&quot;;
let key2 = b&quot;deleteme&quot;;
let value= b&quot;value&quot;;

kv.set(&amp;key, &amp;value, Some(tx_id))?;
kv.delete(&amp;key, Some(tx_id))?;

kv.commit_tx(tx_id)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Actions are sent to a specific key value database, &quot;db&quot; is the name,
/// &quot;package_id&quot; is the package. Capabilities are checked, you can access another process's
/// database if it has given you the capability.
pub struct KvRequest {
    pub package_id: PackageId,
    pub db: String,
    pub action: KvAction,
}

pub enum KvAction {
    Open,
    RemoveDb,
    Set { key: Vec&lt;u8&gt;, tx_id: Option&lt;u64&gt; },
    Delete { key: Vec&lt;u8&gt;, tx_id: Option&lt;u64&gt; },
    Get { key: Vec&lt;u8&gt; },
    BeginTx,
    Commit { tx_id: u64 },
    Backup,
}

pub enum KvResponse {
    Ok,
    BeginTx { tx_id: u64 },
    Get { key: Vec&lt;u8&gt; },
    Err { error: KvError },
}

pub enum KvError {
    NoDb,
    KeyNotFound,
    NoTx,
    NoCap { error: String },
    RocksDBError { action: String, error: String },
    InputError { error: String },
    IOError { error: String },
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net-api"><a class="header" href="#net-api">Net API</a></h1>
<p>TODO Ben</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nectarwit"><a class="header" href="#nectarwit"><code>nectar.wit</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h3 id="sqlite-api"><a class="header" href="#sqlite-api">SQLITE API</a></h3>
<p>Useful helper functions can be found in the <a href="https://github.com/uqbar-dao/process_lib">nectar_process_lib</a></p>
<h4 id="creatingopening-a-database-1"><a class="header" href="#creatingopening-a-database-1">Creating/Opening a database</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nectar_process_lib::sqlite;

let db = sqlite::open(our.package_id(), &quot;users&quot;)?;
// You can now pass this SQLite struct as a reference to other functions
<span class="boring">}</span></code></pre></pre>
<h4 id="write"><a class="header" href="#write">Write</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = &quot;INSERT INTO users (name) VALUES (?), (?), (?);&quot;.to_string();
let params = vec![
serde_json::Value::String(&quot;Bob&quot;.to_string()),
serde_json::Value::String(&quot;Charlie&quot;.to_string()),
serde_json::Value::String(&quot;Dave&quot;.to_string()),
];

sqlite.write(statement, params, None)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="read"><a class="header" href="#read">Read</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = &quot;SELECT FROM users;&quot;.to_string();
let rows = sqlite.read(query, vec![])?;
// rows: Vec&lt;HashMap&lt;String, serde_json::Value&gt;&gt;
println!(&quot;rows: {}&quot;, rows.len());
for row in rows {
    println!(row.get(&quot;name&quot;));
}
<span class="boring">}</span></code></pre></pre>
<h4 id="transactions-1"><a class="header" href="#transactions-1">Transactions</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tx_id = sqlite.begin_tx()?;

let statement = &quot;INSERT INTO users (name) VALUES (?);&quot;.to_string();
let params = vec![serde_json::Value::String(&quot;Eve&quot;.to_string())];
let params2 = vec![serde_json::Value::String(&quot;Steve&quot;.to_string())];

sqlite.write(statement, params, Some(tx_id))?;
sqlite.write(statement, params2, Some(tx_id))?;

sqlite.commit_tx(tx_id)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="api-1"><a class="header" href="#api-1">API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Actions are sent to a specific sqlite database, &quot;db&quot; is the name,
/// &quot;package_id&quot; is the package. Capabilities are checked, you can access another process's
/// database if it has given you the capability.
pub struct SqliteRequest {
    pub package_id: PackageId,
    pub db: String,
    pub action: SqliteAction,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum SqliteAction {
    Open,
    RemoveDb,
    Write {
        statement: String,
        tx_id: Option&lt;u64&gt;,
    },
    Read {
        query: String,
    },
    BeginTx,
    Commit {
        tx_id: u64,
    },
    Backup,
}

pub enum SqliteResponse {
    Ok,
    Read,
    BeginTx { tx_id: u64 },
    Err { error: SqliteError },
}

pub enum SqlValue {
    Integer(i64),
    Real(f64),
    Text(String),
    Blob(Vec&lt;u8&gt;),
    Boolean(bool),
    Null,
}

pub enum SqliteError {
    NoDb,
    NoTx,
    NoCap { error: String },
    UnexpectedResponse,
    NotAWriteKeyword,
    NotAReadKeyword,
    InvalidParameters,
    IOError { error: String },
    RusqliteError { error: String },
    InputError { error: String },
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal-api"><a class="header" href="#terminal-api">Terminal API</a></h1>
<p>The Nectar terminal is broken up into two segments: a Wasm app, called <code>terminal:terminal:nectar</code>, and a runtime module called <code>terminal:sys:nectar</code>.
The Wasm app is the central area where terminal logic and authority live.
It parses <code>Requests</code> by attempting to read the <code>body</code> field as a UTF-8 string, then parsing that string into various commands (usually denoted by a <code>/</code>) to perform.
The runtime module exists in order to actually use this app from the terminal which is launched by starting NectarOS.
It manages the raw input and presents an interface with features such as command history, text manipulation, and shortcuts.</p>
<p>To &quot;use&quot; the terminal as an API, one must simply send a <code>Request</code> to the <code>terminal:terminal:nectar</code> module.
This is a powerful capability, as it allows the process to send a <code>Request</code> to the terminal and have it be parsed and executed.
For this reason, users are unlikely to grant direct terminal access to most apps.</p>
<p>If one does have the capability to send <code>Request</code>s to the terminal, they can use the following commands:</p>
<pre><code>/hi &lt;node_id&gt; &lt;message&gt;
</code></pre>
<p>Send a raw network message to another node.</p>
<pre><code>/app &lt;address&gt;
/a &lt;address&gt;
</code></pre>
<p>Set the terminal to send all subsequent messages to a certain process.</p>
<pre><code>/app clear
/a clear
</code></pre>
<p>Remove the set process.</p>
<pre><code>/message &lt;address&gt; &lt;request_body&gt;
/m &lt;address&gt; &lt;request_body&gt;
</code></pre>
<p>Send a <code>Request</code> with the given body to the given address.
If <code>/app</code> or <code>/a</code> has been used to set a process, the address parameter here must be omitted, and the set one will be used instead.</p>
<p>The plaintext format of an <code>Address</code> looks like &lt;node_id&gt;<code>@</code>&lt;process_id&gt;.
<code>ProcessId</code> is a triple of the form &lt;process_name&gt;<code>:</code>&lt;package_name&gt;<code>:</code>&lt;publisher_name&gt;.</p>
<p>Example address:</p>
<pre><code>some_user.nec@process_one:my_cool_software:my_username.nec
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vfs-api"><a class="header" href="#vfs-api">VFS API</a></h1>
<p>Useful helper functions can be found in the <a href="https://github.com/uqbar-dao/process_lib">nectar_process_lib</a></p>
<p>The VFS API tries to map over the <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a> calls as directly as possible.</p>
<p>Every request takes a path and a corresponding action.
The paths look like normal relative paths within the folder <code>your_node_home/vfs</code>, but they include 2 parts at the start, a <code>package_id</code> and a <code>drive</code>.</p>
<p>Example path: <code>/your_package:publisher.nec/pkg/</code>. This folder is usually filled with files put into the /pkg folder when installing with app_store.</p>
<p>Capabilities are checked on the package_id/drive part of the path, when calling CreateDrive you'll be given &quot;Read&quot; and &quot;Write&quot; caps that you can share with other processes.</p>
<p>Other processes within your package will have access by default.
They can open and modify files and directories within their own package_id.</p>
<h3 id="openingcreating-a-drive"><a class="header" href="#openingcreating-a-drive">Opening/Creating a drive</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let drive_path: String = create_drive(our.package_id(), &quot;drive_name&quot;)?;
// you can now prepend this path to any files/directories you're interacting with
<span class="boring">}</span></code></pre></pre>
<h3 id="files-1"><a class="header" href="#files-1">Files</a></h3>
<h4 id="open-a-file"><a class="header" href="#open-a-file">Open a File</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Opens a file at path, if no file at path, creates one if boolean create is true.
let file_path = format!(&quot;{}/hello.txt&quot;, &amp;drive_path);
let file = open_file(&amp;file_path, true);
<span class="boring">}</span></code></pre></pre>
<h4 id="create-a-file"><a class="header" href="#create-a-file">Create a File</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Creates a file at path, if file found at path, truncates it to 0.
let file_path = format!(&quot;{}/hello.txt&quot;, &amp;drive_path);
let file = create(&amp;file_path);
<span class="boring">}</span></code></pre></pre>
<h4 id="read-a-file"><a class="header" href="#read-a-file">Read a File</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Reads the entire file, from start position.
/// Returns a vector of bytes.
let contents = file.read()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="write-a-file"><a class="header" href="#write-a-file">Write a File</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Write entire slice as the new file.
/// Truncates anything that existed at path before.
let buffer = b&quot;Hello!&quot;;
file.write(&amp;buffer)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="write-to-file"><a class="header" href="#write-to-file">Write to File</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Write buffer to file at current position, overwriting any existing data.
let buffer = b&quot;World!&quot;;
file.write_all(&amp;buffer)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="read-at-position"><a class="header" href="#read-at-position">Read at position</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Read into buffer from current cursor position
/// Returns the amount of bytes read.
let mut buffer = vec![0; 5];
file.read_at(&amp;buffer)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="set-length"><a class="header" href="#set-length">Set Length</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Set file length, if given size &gt; underlying file, fills it with 0s.
file.set_len(42)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="seek-to-a-position"><a class="header" href="#seek-to-a-position">Seek to a position</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Seek file to position.
/// Returns the new position.
let position = SeekFrom::End(0);
file.seek(&amp;position)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="sync"><a class="header" href="#sync">Sync</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Syncs path file buffers to disk.
file.sync_all()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="metadata"><a class="header" href="#metadata">Metadata</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Metadata of a path, returns file type and length.
let metadata = file.metadata()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="directories"><a class="header" href="#directories">Directories</a></h3>
<h4 id="open-a-directory"><a class="header" href="#open-a-directory">Open a Directory</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Opens or creates a directory at path.
/// If trying to create an existing file, will just give you the path.
let dir_path = format!(&quot;{}/my_pics&quot;, &amp;drive_path);
let dir = open_dir(&amp;file_path, true);
<span class="boring">}</span></code></pre></pre>
<h4 id="read-a-directory"><a class="header" href="#read-a-directory">Read a Directory</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Iterates through children of directory, returning a vector of DirEntries.
/// DirEntries contain the path and file type of each child.
let entries = dir.read()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="general-path-metadata"><a class="header" href="#general-path-metadata">General path Metadata</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Metadata of a path, returns file type and length.
let some_path = format!(&quot;{}/test&quot;, &amp;drive_path);
let metadata = metadata(&amp;some_path)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="api-2"><a class="header" href="#api-2">API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VfsRequest {
    /// path is always prepended by package_id, the capabilities of the topmost folder are checked
    /// &quot;/your_package:publisher.nec/drive_folder/another_folder_or_file&quot;
    pub path: String,
    pub action: VfsAction,
}

pub enum VfsAction {
    CreateDrive,
    CreateDir,
    CreateDirAll,
    CreateFile,
    OpenFile { create: bool },
    CloseFile,
    Write,
    WriteAt,
    Append,
    SyncAll,
    Read,
    ReadDir,
    ReadToEnd,
    ReadExact(u64),
    ReadToString,
    Seek { seek_from: SeekFrom },
    RemoveFile,
    RemoveDir,
    RemoveDirAll,
    Rename { new_path: String },
    Metadata,
    AddZip,
    CopyFile { new_path: String },
    Len,
    SetLen(u64),
    Hash,
}

pub enum SeekFrom {
    Start(u64),
    End(i64),
    Current(i64),
}

pub enum FileType {
    File,
    Directory,
    Symlink,
    Other,
}

pub struct FileMetadata {
    pub file_type: FileType,
    pub len: u64,
}

pub struct DirEntry {
    pub path: String,
    pub file_type: FileType,
}

pub enum VfsResponse {
    Ok,
    Err(VfsError),
    Read,
    SeekFrom(u64),
    ReadDir(Vec&lt;DirEntry&gt;),
    ReadToString(String),
    Metadata(FileMetadata),
    Len(u64),
    Hash([u8; 32]),
}

pub enum VfsError {
    NoCap { action: String, path: String },
    BadBytes { action: String, path: String },
    BadRequest { error: String },
    ParseError { error: String, path: String },
    IOError { error: String, path: String },
    CapChannelFail { error: String },
    BadJson { error: String },
    NotFound { path: String },
    CreateDirError { path: String, error: String },
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="websocket-api"><a class="header" href="#websocket-api">WebSocket API</a></h1>
<p>In NectarOS, WebSocket connects are made with a Rust <code>warp</code> server in the core <code>http_server:sys:nectar</code> process.
Each connection is assigned a <code>channel_id</code> that can be bound to a given process using a <code>WsRegister</code> message.
The process receives the <code>channel_id</code> for pushing data into the WebSocket, and any subsequent messages from that client will be forwarded to the bound process.</p>
<h2 id="opening-a-websocket-channel-from-a-client"><a class="header" href="#opening-a-websocket-channel-from-a-client">Opening a WebSocket Channel from a Client</a></h2>
<p>To open a WebSocket channel, connect to the main route on the node <code>/</code> and send a <code>WsRegister</code> message as either text or bytes.</p>
<p>The simplest way to connect from a browser is to use the <code>@uqbar/client-encryptor-api</code> like so:</p>
<pre><code>const api = new NectarEncryptorApi({
  nodeId: window.our.node, // this is set if the /our.js script is present in index.html
  processId: &quot;my_package:my_package:template.nec&quot;,
  onOpen: (_event, api) =&gt; {
    console.log('Connected to nectar node')
    // Send a message to the node via WebSocket
    api.send({ data: 'Hello World' })
  },
})
</code></pre>
<p><code>@uqbar/client-encryptor-api</code> is available here: <a href="https://www.npmjs.com/package/@uqbar/client-encryptor-api">https://www.npmjs.com/package/@uqbar/client-encryptor-api</a></p>
<p>Simple JavaScript/JSON example:</p>
<pre><code>function getCookie(name) {
    const cookies = document.cookie.split(';');
    for (let i = 0; i &lt; cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.startsWith(name)) {
            return cookie.substring(name.length + 1);
        }
    }
}

const websocket = new WebSocket(&quot;http://localhost:8080/&quot;);

const message = JSON.stringify({
    &quot;auth_token&quot;: getCookie(`nectar-auth_${nodeId}`),
    &quot;target_process&quot;: &quot;my_package:my_package:template.nec&quot;,
    &quot;encrypted&quot;: false,
});

websocket.send(message);
</code></pre>
<h2 id="handling-incoming-websocket-messages"><a class="header" href="#handling-incoming-websocket-messages">Handling Incoming WebSocket Messages</a></h2>
<p>Incoming WebSocket messages will be enums of <code>HttpServerRequest</code> with type <code>WebSocketOpen</code>, <code>WebSocketPush</code>, or <code>WebSocketClose</code>.</p>
<p>You will want to store the <code>channel_id</code> that comes in with <code>WebSocketOpen</code> so that you can push data to that WebSocket.
If you expect to have more than one client connected at a time, then you will most likely want to store the channel IDs in a Set (Rust <code>HashSet</code>).</p>
<p>With a <code>WebSocketPush</code>, the incoming message will be on the <code>LazyLoadBlob</code>, accessible with <code>get_blob()</code>.</p>
<p><code>WebSocketClose</code> will have the <code>channel_id</code> of the closed channel, so that you can remove it from wherever you are storing it.</p>
<p>A full example:</p>
<pre><code>fn handle_http_server_request(
    our: &amp;Address,
    message_archive: &amp;mut MessageArchive,
    source: &amp;Address,
    body: &amp;[u8],
    channel_ids: &amp;mut HashSet,
) -&gt; anyhow::Result&lt;()&gt; {
    let Ok(server_request) = serde_json::from_slice::&lt;HttpServerRequest&gt;(body) else {
        // Fail silently if we can't parse the request
        return Ok(());
    };

    match server_request {
        HttpServerRequest::WebSocketOpen { channel_id, .. } =&gt; {
            // Set our channel_id to the newly opened channel
            // Note: this code could be improved to support multiple channels
            channel_ids.insert(channel_id);
        }
        HttpServerRequest::WebSocketPush { .. } =&gt; {
            let Some(blob) = get_blob() else {
                return Ok(());
            };

            handle_chat_request(
                our,
                message_archive,
                our_channel_id,
                source,
                &amp;blob.bytes,
                false,
            )?;
        }
        HttpServerRequest::WebSocketClose(_channel_id) =&gt; {
          channel_ids.remove(channel_id);
        }
        HttpServerRequest::Http(IncomingHttpRequest { method, raw_path, .. }) =&gt; {
            // Handle incoming HTTP requests here
        }
    };

    Ok(())
}
</code></pre>
<h2 id="pushing-data-to-a-client-via-websocket"><a class="header" href="#pushing-data-to-a-client-via-websocket">Pushing Data to a Client via WebSocket</a></h2>
<p>Pushing data to a connected WebSocket is very simple. Call the <code>send_ws_push</code> function from <code>process_lib</code>:</p>
<pre><code>pub fn send_ws_push(
    node: String,
    channel_id: u32,
    message_type: WsMessageType,
    blob: LazyLoadBlob,
) -&gt; anyhow::Result&lt;()&gt;
</code></pre>
<p><code>node</code> will usually be <code>our.node</code> (although you can also send a WS push to another node's <code>http_server</code>!), <code>channel_id</code> is the client you want to send to, <code>message_type</code> will be either <code>WsMessageType::Text</code> or <code>WsMessageType::Binary</code>, and <code>blob</code> will be a standard <code>LazyLoadBlob</code> with an optional <code>mime</code> field and required <code>bytes</code> field.</p>
<p>If you would prefer to send the request without the helper function, this is that what <code>send_ws_push</code> looks like under the hood:</p>
<pre><code>Request::new()
    .target(Address::new(
        node,
        ProcessId::from_str(&quot;http_server:sys:nectar&quot;).unwrap(),
    ))
    .body(
        serde_json::json!(HttpServerRequest::WebSocketPush {
            channel_id,
            message_type,
        })
        .to_string()
        .as_bytes()
        .to_vec(),
    )
    .blob(blob)
    .send()?;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/customize-buttons.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
